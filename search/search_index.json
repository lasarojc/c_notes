{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C(++) para n\u00e3o \"Computeiros\" Uma introdu\u00e7\u00e3o ao racioc\u00ednio computacional Com contribui\u00e7\u00f5es de Paulo R. Coelho e Anilton Joaquim","title":"C(++) para n\u00e3o \"Computeiros\""},{"location":"#c-para-nao-computeiros","text":"","title":"C(++) para n\u00e3o \"Computeiros\""},{"location":"#uma-introducao-ao-raciocinio-computacional","text":"Com contribui\u00e7\u00f5es de Paulo R. Coelho e Anilton Joaquim","title":"Uma introdu\u00e7\u00e3o ao racioc\u00ednio computacional"},{"location":"preface/","text":"Pref\u00e1cio A habilidade de olhar para um problema complexo e extrair do mesmo um conjunto de problemas mais simples e, portanto, mais facilmente resolv\u00edveis, \u00e9 essencial aos profissionais da computa\u00e7\u00e3o. Isto por qu\u00ea na automatiza\u00e7\u00e3o de tarefas por um computador, \u00e9 necess\u00e1rio quebr\u00e1-las em unidades m\u00ednimas, que sejam compreens\u00edveis pela m\u00e1quina. Acontece que esta habilidade \u00e9 tamb\u00e9m \u00fatil \u00e0 profissionais das mais diversas \u00e1reas, da constru\u00e7\u00e3o civil \u00e0 de foguetes, da medicina \u00e0 psicologia, e \u00e0 todas as \u00e1reas da engenharia. A esta habilidade, chamamos de racioc\u00ednio computacional. Este material \u00e9 uma tentativa de organizar um curso de racioc\u00ednio computacional, via aprendizado de t\u00e9cnicas b\u00e1sicas de programa\u00e7\u00e3o. Nosso p\u00fablico alvo s\u00e3o os estudantes cujo t\u00f3pico principal de estudo n\u00e3o \u00e9 a Ci\u00eancia da Computa\u00e7\u00e3o ou \u00e1reas afins, embora estes tamb\u00e9m possam us\u00e1-lo como uma introdu\u00e7\u00e3o aos estudos mais aprofundados que far\u00e3o. Este tipo de curso \u00e9 tradicional nos estudos de engenharia e mesmo outras \u00e1reas e, provavelmente por raz\u00f5es hist\u00f3ricas, \u00e9 dado usando-se como ferramenta a linguagem de programa\u00e7\u00e3o C. Aqui usaremos C, mas n\u00e3o toda ela e n\u00e3o somente ela. Em vez disso, usaremos parte da linguagem C, extendida com partes da linguagem C++. A esta combina\u00e7\u00e3o particular, chamaremos C(++). O material \u00e9 dividido em cap\u00edtulos correspondendo a aproximadamente uma aula de 100 minutos, provavelmente mais do que comporiam um curso deste tipo, dando assim op\u00e7\u00f5es para que os professores usando livro variem a estrutura de seus cursos. Sugere-se que a primeira parte do material, mais b\u00e1sica, seja seguida na \u00edntegra e na ordem em que \u00e9 apresentada. A segunda parte contem t\u00f3picos mais (mas n\u00e3o completamente) independentes. A terceira parte apresenta t\u00f3picos mais avan\u00e7ados, que poder\u00e3o ser usadas em turmas com melhor rendimento. Cada cap\u00edtulo \u00e9 iniciado com uma motiva\u00e7\u00e3o para o t\u00f3pico apresentado, seguido de se\u00e7\u00f5es com a teoria e exemplos. O cap\u00edtulo termina, ent\u00e3o, com exerc\u00edcios propostos e problemas para serem resolvidos em laborat\u00f3rio. O material foi inicialmente escrito em LaTeX e esta convers\u00e3o para markdown \u00e9 um esfor\u00e7o para organizar minhas notas de aula em um s\u00f3 local e formato. Eu n\u00e3o estou ativamente usando este material e por isso a convers\u00e3o dever\u00e1 ser lenta. Se voc\u00ea estiver usando este material, me avise, pois poder\u00e1 (talvez) me estimular a convert\u00ea-lo mais rapidamente. Se voc\u00ea tem sugest\u00f5es de modifica\u00e7\u00f5es a este material, por favor proponha como PR ou entre em contato comigo. Este material foi usado por outros professores na UFU, que tamb\u00e9m contribu\u00edram para o mesmo, mas n\u00e3o como co-autores, dado o volume de suas contribui\u00e7\u00f5es.","title":"Apresenta\u00e7\u00e3o"},{"location":"preface/#prefacio","text":"A habilidade de olhar para um problema complexo e extrair do mesmo um conjunto de problemas mais simples e, portanto, mais facilmente resolv\u00edveis, \u00e9 essencial aos profissionais da computa\u00e7\u00e3o. Isto por qu\u00ea na automatiza\u00e7\u00e3o de tarefas por um computador, \u00e9 necess\u00e1rio quebr\u00e1-las em unidades m\u00ednimas, que sejam compreens\u00edveis pela m\u00e1quina. Acontece que esta habilidade \u00e9 tamb\u00e9m \u00fatil \u00e0 profissionais das mais diversas \u00e1reas, da constru\u00e7\u00e3o civil \u00e0 de foguetes, da medicina \u00e0 psicologia, e \u00e0 todas as \u00e1reas da engenharia. A esta habilidade, chamamos de racioc\u00ednio computacional. Este material \u00e9 uma tentativa de organizar um curso de racioc\u00ednio computacional, via aprendizado de t\u00e9cnicas b\u00e1sicas de programa\u00e7\u00e3o. Nosso p\u00fablico alvo s\u00e3o os estudantes cujo t\u00f3pico principal de estudo n\u00e3o \u00e9 a Ci\u00eancia da Computa\u00e7\u00e3o ou \u00e1reas afins, embora estes tamb\u00e9m possam us\u00e1-lo como uma introdu\u00e7\u00e3o aos estudos mais aprofundados que far\u00e3o. Este tipo de curso \u00e9 tradicional nos estudos de engenharia e mesmo outras \u00e1reas e, provavelmente por raz\u00f5es hist\u00f3ricas, \u00e9 dado usando-se como ferramenta a linguagem de programa\u00e7\u00e3o C. Aqui usaremos C, mas n\u00e3o toda ela e n\u00e3o somente ela. Em vez disso, usaremos parte da linguagem C, extendida com partes da linguagem C++. A esta combina\u00e7\u00e3o particular, chamaremos C(++). O material \u00e9 dividido em cap\u00edtulos correspondendo a aproximadamente uma aula de 100 minutos, provavelmente mais do que comporiam um curso deste tipo, dando assim op\u00e7\u00f5es para que os professores usando livro variem a estrutura de seus cursos. Sugere-se que a primeira parte do material, mais b\u00e1sica, seja seguida na \u00edntegra e na ordem em que \u00e9 apresentada. A segunda parte contem t\u00f3picos mais (mas n\u00e3o completamente) independentes. A terceira parte apresenta t\u00f3picos mais avan\u00e7ados, que poder\u00e3o ser usadas em turmas com melhor rendimento. Cada cap\u00edtulo \u00e9 iniciado com uma motiva\u00e7\u00e3o para o t\u00f3pico apresentado, seguido de se\u00e7\u00f5es com a teoria e exemplos. O cap\u00edtulo termina, ent\u00e3o, com exerc\u00edcios propostos e problemas para serem resolvidos em laborat\u00f3rio. O material foi inicialmente escrito em LaTeX e esta convers\u00e3o para markdown \u00e9 um esfor\u00e7o para organizar minhas notas de aula em um s\u00f3 local e formato. Eu n\u00e3o estou ativamente usando este material e por isso a convers\u00e3o dever\u00e1 ser lenta. Se voc\u00ea estiver usando este material, me avise, pois poder\u00e1 (talvez) me estimular a convert\u00ea-lo mais rapidamente. Se voc\u00ea tem sugest\u00f5es de modifica\u00e7\u00f5es a este material, por favor proponha como PR ou entre em contato comigo. Este material foi usado por outros professores na UFU, que tamb\u00e9m contribu\u00edram para o mesmo, mas n\u00e3o como co-autores, dado o volume de suas contribui\u00e7\u00f5es.","title":"Pref\u00e1cio"},{"location":"intro/","text":"O computador \u00e9 uma m\u00e1quina burra Computadores s\u00e3o m\u00e1quinas \"burras\" que n\u00e3o fazem nada al\u00e9m de seguir instru\u00e7\u00f5es. Sendo assim, eles precisam de instru\u00e7\u00f5es precisas e detalhadas sobre o que fazer. Agora que est\u00e1 ciente deste fato, voc\u00ea est\u00e1 pronto para entender que quando o programa n\u00e3o fizer o que voc\u00ea quer, \u00e9 por que voc\u00ea lhe deu instru\u00e7\u00f5es erradas. Para que n\u00e3o cometamos erros (ou pelo menos para minimiz\u00e1-los), ao montar a sequ\u00eancia de instru\u00e7\u00f5es que resolvem determinado problema precisamos, antes de qualquer outra coisa, entender o problema e sermos capazes de resolv\u00ea-lo ``na m\u00e3o''. Uma vez que tenhamos uma solu\u00e7\u00e3o teremos o que chamamos de um \\emph{algoritmo}\\footnote{\\url{ http://www.merriam-webster.com/dictionary/algorithm }}. Algoritmo Um algoritmo nada mais \u00e9 que um conjunto de instru\u00e7\u00f5es para se resolver um problema. Por exemplo, para se destrancar uma porta temos o seguinte algoritmo: \\[\\begin{itemize} \\item Coloque a chave na fechadura \\item Gire a chave \\end{itemize}\\] \u00c9 claro que este algoritmo est\u00e1 em um n\u00edvel de abstra\u00e7\u00e3o muito alto e que poderia ser muito mais detalhado. Por exemplo, n\u00e3o h\u00e1 por qu\u00ea destrancar a porta se ela j\u00e1 estiver destrancada e n\u00e3o h\u00e1 como destranc\u00e1-la se n\u00e3o estiver de posse da chave. Quanto mais detalhada sua sequ\u00eancia de passos, mais pr\u00f3ximo de algo intelig\u00edvel ao computador ela ser\u00e1. Para que isto ocorra, isto \u00e9, para que o computador entenda suas intru\u00e7\u00f5es, al\u00e9m de detalhadas, eles precisam ser escritas em uma linguagem de programa\u00e7\u00e3o. {Linguagem de Programa\u00e7\u00e3o} De acordo com fontes altamente confi\u00e1veis\\footnote{\\url{ http://en.wikipedia.org/wiki/Programming _language}} \\begin{quote} %\\emph{A programming language is an artificial language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs that control the behavior of a machine and/or to express algorithms precisely.} Uma linguagem de programa\u00e7\u00e3o \u00e9 uma linguagem artificial projetada para comunicar instru\u00e7\u00f5es a uma m\u00e1quina, particularmente computadores. Linguagens de programa\u00e7\u00e3o podem ser usadas para criar programas que controlam o comportamento da m\u00e1quina e expressar algoritmos de forma precisa (n\u00e3o amb\u00edgua). \\end{quote} De forma simplificada, uma liguagem de programa\u00e7\u00e3o \u00e9 um conjunto de palavras e regras sobre como us\u00e1-las na descri\u00e7\u00e3o de algoritmos interpret\u00e1veis por um computador. Existem diversas \\footnote{Uma listagem n\u00e3o completa mas ainda assim impressionante pode ser encontrada em \\url{ http://en.wikipedia.org/wiki/Categorical_list_of_programming_languages }} linguagens de programa\u00e7\u00e3o, tendo cada uma seus pontos fortes e fracos; neste curso, usaremos as linguagens C e C++. {A linguagem C(++)} A primeira encarna\u00e7\u00e3o da linguagem de programa\u00e7\u00e3o \\href{ http://en.wikipedia.org/wiki/C_(programming_language)}{C } foi desenvolvida no fim da d\u00e9cada de 60, tendo sido extendida, melhorada e padronizada v\u00e1rias vezes depois. A linguagem C++, que extende a linguagem C com diversas funcionalidades como orienta\u00e7\u00e3o a objetos, come\u00e7ou a ser desenvolvida na d\u00e9cada de 70 e, como a linguagem C, tamb\u00e9m passou por v\u00e1rias reformas. Como resultado, hoje temos uma linguagem C++ padronizada que pode ser usada, mesmo que com certa dificuldade, para se programar em v\u00e1rios sistemas operacionais de forma port\u00e1vel. Al\u00e9m disso, a linguagem C++ \u00e9 um super conjunto da linguagem C. Ou seja, todo e qualquer programa em C tamb\u00e9m \u00e9 um programa em C++, mesmo que o oposto n\u00e3o seja verdade. Como j\u00e1 mencionado, neste curso usaremos primariamente a linguagem C. Contudo, uma vez que o objetivo deste curso \u00e9 introduzir o uso do racioc\u00edcio computacional e n\u00e3o aprofundar no uso de determinada linguagem, estudaremos somente os aspectos mais b\u00e1sicos da linguagem C. Al\u00e9m disso, usaremos partes da linguagem C++ para simplificar o desenvolvimento dos nossos programas. Assim, nos referiremos \u00e0 linguagem usada como C(++), pois nem \u00e9 toda a C, e nem \u00e9 somente C, mas n\u00e3o chega a ser C++. Mas chega de ladainha; vamos ao nosso primeiro programa em linguagem C(++)! {Meu Primeiro Programa} O algoritmo em linguagem C(++) \\footnote{Usaremos tamb\u00e9m os termos programa'' e c\u00f3digo'' para nos referirmos a tais algoritmos.}, abaixo, descreve para o computador os passos necess\u00e1rios para se escrever a mensagem Ol\u00e1 Mundo!'' na tela do computador. N\u00e3o se preocupe com os detalhes de como isso \u00e9 feito agora, mas foque-se nos seguintes aspectos: \\begin{itemize} \\item existem v\u00e1rias formas de se dizer Ol\u00e1 Mundo!'', por exemplo se pode saltar antes de faz\u00ea-lo, agaixar, ou fechar os olhos. Todas estas formas s\u00e3o corretas, embora algumas possam lhe causar certo constrangimento quando em p\u00fablico. \\item um c\u00f3digo de computador deve ser entendido, al\u00e9m de pelos computadores, tamb\u00e9m por humanos. Sendo assim, \u00e9 imprescind\u00edvel que voc\u00ea mantenha o c\u00f3digo organizado. \\item usar acentos em um programa \u00e9 fonte de dores de cabe\u00e7a; melhor simplesmente ignor\u00e1-los em nosso curso. \\end{itemize} \\begin{lstlisting}[caption=Ola Mundo!, label=cod:ola] include using namespace std; int main() { cout << \"Ola Mundo!\" << endl; return 0; } \\end{lstlisting} Analisando o C\u00f3digo~\\ref{cod:ola}, podemos facilmente identificar a linha que cont\u00e9m a frase Ola Mundo!''. Esta linha \u00e9 a que efetivamente \\emph{escreve} na tela do computador. Altere esta linha para que contenha, por exemplo, seu nome em vez da palavra \\emph{Mundo}. Digamos que seu nome seja \\emph{Feissibukson}. Este programa agora escreve na tela do computador os dizeres Ola Feissibukson!''. Para entendermos o que as demais linhas fazem, precisamos passar para o nosso pr\u00f3ximo problema/programa. {\u00c1rea de um Ret\u00e2ngulo} A \u00e1rea de um ret\u00e2ngulo pode ser facilmente calculada caso voc\u00ea saiba o comprimento de sua base e de sua altura. Matematicamente, seja \\(b\\) o comprimento da base e \\(a\\) a altura. A fun\u00e7\u00e3o \\(f\\) equivalente \u00e0 \u00e1rea do ret\u00e2ngulo pode ser definda como: \\(f(a,b) = a*b\\) . Isto \u00e9, a fun\u00e7\u00e3o \\(f\\) tem dois par\u00e2metros (a altura \\(a\\) e base \\(b\\) do ret\u00e2ngulo) e calcula a \u00e1rea como sendo a multiplica\u00e7\u00e3o de \\(a\\) e \\(b\\) . Em linguagem C(++) a fun\u00e7\u00e3o \\(f\\) pode-se escrever esta fun\u00e7\u00e3o como mostrado no C\u00f3digo~\\ref{cod:area}, que analisaremos em seguida. \\[\\begin{lstlisting}[caption=\u00c1rea de um ret\u00e2ngulo, label=cod:area] int f(int a, int b) { return a * b; } \\end{lstlisting}\\] A linha 1 do c\u00f3digo define a fun\u00e7\u00e3o \\verb|f| como uma fun\u00e7\u00e3o que aceita dois par\u00e2metros \\lstinline!a! e \\lstinline!b!. Al\u00e9m disso, esta fun\u00e7\u00e3o tamb\u00e9m define que cada um destes par\u00e2metros \u00e9 um n\u00famero inteiro ao preceder cada par\u00e2metro pela palavra \\lstinline!int!. Finalmente, esta linha tamb\u00e9m define que o resultado da fun\u00e7\u00e3o ser\u00e1 um n\u00famero inteiro ao preceder o nome da fun\u00e7\u00e3o (\\lstinline!f!) pela palavra \\lstinline!int!. Isto quer dizer que voc\u00ea n\u00e3o pode usar esta fun\u00e7\u00e3o para calcular a \u00e1rea de ret\u00e2ngulos cujos lados n\u00e3o sejam inteiros. Mas n\u00e3o se preocupe, corrigiremos esta defici\u00eancia daqui a pouco. As linhas 2 e 4 definem o \\emph{corpo da fun\u00e7\u00e3o}, isto \u00e9, quais outras linhas s\u00e3o partes da fun\u00e7\u00e3o \\lstinline!f!. Toda fun\u00e7\u00e3o na linguagem C precisa ter definido seu come\u00e7o e fim usando \\lstinline!{! e \\lstinline!}!, respectivamente. A linha 3 do c\u00f3digo \u00e9 onde o c\u00e1lculo da \u00e1rea \u00e9 efetivamente executado: \\lstinline!a*b!. Al\u00e9m disso, esta linha define tamb\u00e9m qual \u00e9 o resultado da fun\u00e7\u00e3o ao preceder o resultado da multiplica\u00e7\u00e3o por \\lstinline!return!. Como a multiplica\u00e7\u00e3o de dois n\u00fameros inteiros s\u00f3 pode resultar em um n\u00famero inteiro, o resultado da fun\u00e7\u00e3o tamb\u00e9m \u00e9 inteiro, est\u00e1 justificado o tipo da fun\u00e7\u00e3o ser \\lstinline|int|. {Tipos Primitivos da Linguagem C} O C\u00f3digo~\\ref{cod:area}, como mencionado, tem a limita\u00e7\u00e3o de s\u00f3 calcular a \u00e1rea de ret\u00e2ngulos cujos lados tenham tamanhos inteiros. Para corrigir esta defici\u00eancia, vamos alter\u00e1-lo para que aceite n\u00fameros reais. Em computa\u00e7\u00e3o, n\u00fameros reais s\u00e3o tamb\u00e9m chamados de n\u00fameros com \\emph{pontos flutuantes} e, em linguagem C, simplesmente de \\lstinline!float!. Sendo assim, podemos corrigir o programa simplesmente substituindo as ocorr\u00eancias da palavra \\lstinline!int! por \\lstinline!float!, resultando no C\u00f3digo~\\ref{cod:area1} \\[\\begin{lstlisting}[caption=\u00c1rea de ret\u00e2ngulo com dimens\u00f5es reais., label=cod:area1] float f(float a, float b) { return a * b; } \\end{lstlisting}\\] Pronto, a fun\u00e7\u00e3o agora \\emph{recebe} dois par\u00e2metros do tipo \\verb|float| e \\emph{retorna} um resultado tamb\u00e9m deste tipo. Juntamente com outros tipos que ser\u00e3o vistos adiante no curso, \\verb|int| e \\verb|float| s\u00e3o chamados de tipos de dados primitivos da linguagem. Isto sugere, obviamente, que h\u00e1 tamb\u00e9m tipos n\u00e3o primitivos, e nada poderia ser mais verdade. Estes tipos, contudo, s\u00f3 ser\u00e3o vistos bem mais adiante no curso, no Cap\u00edtulo~?\\todo{Adicionar refer\u00eancia}. {Organiza\u00e7\u00e3o do C\u00f3digo} \u00c9 poss\u00edvel facilmente perceber um padr\u00e3o nos exemplos de c\u00f3digo apresentados at\u00e9 agora: \\begin{itemize} \\item A linha definindo a fun\u00e7\u00e3o \u00e9 seguida por uma linha contendo apenas um \\verb|{| que \u00e9 alinhado com o in\u00edcio da linha acima. \\item A \u00faltima linha da fun\u00e7\u00e3o cont\u00e9m apenas um \\verb|}|, alinhado com o \\verb|{| do in\u00edcio da fun\u00e7\u00e3o. \\item Todas as linhas entre o \\verb|{| inicial e o \\verb|}| final est\u00e3o alinhas e mais avan\u00e7adas em rela\u00e7\u00e3o \u00e0s chaves. \\end{itemize} Esta organiza\u00e7\u00e3o do c\u00f3digo serve para facilitar a leitura do c\u00f3digo, uma vez que torna extremamente \u00f3bvio onde a fun\u00e7\u00e3o come\u00e7a e termina. Esta t\u00e9cnica \u00e9 chamada \\emph{indenta\u00e7\u00e3o}. Algo que faltou nestes exemplos e que tamb\u00e9m serve ao prop\u00f3sito de facilitar o entendimento do c\u00f3digo s\u00e3o os chamados coment\u00e1rios. O exemplo no C\u00f3digo~\\ref{cod:comment} mostra como a fun\u00e7\u00e3o \\verb|f| poderia ser comentada. \\[\\begin{lstlisting}[caption={\u00c1rea do ret\u00e2ngulo, com coment\u00e1rios.}, label=cod:comment] /* * A funcao a seguir calcula a area de um retangulo de base * b e altura a. Os parametros e resultado da funcao sao do * tipo float. */ float f(float a, float b) { //Calcula e retorna a area do retangulo. return a * b; } \\end{lstlisting}\\] Observe que h\u00e1 dois tipos de coment\u00e1rios no c\u00f3digo. O primeiro come\u00e7a com \\verb|*| e termina com \\verb|*| e o segundo come\u00e7a com \\verb|\\| e termina no final da linha. Todos os coment\u00e1rios servem somente ao programador e s\u00e3o completamente ignorados pelo computador. Os coment\u00e1rios podem ser poderosos aliados na hora de procurar por erros no seu c\u00f3digo, uma vez que permitem desabilitar trechos do mesmo. Finalmente, \u00e9 muito importante nomear suas fun\u00e7\u00f5es e par\u00e2metros com nomes intuitivos. Seguindo esta orienta\u00e7\u00e3o, escreveremos a \u00faltima vers\u00e3o de nossa fun\u00e7\u00e3o. \\[\\begin{lstlisting}[caption={\u00c1rea do ret\u00e2ngulo, com coment\u00e1rios e nomes intuitivos.}, label=cod:intui] /* * A funcao a seguir calcula a area de um retangulo de base * base e altura altura. Os parametros e resultado da funcao * sao do tipo float. */ float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } \\end{lstlisting}\\] {Sa\u00edda de Dados} Em computa\u00e7\u00e3o, diz-se que um programa est\u00e1 executando a sa\u00edda de dados quando envia para ``fora'' do programa tais dados. Exemplos comuns de sa\u00edda de dados s\u00e3o a escrita em arquivo, o envio de mensagens na rede ou, o mais comum, a exibi\u00e7\u00e3o de dados na tela. Em nossos programas, a sa\u00edda de dados efetuada mais comumente ser\u00e1 para a tela do computador. Este tipo de sa\u00edda, por ser t\u00e3o comum, \u00e9 chamada de a sa\u00edda padr\u00e3o do C(++), ou simplesmente \\emph{C out}. Para enviar dados para a sa\u00edda do C(++), usamos a express\u00e3o \\lstinline|cout <<|, seguido do dado a ser impresso na tela. Por exemplo, para imprimir a mensagem ``Ol\u00e1 Jo\u00e3o'', simplesmente adicionamos \\lstinline|cout << \"Ola Joao\"| ao c\u00f3digo. Observe que o simbolos \\lstinline|<<| funciona como uma seta dizendo para onde os dados devem, neste caso, \\lstinline|cout|. \u00c9 poss\u00edvel enviar v\u00e1rios tipos de dados para a sa\u00edda, como veremos no decorrer do curso. No caso da tela, os dados s\u00e3o convertidos para sua forma textual, para que possam ser lidos pelo usu\u00e1rio. O computador realiza a convers\u00e3o de acordo com o tipo original do dado: se o dado j\u00e1 for um texto, ele \u00e9 simplesmente copiado para a tela; se for um n\u00famero, ele \u00e9 convertido para um conjunto de d\u00edgitos que o represente. Por exemplo, o trecho de programa \\begin{lstlisting} cout << \"numero \"; cout << 10; \\end{lstlisting} gera a sa\u00edda \\verb|numero 10| na tela. Observe que a palavra \\lstinline|numero| no programa aparece entre aspas duplas e que o numero 10. Isto ocorre por qu\u00ea \\lstinline|numero| \u00e9 um texto, e \\lstinline|10| \u00e9 um n\u00famero; todos os textos devem ser colocados entre aspas duplas, para que o computador o identifique como tal, mas o mesmo n\u00e3o \u00e9 necess\u00e1rio para n\u00fameros. Veja bem, o n\u00famero \\lstinline|10| \u00e9 bem difernte de \\lstinline|\"10\"| pois, por exemplo, \\lstinline|10| pode ser somado a outro n\u00famero (\\lstinline|10 + 32|), mas \\lstinline|\"10\"| n\u00e3o. Para simplificar a sa\u00edda de dados, em C(++) \u00e9 poss\u00edvel encadear v\u00e1rias sa\u00eddas em uma s\u00f3, assim \\begin{lstlisting} cout << \"numero \" << 10; \\end{lstlisting} com o mesmo efeito do c\u00f3digo anterior. Se houver necessidade de se iniciar nova linha na ``impress\u00e3o'' na tela, basta enviar \\lstinline|endl| (contra\u00e7\u00e3o de \\emph{end line}) para a sa\u00edda. Assim, o c\u00f3digo \\begin{lstlisting} cout << \"numero \" << 10 << endl << \"texto \" << endl; \\end{lstlisting} imprime na tela o texto \\begin{verbatim} numero 10 texto \\end{verbatim} Finalmente, quando uma ``chamada'' a uma fun\u00e7\u00e3o \u00e9 enviada para o \\lstinline|cout|, o que \u00e9 impresso \u00e9 o resultado da fun\u00e7\u00e3o. Assim, \\begin{lstlisting} cout << \"sen(1)\" << endl << sen(1); \\end{lstlisting} imprime na tela o texto \\begin{verbatim} sen(1) 0 \\end{verbatim} Voc\u00ea ver\u00e1 v\u00e1rios exemplos de usos do \\lstinline|cout| na pr\u00f3xima se\u00e7\u00e3o. {A Fun\u00e7\u00e3o \\texttt{main}} Que o computador \u00e9 uma m\u00e1quina burra e executa somente o que voc\u00ea manda voc\u00ea j\u00e1 deve ter entendido, mas como mand\u00e1-lo executar algo? Em linguagem C(++), o computador \\emph{sempre} come\u00e7a a execu\u00e7\u00e3o de um c\u00f3digo pela fun\u00e7\u00e3o \\verb|main|, a fun\u00e7\u00e3o principal. Sendo assim, se voc\u00ea quer dizer ao computador que calcule a \u00e1rea de um ret\u00e2ngulo, ent\u00e3o esta ordem dever partir, de alguma forma, da fun\u00e7\u00e3o \\verb|main|. Para um exemplo,veja o seguinte c\u00f3digo. \\begin{lstlisting} include using namespace std; /* * A funcao a seguir calcula a area de um retangulo de base * base e altura altura. Os parametros e resultado da funcao * sao do tipo float. */ float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { //Calculemos a area de alguns retangulos. cout << area_retangulo(3.3, 2.0) << endl; cout << area_retangulo(2.0, 2.0) << endl; //Lembre-se, todo numero inteiro tambem e um numero real. cout << area_retangulo(4, 2) << endl; return 0; } \\end{lstlisting} Algumas observa\u00e7\u00f5es importantes sobre a fun\u00e7\u00e3o \\verb|main|: \\begin{enumerate} \\item A fun\u00e7\u00e3o \\verb|main| tem sempre um resultado do tipo inteiro e seu resultado \u00e9 sempre 0 (\\verb|return 0;|)\\footnote{Na verdade, nem nem sempre \u00e9 0, mas por enquanto definiremos sempre assim.} \\item Fun\u00e7\u00e3o \\verb|main| \u00e9 como um \\emph{highlander}: s\u00f3 pode haver uma! Isto \u00e9, cada programa s\u00f3 pode conter a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o com este nome. Ali\u00e1s, a regra vale para toda e qualquer fun\u00e7\u00e3o; se n\u00e3o fosse assim, o computador n\u00e3o saberia a qual fun\u00e7\u00e3o voc\u00ea est\u00e1 se referindo em seu c\u00f3digo. \\item Finalmente, a fun\u00e7\u00e3o \\verb|area_retangulo| aparece antes da fu\u00e7\u00e3o \\verb|main| no programa. Isto deve ser verdade para todas as fun\u00e7\u00f5es do seu programa. Isto ocorre por qu\u00ea, antes de executar a fun\u00e7\u00e3o \\verb|main|, o computador precisa aprender sobre a exist\u00eancia das outras fun\u00e7\u00f5es. \\end{enumerate} O c\u00f3digo como est\u00e1, includindo as duas linhas iniciais que ainda n\u00e3o sabem para que servem, pronto'' para ser executado no seu computador. No pr\u00f3ximo cap\u00edtulo veremos exatamente como fazer isso. At\u00e9 l\u00e1, executemos o c\u00f3digo na m\u00e3o'': \\begin{itemize} \\item O programa come\u00e7a a executar pela fun\u00e7\u00e3o \\lstinline|main|; somente o que est\u00e1 no corpo desta fun\u00e7\u00e3o \u00e9 executado. \\item Na linha 18 n\u00e3o h\u00e1 o que executar, pois \u00e9 s\u00f3 um coment\u00e1rio. \\item Na linha 19, como vimos no C\u00f3digo~\\ref{cod:ola}, est\u00e1 se dizendo para o computador escrever algo na tela. Este algo \u00e9 o resultado da aplica\u00e7\u00e3o da fun\u00e7\u00e3o \\lstinline|area_retangulo| aos par\u00e2metros 3.3 e 2.0.\\footnote{Observe o uso de .'' como separador de casas decimais.}. Para que se conhe\u00e7a este resultado, o programa executa a fun\u00e7\u00e3o \\lstinline|area_retangulo|. \\item A linha 13 calcula a \u00e1rea do ret\u00e2ngulo, que \u00e9 ent\u00e3o retornado para a linha 19. \\item Na linha 19, a \\emph{chamada} da fun\u00e7\u00e3o \u00e9 substitu\u00edda'' pelo resultado, e o n\u00famero 6.6 \u00e9 escrito na tela do computador. Na sequ\u00eancia, \u00e9 escrito tamb\u00e9m \\lstinline|endl|, que faz com que o computador salte para a pr\u00f3xima linha da tela do computador. \\item Na linha 20 o procedimento todo \u00e9 repetido, agora escrevendo o valor 4.0 na tela. \\item Na linha 23 tamb\u00e9m se repete o procedimento, mas agora passando como par\u00e2metro para a fun\u00e7\u00e3o os valores inteiros 4 e 2. Como todo n\u00famero inteiro tamb\u00e9m \u00e9 um n\u00famero real, a fun\u00e7\u00e3o \u00e9 novamente executada e o valor 8.0 \u00e9 impresso na tela. \\end{itemize} {Conclus\u00e3o} Os c\u00f3digos apresentados neste cap\u00edtulo, apesar de simples, ilustraram v\u00e1rios pontos importantes da programa\u00e7\u00e3o de computadores em geral e da linguagem C em espec\u00edfico. Estes pontos podem ser sumarizados assim: \\begin{itemize} \\item Em C(++) pode-se definir fun\u00e7\u00f5es que executem computa\u00e7\u00f5es bem definidas e espec\u00edficas. \\item C(++) tem v\u00e1rios \\emph{tipos} de dados, como \\verb|int| (n\u00fameros inteiros) e \\verb|float| (n\u00fameros reais). \\item \u00c9 importante manter o c\u00f3digo organizado, comentado e indentado. Isso facilita seu entendimento e manuten\u00e7\u00e3o. \\end{itemize} {Exerc\u00edcios} \\[\\begin{exercicio} Escreva um fun\u00e7\u00e3o que calcule a \u00e1rea de um c\u00edrculo. Observe que a linguagem C \u00e9 baseada na l\u00edngua inglesa, na qual se separa casas decimais por \\verb|.| e n\u00e3o por \\verb|,|. Logo, $\\Pi$ \u00e9 igual 3.14 e n\u00e3o 3,14. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva uma fun\u00e7\u00e3o que calcule a \u00e1rea de um tri\u00e2ngulo. \\end{exercicio}\\] \\chapter{Compila\u00e7\u00e3o e Execu\u00e7\u00e3o} Para colocarmos nossos algoritmos em execu\u00e7\u00e3o, o primeiro passo \u00e9 escrev\u00ea-los, usando um editor de textos qualquer que salve arquivos em texto puro, como o notepad, vim, gedit, etc. A este arquivo com o \\emph{c\u00f3digo} chamaremos \\emph{c\u00f3digo fonte} ou simplesmente \\emph{fonte}. Uma vez de posse do fonte, \u00e9 preciso submet\u00ea-lo a um processos com v\u00e1rios passos que gera, ao final, um arquivo execut\u00e1vel ou o que chamamos, comumente, de \\emph{programa}. O processo como um todo, descrito na se\u00e7\u00e3o seguinte, \u00e9 conhecido como \\emph{compila\u00e7\u00e3o}, apesar de compila\u00e7\u00e3o ser apenas um dos passos do processo. {O processo de compila\u00e7\u00e3o} A sequ\u00eancia de passos que comp\u00f5em a compila\u00e7\u00e3o \u00e9 a seguinte: C\u00f3digo Fonte \\(\\rightarrow\\) Pr\u00e9-processador \\(\\rightarrow\\) Fonte Expandido \\(\\rightarrow\\) Compilador \\(\\rightarrow\\) Arquivo Objeto \\(\\rightarrow\\) Ligador \\(\\rightarrow\\) Execut\u00e1vel De forma simplificada, a pr\u00e9-compila\u00e7\u00e3o \u00e9 um passo que modifica o c\u00f3digo fonte substituindo certas ``palavras chave'' encontradas ao longo do texto por suas defini\u00e7\u00f5es. Por exemplo, pode-se definir que, no programa, toda vez que o pr\u00e9-processador encontrar a palavra PI, ele a substituir\u00e1 por 3.141649. A utilidade da pr\u00e9-compila\u00e7\u00e3o ficar\u00e1 mais clara mais adiante no curso. Uma vez terminada a pr\u00e9-compila\u00e7\u00e3o, acontece a compila\u00e7\u00e3o do seu programa. A compila\u00e7\u00e3o traduz o c\u00f3digo que voc\u00ea escreveu para uma linguagem intelig\u00edvel ao computador, salvando-o em um arquivo chamado arquivo objeto. Por exemplo, a compila\u00e7\u00e3o transformaria o c\u00f3digo ``Ol\u00e1 Mundo!'' escrito acima em algo como % http://farid.hajji.name/blog/2009/12/26/hello-world-in-freebsd-assembler/ \\begin{verbatim} ... CALL write(0x1,0x400623,0xe) GIO fd 1 \"Ol\u00e1 Mundo!\" RET ... \\end{verbatim} Ap\u00f3s a compila\u00e7\u00e3o vem a \\emph{linkedi\u00e7\u00e3o}, o passo que junta o seu arquivo objeto a outros arquivos objetos interessantes, como por exemplo um que contenha c\u00f3digo de fun\u00e7\u00f5es matem\u00e1ticas, manipula\u00e7\u00e3o de arquivos, ou intera\u00e7\u00e3o gr\u00e1fica com o usu\u00e1rio.\\footnote{Embora a explica\u00e7\u00e3o dada aqui n\u00e3o seja estritamente correta, ela \u00e9 pr\u00f3xima o suficiente da realidade para o escopo deste curso.} {A IDE Code::Blocks} Embora a edi\u00e7\u00e3o de um programa possa ser feita em praticamente qualquer editor de textos, h\u00e1 certos editores que s\u00e3o mais adequados a esta tarefa. Tais editores fazem, dentre outras, a coloriza\u00e7\u00e3o das palavras de seu c\u00f3digo de forma a ajud\u00e1-lo a detectar erros e tentam alinhar automaticamente as linhas do seu c\u00f3digo. A inten\u00e7\u00e3o destes editores \u00e9 aumenentar sua produtividade como programador. Outros editores v\u00e3o ainda mais longe e lhe permitem fazer todo o processo de compila\u00e7\u00e3o com um simples \\emph{click} do mouse ou apertar de uma tecla. Estes editores mais completos s\u00e3o conhecidos como \\emph{Integrated Development Environment}, ou simplesmente IDE. No decorrer deste curso consideraremos que o aluno estar\u00e1 usando a IDE \\href{ http://www.Code::Blocks.org}{Code::Blocks }, que \u00e9 gratuita e com vers\u00f5es para Windows, Linux e OSX. Entretanto, qualquer outra IDE ou mesmo a compila\u00e7\u00e3o manual podem ser usados em substitui\u00e7\u00e3o ao Code::Blocks. {Criando um Projeto} Para come\u00e7ar a programar no Code::Blocks, precisamos criar um \\emph{projeto}. Este projeto conter\u00e1 seu c\u00f3digo fonte e, no caso de uma programa\u00e7\u00e3o mais avan\u00e7ada, arquivos de imagens, defini\u00e7\u00f5es de personaliza\u00e7\u00e3o do processo de compila\u00e7\u00e3o, etc. Para criar um projeto no Code::Blocks, clique em \\textbf{File} e, em seguida, \\textbf{New}, \\textbf{Project}. Na tela que se apresenta, voc\u00ea deve escolher o tipo de projeto a ser criado. N\u00e3o se perca nos tipos; escolha \\textbf{Console Application} e ent\u00e3o clique em \\textbf{Go}. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-1.PNG} \\end{center}\\] Na tela seguinte voc\u00ea dever\u00e1 escolher a linguagem de programa\u00e7\u00e3o usada; escolha C++ e clique em \\textbf{Next} para passar para a tela onde dever\u00e1 nomear o seu projeto. Em \\textbf{project title} escreva algo como teste1; em \\textbf{folder to create the project in}, clique no botao com \\ldots e escolha uma pasta para salvar o projeto; esta pode ser, por exemplo, a pasta \\textbf{Meus Documentos} ou uma pasta qualquer em um \\emph{pen drive}.\\footnote{O importante aqui \u00e9 salvar o arquivo em um lugar em que voc\u00ea possa voltar mais tarde para reler.}. Clique ent\u00e3o \\textbf{Next} e, na tela seguinte, clique em \\textbf{Finish}. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-2.PNG} \\end{center}\\] Pronto, seu projeto foi criado. Agora abra o arquivo \\textbf{main.cpp}, que est\u00e1 na pasta \\textbf{sources}, dando um clique duplo no nome do arquivo. Observe que o Code::Blocks criou automaticamente um programa b\u00e1sico. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-3.PNG} \\end{center}\\] Finalmente, clique em \\textbf{build} e ent\u00e3o em \\textbf{build and run}. Parab\u00e9ns, voc\u00ea acaba de executar seu primeiro programa. {Depura\u00e7\u00e3o} Todo programa de tamanho consider\u00e1vel, e mesmo aqueles de tamanho diminuto, possuir\u00e3o, ao menos em suas vers\u00f5es iniciais, erros. Por raz\u00f5es hist\u00f3ricas, nos referimos a estes erros por \\emph{bugs}\\todo{Refer\u00eancia para o uso de bug}. Uma das formas de achar os bugs do seu programa \u00e9 fazer com que o computador execute seu programa passo a passo, isto \u00e9, linha a linha, e acompanhar esta execu\u00e7\u00e3o verificando se o programa faz o que voc\u00ea espera. Para experimentarmos a depura\u00e7\u00e3o, processo pelo qual removemos bugs, modifique a mensagem \"Hello world!\" do seu programa para \"Ol\u00e1 !\" e execute novamente o programa (\\textbf{build and run}). Se o programa executou normalmente, voc\u00ea est\u00e1 no caminho certo. Agora, copie toda a linha contendo a mensagem e cole-a v\u00e1rias vezes, substituindo o nome em cada linha. Seu programa deve ficar como no C\u00f3digo~\\ref{cod:olas} \\begin{lstlisting}[label=cod:olas, caption={Programa com v\u00e1rios Hello's.}] include using namespace std; int main() { cout << \"Hello Joao!\" << endl; cout << \"Hello Jose!\" << endl; cout << \"Hello Joaquim!\" << endl; cout << \"Hello Joselino!\" << endl; cout << \"Hello Asdrubal!\" << endl; return 0; } \\end{lstlisting} Mais uma vez, compile e execute seu programa. Se a execu\u00e7\u00e3o foi bem sucedida, voc\u00ea est\u00e1 pronto para a depura\u00e7\u00e3o. Para depurar, clique ao lado direito do n\u00famero 7 (s\u00e9tima linha do programa), at\u00e9 que uma bolinha vermelha apare\u00e7a, como na figura a seguir. A bolinha vermelha \u00e9, na verdade, um sinal de pare, e diz ao computador que deve, ao executar seu programa, parar ali. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-4.PNG} \\end{center}\\] Se voc\u00ea for adiante e executar o programa como fizemos at\u00e9 agora, ver\u00e1 que o pare n\u00e3o funcionou. Isto \u00e9 por que o sinal \u00e9 ignorado a n\u00e3o ser que voc\u00ea inicie a execu\u00e7\u00e3o em modo de depura\u00e7\u00e3o. Para fazer isso, clique no menu \\textbf{Debug} e ent\u00e3o em \\textbf{Start} ou, alternativamente, pressione a tecla F8. Observe que a execu\u00e7\u00e3o parou onde voc\u00ea esperava. Agora, clique em \\textbf{Debug} e \\textbf{Next Line} ou aperte F7, no teclado, sucessivamente para ver o que acontece. Observe que cada linha \u00e9 executada e ent\u00e3o a execu\u00e7\u00e3o p\u00e1ra novamente. {O Arquivo Execut\u00e1vel} Agora que voc\u00ea j\u00e1 escreveu programas super interessantes, os compilou e executou, imagine como faria para enviar tais programas a um amigo que n\u00e3o tenha qualquer interesse ou aptid\u00e3o em programa\u00e7\u00e3o. A solu\u00e7\u00e3o \u00e9 simples: mandaremos a este amigo o arquivo execut\u00e1vel do programa. Para faz\u00ea-lo, abra a pasta na qual salvou seu projeto Code::Blocks. Nesta pasta voc\u00ea encontrar\u00e1 um arquivo com extens\u00e3o \\verb|.exe|; este \u00e9 o arquivo execut\u00e1vel que deveria enviar para seu amigo. Quando seu amigo executar este programa, ver\u00e1 exatamente a mesma coisa que voc\u00ea viu quando o fez. Al\u00e9m de ser muito \u00fatil, este procedimento \u00e9 tamb\u00e9m uma \u00f3tima forma de se compartilhar v\u00edrus de computador. {Exerc\u00edcios} \\[\\begin{exercicio} Escreva o programa completo que calcula a \u00e1rea de v\u00e1rios ret\u00e2ngulos do cap\u00edtulo anterior e execute-o. \\end{exercicio}\\] \\[\\begin{exercicio} Altere seu programa para usar, al\u00e9m da fun\u00e7\u00e3o de c\u00e1lculo de \u00e1rea de um quadrado, as fun\u00e7\u00f5es definidas nos exerc\u00edcios do cap\u00edtulo anterior. \\end{exercicio}\\] \\chapter{Vari\u00e1veis, Entrada / Sa\u00edda e Operadores} A todo momento precisamos representar informa\u00e7\u00e3o do mundo a nossa volta em nossos programas. Essas informa\u00e7\u00f5es, tais como nome, n\u00famero de matr\u00edcula, nota final, temperatura, idade e outras tantas s\u00e3o armazenadas em entidades chamadas vari\u00e1veis. Uma vari\u00e1vel nada mais \u00e9 do que um peda\u00e7o de mem\u00f3ria, no qual se pode ler ou escrever alguma informa\u00e7\u00e3o. A estes peda\u00e7os de mem\u00f3ria podemos dar nomes que nos ajude a lembrar o que exatamente est\u00e1 escrito ali. Por exemplo, se uma vari\u00e1vel guarda a idade de algu\u00e9m, um bom nome seria idade'', enquanto que rataplam'' ou ``var13'' provavelmente ser\u00e3o p\u00e9ssimas escolhas. As altera\u00e7\u00f5es em uma vari\u00e1vel resultam da intera\u00e7\u00e3o com o usu\u00e1rio, isto \u00e9, quando o usu\u00e1rio informa valores para as mesmas em uma opera\u00e7\u00e3o de leitura, ou da avalia\u00e7\u00e3o de express\u00f5es l\u00f3gico-aritm\u00e9ticas (o tipo de c\u00e1lculo nos quais o computador \u00e9 especializado). Neste cap\u00edtulo veremos como criar nossas primeiras vari\u00e1veis e como alterar seus valores por meio da leitura direta do teclado e da utiliza\u00e7\u00e3o de operadores. {Declara\u00e7\u00e3o de Vari\u00e1veis} Na linguagem C, toda vari\u00e1vel deve ser declarada (isto \u00e9, criada) no in\u00edcio do corpo da fun\u00e7\u00e3o que a contem. A declara\u00e7\u00e3o de uma vari\u00e1vel tem pelo menos duas partes: \\begin{description} \\item[Nome:] usado para referenciar a vari\u00e1vel quando se precisa ler ou escrever a mesma; \\item[Tipo:] para que o computador saiba como tratar a informa\u00e7\u00e3o, ele precisa saber de que tipo ela \u00e9, ou seja, se \u00e9 um n\u00famero, ou uma palavra, ou uma caractere, etc; e, \\end{description} Algumas regras simples devem ser seguinda na hora de se nomear uma vari\u00e1vel: \\begin{itemize} \\item o nome s\u00f3 pode conter os caracteres [a-z], [A-Z], [0-9] e o ``_''; e, \\item o nome n\u00e3o pode come\u00e7ar com n\u00fameros. \\end{itemize} Quanto aos tipos usaremos, por enquanto, os seguintes: \\begin{description} \\item[int] representando um n\u00famero inteiro, como por exemplo 3, 4 e -78; \\item[float:] representando um n\u00famero real, com casas decimais separadas por \\emph{ponto}, como por exemplo 3.1416 e -1.2; e \\item[char:] representando um caractere (letra, d\u00edgito, sinal de pontua\u00e7\u00e3o) como por exemplo 5, a, Z, ., e -. \\end{description} S\u00e3o exemplos de declara\u00e7\u00f5es de vari\u00e1veis v\u00e1lidas: \\begin{lstlisting} int nota1, nota2; float media; char _caractere; \\end{lstlisting} S\u00e3o exemplos de declara\u00e7\u00f5es inv\u00e1lidas: \\begin{lstlisting} int 1nota, 2nota; float #media; char nome completo; \\end{lstlisting} {Atribui\u00e7\u00e3o e Uso} Como j\u00e1 dito, uma vari\u00e1vel \u00e9 um peda\u00e7o da mem\u00f3ria do computador no qual se pode escrever'' e ler'' dados. Em vez de ``escrever'', contudo, no mundo da computa\u00e7\u00e3o usamos a express\u00e3o \\emph{atribuir um valor a uma vari\u00e1vel} para significar a mudan\u00e7a do valor da vari\u00e1vel. Esta opera\u00e7\u00e3o \u00e9 executada pelo operador de atribui\u00e7\u00e3o \\verb|=|. Por exemplo, o seguinte c\u00f3digo declara tr\u00eas vari\u00e1veis num\u00e9ricas, duas inteiras e uma real, e, em seguida, lhes atribui os valores \\verb|0|, \\verb|10| e \\verb|10.0|. \\begin{lstlisting} int inteiro1, inteiro2; float real; inteiro1 = 0; inteiro2 = 10; real = 10.0; \\end{lstlisting} A mem\u00f3ria do computador sempre tem algum dado, tenha ele sido colocado por voc\u00ea ou n\u00e3o, seja ele relevante ou n\u00e3o. Logo, para se usar o conte\u00fado de uma vari\u00e1vel, \u00e9 necess\u00e1rio ter certeza de que a mesma cont\u00e9m um valor que fa\u00e7a sentido. Isto \u00e9, algo que tenha sido atribu\u00eddo pelo seu programa \u00e0quela vari\u00e1vel, via uma opera\u00e7\u00e3o de leitura, via uma computa\u00e7\u00e3o qualquer, ou via uma atribui\u00e7\u00e3o como a do exemplo anterior. Denominamos a primeira atribui\u00e7\u00e3o de um valor a uma vari\u00e1vel de \\emph{inicia\u00e7\u00e3o} (ou \\emph{inicializa\u00e7\u00e3o}). E j\u00e1 que qualquer vari\u00e1vel s\u00f3 deve ser usada se tiver sido iniciada, o C(++) permite que as vari\u00e1veis sejam iniciadas j\u00e1 em sua declara\u00e7\u00e3o. Por exemplo, o c\u00f3digo abaixo faz exatamente o que fazia o exemplo anterior, mas de forma mais compacta. \\[\\begin{lstlisting} int inteiro1 = 0, inteiro2 = 10; float real = 10.0; \\end{lstlisting}\\] Observe que se pode iniciar v\u00e1rias vari\u00e1veis do mesmo tipo, declaradas na mesma linha, com valores distintos. Neste caso, note quebra de linha entre as declara\u00e7\u00f5es de \\verb|inteiro1| e \\verb|inteiro2|; ela \u00e9 somente est\u00e9tica, mas ajuda a separar a declara\u00e7\u00e3o e inicia\u00e7\u00e3o das v\u00e1rias vari\u00e1veis. Agora que voc\u00ea viu como declarar e iniciar uma vari\u00e1vel vem a parte f\u00e1cil: us\u00e1-la. Veja como no seguinte exemplo. \\begin{lstlisting}[label={Programa com exemplo de uso de vari\u00e1veis.}, caption=cod:vars] include using namespace std; float area_circulo(float raio) { float PI = 3.14, area; area = PI * raio * raio; return area; } char proxima_letra(char c1) { char c2; c2 = c1 + 1; return c2; } int main() { int r1; float r2; char _c; _c = 'a'; cout << \"O proximo de \" << _c << \" eh \" << proxima_letra(_c) << endl; r1 = 2; r2 = 9.7; cout << \"r = \" << r1 << \", area = \" << area_circulo(r1) << endl; cout << \"r = \" << r2 << \", area = \" << area_circulo(r2) << endl; r1 = 12; r2 = 0.4; cout << \"r = \" << r1 << \", area = \" << area_circulo(r1) << endl; cout << \"r = \" << r2 << \", area = \" << area_circulo(r2) << endl; return 0; } \\end{lstlisting} \u00c9 simples assim: para se usar uma vari\u00e1vel, basta colocar seu nome na express\u00e3o a ser computada. Na linha 9, por exemplo, atribui-se \u00e0 vari\u00e1vel \\lstinline|area| o valor da multiplica\u00e7\u00e3o do conte\u00fado da vari\u00e1vel \\lstinline|PI| por \\lstinline|raio|, ao quadrado. Na linha 10, o resultado da fun\u00e7\u00e3o \u00e9 o conte\u00fado da vari\u00e1vel \\lstinline|area|. {Par\u00e2metros s\u00e3o Vari\u00e1veis} Nos exemplos de programas dos cap\u00edtulos anteriores, voc\u00ea viu como o conte\u00fado de uma par\u00e2metro \u00e9 definido e usado. Por exemplo, os dois par\u00e2metros da fun\u00e7\u00e3o \\verb|area_retangulo|, reproduzida abaixo, s\u00e3o declarados dizendo-se de que tipo eles s\u00e3o e quais s\u00e3o seus nomes. Em seguida, no corpo da fun\u00e7\u00e3o, os par\u00e2metros s\u00e3o usados no c\u00e1lculo da \u00e1rea simplesmente multiplicando-se ``o nome de um pelo nome do outro''; os valores dos par\u00e2metros s\u00e3o aqueles passados na chamada da fun\u00e7\u00e3o. \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { float area; area = area_retangulo(2.0, 2.0); cout << area; return 0; } \\end{lstlisting} Esta semelhan\u00e7a com a declara\u00e7\u00e3o e uso de vari\u00e1veis n\u00e3o \u00e9 coincidental: par\u00e2metros n\u00e3o s\u00e3o mais do que vari\u00e1veis declaradas e iniciadas de uma forma especial. Isto \u00e9, elas declaradas na defini\u00e7\u00e3o da fun\u00e7\u00e3o e s\u00e3o iniciadas atribuindo-se os valores passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, na mesma \u00f3rdem em que s\u00e3o passados. Isto \u00e9, se a fun\u00e7\u00e3o \u00e9 invocada como \\lstinline|area_retangulo(1,2)|, ent\u00e3o 1 \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel/par\u00e2metro \\lstinline|altura| e 2 \u00e0 \\lstinline|base|. Se a fun\u00e7\u00e3o \u00e9 invocada como \\lstinline|area_retangulo(X,y)|, ent\u00e3o o valor da vari\u00e1vel X, seja l\u00e1 qual for \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel/par\u00e2metro \\lstinline|altura| e de y \u00e0 \\lstinline|base|. {Entrada / Sa\u00edda} Al\u00e9m da escrita ou impress\u00e3o de dados na tela, vista no Cap\u00edtulo\\ref{cap:introducao}, uma das tarefas mais comuns em programa\u00e7\u00e3o \u00e9 a leitura de valores informados pelo usu\u00e1rio. A seguir veremos o comando que nos permitem executar tal tarefas. {Leitura} De forma semelhante ao \\verb|cout|, h\u00e1 um comando para leitura denominado \\verb|cin|. Este comando permite ler valores digitados pelo usu\u00e1rio atualizando a(s) vari\u00e1vel(is) passada(s) para o \\verb|cin| por meio do conector \\verb|>>|. A seguir temos um exemplo de entrada de dados: \\begin{lstlisting} char letra; int idade; cout << \"Informe a letra inicial de seu nome e sua idade: \"; // a seguir eh feita a leitura cin >> letra >> idade; cout << \"A letra eh \" << letra; cout << \" e sua idade eh \" << idade << endl; \\end{lstlisting} {Impress\u00e3o} Complementando o que j\u00e1 vimos sobre o \\verb|cout|, vejamos como escrever o conte\u00fado de vari\u00e1veis na tela: \\begin{itemize} \\item Vari\u00e1veis e chamadas de fun\u00e7\u00f5es aparecem diretamente tamb\u00e9m, e seus valores (e resultado) \u00e9 que s\u00e3o colocados na sa\u00edda. \\end{itemize} A seguir, podemos ver alguns exemplos: \\begin{lstlisting} char letra = 'a'; int num = 2; cout << \"letra = \" << letra << endl << \"num = \" << num << endl; \\end{lstlisting} que gera a seguinte sa\u00edda: \\begin{lstlisting} letra = a num = 2 \\end{lstlisting} Agora que voc\u00ea consegue ler do teclado e escrever para a tela, veja como \u00e9 f\u00e1cil fazer um programa que calcule a \u00e1rea de ret\u00e2ngulo cujos lados s\u00e3o digitados pelo usu\u00e1rio. \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { float area, b, a; cout << \"Qual a altura do retangulo?\" << endl; cin >> a; cout << \"Qual a base do retangulo?\" << endl; cin >> b; area = area_retangulo(b, a); cout << area; return 0; } \\end{lstlisting} \\subsubsection{Formata\u00e7\u00e3o de Impress\u00e3o} Em algumas ocasi\u00f5es h\u00e1 necessidade de formatar a sa\u00edda para, por exemplo, garantir que os dados fiquem alinhados, imprimir uma tabela, ou simplesmente por est\u00e9tica. A seguir veremos algumas maneiras de formatar, texto, n\u00fameros inteiros e reais. Para formata\u00e7\u00e3o de texto e n\u00fameros deve-se incluir a biblioteca \\lstinline|iomanip|. A formata\u00e7\u00e3o de texto \u00e9 obtida mediante defini\u00e7\u00e3o da largura do conte\u00fado impresso e do alinhamento. O comando \\lstinline{setw( )}, define a largura do texto impresso para o valor informado como argumento, enquanto os comandos \\lstinline{right} e \\lstinline{left} definem o alinhamento para a direita e esquerda, respectivamente. O efeito do comando \\lstinline|setw| n\u00e3o \u00e9 permamente. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o destes comandos: \\begin{lstlisting} include include using namespace std; float volume_cubo(float aresta) { return aresta*aresta*aresta; } int main() { float a, v; cout << \"Entre valor da aresta do cubo:\" << endl; cin >> a; v = volume_cubo(a); cout << setw(30) << left << \"O volume do cubo eh: \" << v << endl; cout << setfill('-'); cout << setw(30) << left << \"O volume do cubo eh: \" << v << endl; cout << setw(30) << \"O volume do cubo eh: \" << setw(20) << v << endl; cout << setw(30) << \"O volume do cubo eh: \" << setw(20) << right << v << endl; cout << setw(30) << left << \"O volume do cubo eh: \" << v << endl; return 0; } \\end{lstlisting} A execu\u00e7\u00e3o deste c\u00f3digo produz a seguinte sa\u00edda: \\begin{verbatim} Entre valor da aresta do cubo: 2.5 O volume do cubo eh: 15.625 O volume do cubo eh: ---------15.625 O volume do cubo eh: ---------15.625-------------- O volume do cubo eh: -----------------------15.625 O volume do cubo eh: ---------15.625 \\end{verbatim} O comando \\lstinline|setfill| permite definir o caractere que ser\u00e1 usado para preencher os espa\u00e7os restantes, de acordo com a largura definida com \\lstinline|setw| Para formata\u00e7\u00e3o de n\u00fameros reais (\\lstinline{float} e \\lstinline{double}), o exemplo a seguir mostra alguns comandos para formata\u00e7\u00e3o: \\begin{lstlisting} include include using namespace std; float volume_cubo(float aresta) { return aresta*aresta*aresta; } int main() { float a, v; cout << \"Entre valor da aresta do cubo:\" << endl; cin >> a; v = volume_cubo(a); cout << \"O volume do cubo eh: \" << v << endl; cout << fixed << setprecision(2); cout << \"O volume do cubo eh: \" << v << endl; cout << fixed << setprecision(4); cout << \"O volume do cubo eh: \" << v << endl; return 0; } \\end{lstlisting} O comando \\lstinline{fixed} determina que o n\u00famero de casas depois decimais ser\u00e1 fixo, enquanto o comando \\lstinline{setprecision} define quantas casas decimais ser\u00e3o impressas. Desta maneira, para o exemplo anterior, teremos a seguinte sa\u00edda: \\[\\begin{verbatim} Entre valor da aresta do cubo: 4 O volume do cubo eh: 64 O volume do cubo eh: 64.00 O volume do cubo eh: 64.0000 \\end{verbatim}\\] {Operadores} Os operadores s\u00e3o os mecanismos por meio dos quais os computadores realizam os c\u00e1lculos aritm\u00e9ticos e l\u00f3gicos, atualizando valores das vari\u00e1veis e executando as tarefas a que se destinam. Os operadores matem\u00e1ticos s\u00e3o os mais utilizados na maioria dos programas que ser\u00e3o desenvolvidos. Os principais operadores aritm\u00e9ticos s\u00e3o: \\(+, -, *, /\\) e o \\%, indicando, respectivamente, as opera\u00e7\u00f5es de soma, subtra\u00e7\u00e3o, multiplica\u00e7\u00e3o, divis\u00e3o e resto da divis\u00e3o. Considere o exemplo a seguir: \\begin{lstlisting} include using namespace std; int main() { int n, dobro_de_n; cout << \"Entre um inteiro: \"; cin >> n; dobro_de_n = 2*n; cout << \"O dobro de \" << n << \" eh \" << dobro_de_n << endl; return 0; } \\end{lstlisting} {Exerc\u00edcios} \\begin{exercicio} Escreva uma fun\u00e7\u00e3o em C que, dado uma temperatura em graus C\u00e9lsius (do tipo float), retorne a temperatura equivalente em Farenheit. Escreva tamb\u00e9m a fun\u00e7\u00e3o \\verb|main| que leia a temperatura em C\u00e9lsius do teclado, invoque a fun\u00e7\u00e3o de convers\u00e3o, e imprima o resultado. Dado: \\(F = \\frac{9C}{5} + 32\\) \\end{exercicio} %\\todo{Esta se\u00e7\u00e3o deve ser movida para mais adiante, para quando formos falar em n\u00fameros bin\u00e1rios, e incrementada.} \\chapter{Vari\u00e1veis (II)} {Escopo de Vari\u00e1veis} No cap\u00edtulo anterior estudamos como declarar e utilizar vari\u00e1veis em nossos programas. Fizemos, por exemplo, um programa como o seguinte, que pede ao usu\u00e1rio que entre com as medidas da base e altura de um ret\u00e2ngulo e ent\u00e3o imprime na tela do computador a \u00e1rea deste ret\u00e2ngulo. \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { float area, b, a; cout << \"Qual a altura do retangulo?\" << endl; cin >> a; cout << \"Qual a base do retangulo?\" << endl; cin >> b; area = area_retangulo(b, a); cout << \"A area do retangulo de base \" << b << \" e altura \" << a << \" eh \" << area << endl; return 0; } \\end{lstlisting} O que aconteceria se em vez de chamarmos as vari\u00e1veis na fun\u00e7\u00e3o \\verb|main| de \\verb|a| e \\verb|b| as tiv\u00e9ssemos chamado de \\verb|base| e \\verb|altura|? Veja que estes s\u00e3o exatamente os nomes dos par\u00e2metros da fun\u00e7\u00e3o \\verb|area_retangulo|. Melhor ainda, e se a fun\u00e7\u00e3o tivesse alterado os valores dos par\u00e2metros? Para descobrir as respostas a estas perguntas, fa\u00e7a o seguinte experimento: \\begin{itemize} \\item digite o programa tal qual acima em seu computador e \\emph{execute-o}. \\item modifique somente a fun\u00e7\u00e3o \\verb|main| do seu programa para que fique assim \\begin{lstlisting} int main() { float area, base, altura; cout << \"Qual a altura do retangulo?\" << endl; cin >> altura; cout << \"Qual a base do retangulo?\" << endl; cin >> base; area = area_retangulo(base, altura); cout << \"A area do retangulo de base \" << base << \" e altura \" << altura << \" eh \" << area << endl; return 0; } \\end{lstlisting} e execute-o. \\item Note quais as diferen\u00e7as na execu\u00e7\u00e3o. \\item Finalmente, altere a fun\u00e7\u00e3o \\verb|area_retangulo| para que fique assim \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. altura *= base; return altura; } \\end{lstlisting} e execute novamente o programa. \\item Note se houve alguma altera\u00e7\u00e3o do valor da vari\u00e1vel \\verb|altura|. \\end{itemize} Como se p\u00f4de notar, estas mudan\u00e7as n\u00e3o afetaram a execu\u00e7\u00e3o do programa. Isto acontece por qu\u00ea as vari\u00e1veis tem escopos bem definidos em C. A vari\u00e1vel \\verb|altura| da fun\u00e7\u00e3o \\verb|main| n\u00e3o \u00e9 a mesma vari\u00e1vel/par\u00e2metro \\verb|altura| da fun\u00e7\u00e3o \\verb|area_retangulo|; cada uma s\u00f3 existe dentro do corpo da fun\u00e7\u00e3o em que foi declarada. Quando a fun\u00e7\u00e3o \\verb|area_retangulo| \u00e9 invocada passando-se como par\u00e2metro a vari\u00e1vel \\verb|altura| da fun\u00e7\u00e3o \\verb|main|, o valor desta vari\u00e1vel \u00e9 \\emph{copiado} para o par\u00e2metro \\verb|altura| da fun\u00e7\u00e3o invocada. Sendo assim, quaisquer altera\u00e7\u00f5es ao valor do par\u00e2metro dentro da fun\u00e7\u00e3o afetam apenas a c\u00f3pia, n\u00e3o o valor da vari\u00e1vel de onde foi copiado. A vari\u00e1veis definidas at\u00e9 agora possuem o que chamamos \\emph{escopo local}. Isto \u00e9, elas s\u00e3o visiveis somente localmente \u00e0 fun\u00e7\u00e3o em que foram definidas. Outro tipo de escopo presente poss\u00edvel em C \u00e9 o \\emph{escopo global}. Uma vari\u00e1vel tem escopo global se for definida fora de qualquer fun\u00e7\u00e3o. Uma vari\u00e1el com escopo global poder\u00e1 ser acessada de (quase) qualquer parte do seu c\u00f3digo. Para um exemplo de vari\u00e1vel de escopo global, veja o c\u00f3digo a seguir. \\begin{lstlisting} float PI = 3.1416; float resposta = 0; float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. resposta = base * altura; return resposta; } float area_circulo(float raio) { //Calcula e retorna a area do circulo. resposta = PI * raio * raio; return resposta; } int main() { float area, base, altura, raio; cout << \"Qual a altura do retangulo?\" << endl; cin >> altura; cout << \"Qual a base do retangulo?\" << endl; cin >> base; area = area_retangulo(base, altura); cout << \"A area do retangulo de base \" << base << \" e altura \" << altura << \" eh \" << area << endl; cout << \"Resposta da chamada de funcao \" << resposta << endl; cout << \"Qual o raio do circulo?\" << endl; cin >> raio; area = area_circlo(raio); cout << \"A area do circulo de raio \" << raio << \" e PI arredondado para \" << PI <<\" eh \" << area << endl; cout << \"Resposta da chamada de funcao \" << resposta << endl; return 0; } \\end{lstlisting} Observe a vari\u00e1vel \\verb|PI|. Esta vari\u00e1vel foi declarada fora de qualquer fun\u00e7\u00e3o e, sendo assim, \u00e9 vis\u00edvel em qualquer delas, como demonstrado pelo seu uso na fun\u00e7\u00e3o \\verb|main| e \\verb|area_circulo|. Observe tamb\u00e9m que a mesma vari\u00e1vel \\verb|area| foi utilizada mais de uma vez. Isto \u00e9 comum em programa\u00e7\u00e3o pois, com a quantidade limitada de recursos, pode n\u00e3o fazer sentido criar uma vari\u00e1vel para cada novo uso. Observe que a vari\u00e1vel \\verb|resposta| foi alterada dentro das duas fun\u00e7\u00f5es de c\u00e1lculo de \u00e1rea e que estas mudan\u00e7as foram vis\u00edveis \u00e0 fun\u00e7\u00e3o \\verb|main|. Verifique de forma experimental (copiando e executando) que o programa acima funciona como esperado. {Faixas de Valores} Voc\u00ea j\u00e1 aprendeu que vari\u00e1veis s\u00e3o espa\u00e7os (c\u00e9lulas) da mem\u00f3ria do computador para o qual damos nomes. Estes espa\u00e7os, por serem limitados, podem armazenar uma quantidade limitada de valores. Pense, por exemplo, em quais os n\u00fameros, positivos e negativos, se pode representar com tr\u00eas d\u00edgitos: \\(-99, -98, \\ldots, 0, 1, 2, \\ldots, 998,999\\) . Tentemos descobrir qual a faixa de valores que ``cabem'' em uma vari\u00e1vel \\verb|int|. Escreva um programa que declare uma vari\u00e1vel do tipo \\verb|int|, inicie esta vari\u00e1vel com um n\u00famero (digamos, 10000), e imprima este n\u00famero na tela do computador. Veja que o n\u00famero \u00e9 impresso na tela como deveria: \\verb|10000|. Agora altere seu programa para que imprima 20000 e execute-o. Refa\u00e7a este passo (adicionando 10000 a cada passo) at\u00e9 que a impress\u00e3o fuja do que voc\u00ea esperava. Neste ponto, trabalhe com incrementos menores at\u00e9 determinar qual o maior n\u00famero que \u00e9 impresso como esperado. Fepita o processo para identificar qual o menor n\u00famero que cabe em um \\verb|int|. Quais s\u00e3o estes valores? Finalmente, tente identificar a faixa de valores que cabem em um \\verb|float|. Dica: os incrementos iniciais deveriam ser na faixa de milh\u00f5es e n\u00e3o dezenas de milhares. {Exerc\u00edcios} \\todo{Colocar} {Laborat\u00f3rio} \\todo{Colocar} \\chapter{Sele\u00e7\u00e3o Simples} Nossos programas at\u00e9 agora foram extremamente simples, contendo apenas algumas pequenas fun\u00e7\u00f5es al\u00e9m da \\verb|main|. Isto acontece em parte por qu\u00ea nossos programas s\u00e3o apenas sequ\u00eancias diretas de comandos, sem execu\u00e7\u00e3o condicional. Isto \u00e9, at\u00e9 agora n\u00e3o aprendemos a dizer para o computador ``Se for assim, ent\u00e3o fa\u00e7a assado! Sen\u00e3o, fa\u00e7a cozido!''. Esta defici\u00eancia ser\u00e1 corrigida neste cap\u00edtulo. Como exemplo de programa\u00e7\u00e3o mais interessante, implementemos uma fun\u00e7\u00e3o que calcule as raizes de uma equa\u00e7\u00e3o de segundo grau. Para faz\u00ea-lo, relembremos a f\u00f3rmula de Bhaskara: \\(x = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}\\) , sendo \\(\\Delta = b^2 -4ac\\) . Comecemos ent\u00e3o definindo uma fun\u00e7\u00e3o para o c\u00e1lculo do \\(\\Delta\\) . \\[\\begin{lstlisting} float delta(float a, float b, float c) { return b*b - 4*a*c; } \\end{lstlisting}\\] Para testar o c\u00e1lculo do \\(\\Delta\\) precisamos da fun\u00e7\u00e3o \\verb|main|, juntamente com o restante do esqueleto de programa aprendido at\u00e9 agora. \\begin{lstlisting} include using namespace std; float delta(float a, float b, float c) { return b*b - 4*a*c; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; return 0; } \\end{lstlisting} Agora, para c\u00e1lculo das ra\u00edzes! Comecemos por alterar o programa para imprimir \\emph{o n\u00famero} de ra\u00edzes da equa\u00e7\u00e3o. O c\u00e1lculo do n\u00famero de ra\u00edzes ser\u00e1 feito na fun\u00e7\u00e3o \\verb|raizes|. A equa\u00e7\u00e3o tem ou 0 ra\u00edzes reais (se o \\(\\Delta < 0\\) ), ou duas ra\u00edzes iguais (se \\(\\Delta = 0\\) ), ou duas raizes distintas (se \\(\\Delta > 0\\) ). \\begin{lstlisting} include using namespace std; float delta(float a, float b, float c) { return b*b - 4*a*c; } int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; se d menor que 0 { qtd = 0; } senao e se d igual a 0 { qtd = 1; } senao { qtd = 2; } return qtd; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; cout << \"A equacao tem \" << raizes(a,b,c) << \" raizes.\"; return 0; } \\end{lstlisting} Acontece que o computador n\u00e3o entende nem o \\verb|se| e nem o \\verb|menor que|. Mas ent\u00e3o como faremos as verifica\u00e7\u00f5es necess\u00e1rias para determinar a quantidade raizes? A resposta tem duas partes. {Operadores Relacionais} As linguagens de programa\u00e7\u00e3o prov\u00eaem sempre formas de se comparar dados. Em C(++) os operadores relacionais, usados para comparar, s\u00e3o os seguintes: \\[\\begin{tabular}{c l} \\verb|==| & igual a\\\\ \\verb|!=| & diferente de\\\\ \\verb|>| & maior que\\\\ \\verb|<| & menor que\\\\ \\verb|>=| & maior ou igual a\\\\ \\verb|<=| & menor ou igual a\\\\ \\end{tabular}\\] Observe que o primeiro operador tem \\emph{dois} sinais de igual. Isto \u00e9 para diferenciar este operador do operador de atribui\u00e7\u00e3o \\verb|=|, visto anteriormente. O segundo operador tem um sinal de exclama\u00e7\u00e3o (\\verb|!|) que, em linguagem C, significa \\emph{nega\u00e7\u00e3o}. Logo, \\verb|!=| significa n\u00e3o igual ou, simplesmente, diferente. Os demais operadores devem ter significados \u00f3bvios. Usando estes operadores, podemos re-escrever a fun\u00e7\u00e3o raizes do nosso programa assim: \\begin{lstlisting} int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; se d < 0 { qtd = 0; } senao e se d == 0 { qtd = 1; } senao { qtd = 2; } return qtd; } \\end{lstlisting} Melhorou, mas ainda n\u00e3o pode ser executado pelo computador. Vamos ent\u00e3o ao \\emph{se}. {\\texttt{if-else}} Em C, testes simples (tudo o que voc\u00ea realmente precisa) podem ser feitos com a estrutura \\verb|if|, que tem uma das seguintes sintaxes: \\begin{itemize} \\item \\verb|if(| express\u00e3o l\u00f3gica \\verb|)| bloco de comandos 1 \\item \\verb|if(| express\u00e3o l\u00f3gica \\verb|)| bloco de comandos 1 \\verb|else| bloco de comandos 2 \\end{itemize} Uma \\emph{express\u00e3o l\u00f3gica} \u00e9 uma express\u00e3o cuja avalia\u00e7\u00e3o resulte em \\emph{verdadeiro} ou \\emph{falso} como, por exemplo, as express\u00f5es que usam os operadores relacionais apenas apresentados. Um \\emph{bloco de comandos} \u00e9 ou uma instru\u00e7\u00e3o ou um conjunto de instru\u00e7\u00f5es dentro de \\verb|{| \\verb|}|. Quando a express\u00e3o l\u00f3gica \u00e9 avaliada, se seu resultado for \\emph{verdadeiro}, ent\u00e3o o bloco de comandos 1 ser\u00e1 executado. Se o resultado for \\emph{falso}, o bloco de comandos 1 n\u00e3o ser\u00e1 executado e o bloco 2, se existir, ser\u00e1 executado em seu lugar. Observe que o segundo bloco pode ser, por sua vez, outro \\verb|if|. Por exemplo, nosso programa pode ser reescrito assim: \\begin{lstlisting} include using namespace std; float delta(float a, float b, float c) { return b*b - 4*a*c; } int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; if(d < 0) { qtd = 0; } else if(d == 0) { qtd = 1; } else { qtd = 2; } return qtd; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; cout << \"A equacao tem \" << raizes(a,b,c) << \" raizes.\"; return 0; } \\end{lstlisting} O \u00faltimo passo no desenvolvimento do nosso programa \u00e9 imprimir na tela as raizes da equa\u00e7\u00e3o, o que faremos em uma nova fun\u00e7\u00e3o: \\verb|imprime_raizes|. \\begin{lstlisting} include include using namespace std; float delta(float a, float b, float c) { return pow(b,2) - 4*a*c; } int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; if(d < 0) { qtd = 0; } else if(d == 0) { qtd = 1; } else { qtd = 2; } return qtd; } int imprime_raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; if(d < 0) { cout << \"A equacao tem zero raizes reais.\" << endl; } else if(d == 0) { cout << \"A equacao tem duas raizes iguais a \" << -b/(2*a); } else { cout << \"A equacao tem duas raizes iguais distintas \" << endl << \"x' = \" << (-b + sqrt(d))/(2*a) << endl << \"x'' = \" << (-b - sqrt(d))/(2*a) << endl; } return qtd; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; cout << \"A equacao tem \" << raizes(a,b,c) << \" raizes.\" << endl; imprime_raizes(a,b,c); return 0; } \\end{lstlisting} Note que a nova fun\u00e7\u00e3o usa a fun\u00e7\u00e3o \\verb|sqrt| para calcular a ra\u00edz de \\(\\Delta\\) . Esta fun\u00e7\u00e3o \u00e9 uma das muitas dispon\u00edveis na linguagem C. Para usar esta fun\u00e7\u00e3o \u00e9 preciso dizer ao computador sua inten\u00e7\u00e3o. No nosso programa, isto \u00e9 feito na linha 2, isto \u00e9,\\ \\verb|#include |\\ em que dizemos ao computador que queremos usar as fun\u00e7\u00f5es da biblioteca matem\u00e1tica da linguagem. Aproveitando a inclus\u00e3o desta biblioteca tamb\u00e9m alteramos a linha 8 para usar a fun\u00e7\u00e3o \\verb|pow| para o c\u00e1lculo do \\(b^2\\) . V\u00e1rias outras fun\u00e7\u00f5es est\u00e3o dispon\u00edveis e podem ser consultadas em \\url{ http://www.cplusplus.com/reference/clibrary/cmath/ }. \\todo{A se\u00e7\u00e3o seguinte deveria virar um cap\u00edtulo e a parte if else vistos at\u00e9 agora se juntar ao pr\u00f3ximo cap\u00edtulo} {Fun\u00e7\u00f5es e Procedimentos} A fun\u00e7\u00e3o \\verb|imprime_raizes|, definida na se\u00e7\u00e3o anterior, tem por objetivo imprimir na tela as raizes da equa\u00e7\u00e3o de segundo grau, se existirem. Esta fun\u00e7\u00e3o n\u00e3o tem, pela nossa defini\u00e7\u00e3o, o objetivo de calcular a quantidade de ra\u00edzes (que era o objetivo da fun\u00e7\u00e3o \\verb|raizes|). Em \\verb|imprime_raizes| n\u00e3o faz sentido, ent\u00e3o, a fun\u00e7\u00e3o ter um \\emph{resultado}. Fun\u00e7\u00f5es sem resultado s\u00e3o denominadas \\emph{procedimentos} e, em C, s\u00e3o declaradas como qualquer outra fun\u00e7\u00e3o, apenas com uma particularidade: o tipo do resultado \u00e9 \\verb|void|. Antes de vermos alguns exemplos, precisamos ver a sintaxe de fun\u00e7\u00f5es em geral, que estivemos usando nas se\u00e7\u00f5es e cap\u00edtulos anteriores mas n\u00e3o hav\u00edamos definido formalmente. tipo_resultado \\ identificador_fun\u00e7\u00e3o(tipo_par\u00e2metro 1 identificador_do_par\u00e2metro 1, \\ldots) bloco_de_comandos \\[\\begin{itemize} \\item tipo\\_resultado -- o tipo do valor que a fun\u00e7\u00e3o est\u00e1 calculando. \\item identificador\\_fun\u00e7\u00e3o -- o nome usado para invocar a fun\u00e7\u00e3o. \\item tipo\\_par\u00e2metro 1 -- tipo do primeiro par\u00e2metro da fun\u00e7\u00e3o. \\item identificador\\_par\u00e2metro 1 -- identificador do primeiro par\u00e2metro da fun\u00e7\u00e3o. \\item \\dots -- tipo e identificador dos demais par\u00e2metros. \\item bloco\\_de\\_comandos -- instru\u00e7\u00f5es que comp\u00f5em o corpo da fun\u00e7\u00e3o. \\end{itemize}\\] Como mencionado, procedimentos s\u00e3o fun\u00e7\u00f5es sem um resultado e, em C, s\u00e3o declarados como tendo resultado do tipo \\verb|void|. Em fun\u00e7\u00f5es normais, o resultado \u00e9 dado pela instru\u00e7\u00e3o \\verb|return|; em procedimentos, que n\u00e3o tem resultado, \\verb|return| n\u00e3o \u00e9 utilizado. Al\u00e9m disso, o resultado de procedimentos n\u00e3o podem ser usados em atribui\u00e7\u00f5es. Al\u00e9m de fun\u00e7\u00f5es sem resultado, C permite a defini\u00e7\u00e3o de fun\u00e7\u00f5es sem par\u00e2metros. Um exemplo deste tipo de fun\u00e7\u00e3o seria uma que lesse algum dado do usu\u00e1rio. \\begin{lstlisting} int ler_idade() { int id; cout << \"Qual sua idade? \" < > id; return id; } \\end{lstlisting} Finalmente, \u00e9 importante relembrar que as fun\u00e7\u00f5es precisam ser definidas \\emph{antes} de serem usadas. Sendo assim, voc\u00ea deve incluir a defini\u00e7\u00e3o das fun\u00e7\u00f5es antes da defini\u00e7\u00e3o da fun\u00e7\u00e3o \\verb|main| em seu c\u00f3digo. \\footnote{\u00c9 poss\u00edvel escrever o c\u00f3digo de suas fun\u00e7\u00f5es ap\u00f3s a fun\u00e7\u00e3o \\texttt{main} ou mesmo em outros arquivos. Fazer isso, contudo, requer conhecer um pouco mais do funcionamento dos compiladores do que o escopo deste livro.}. Ainda, relembrando a primeira aula, sobre a fun\u00e7\u00e3o \\verb|main|: \\begin{enumerate} \\item A fun\u00e7\u00e3o \\verb|main| tem um resultado do tipo inteiro e seu resultado \u00e9 sempre 0 (\\lstinline{return 0;} )\\footnote{Pelo menos nos programas simples que faremos.}. \\item Fun\u00e7\u00e3o \\verb|main| \u00e9 como um \\emph{highlander}: s\u00f3 pode haver uma! Isto \u00e9, cada programa s\u00f3 pode conter a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o com este nome. \\item Finalmente, todas as fun\u00e7\u00f5es devem ser declaradas antes da serem usadas, pois quando o computador tenta execut\u00e1-la, j\u00e1 deve saber de sua exist\u00eancia. \\end{enumerate} {O Tipo Primitivo \\lstinline|bool|} Como vimos neste cap\u00edtulo, o \\lstinline|if| avalia uma express\u00e3o l\u00f3gica para decidir-se por executar ou n\u00e3o um bloco de comandos. Express\u00f5es l\u00f3gicas, como tamb\u00e9m j\u00e1 visto, s\u00e3o aquelas que s\u00e3o avaliadas em verdadeiro ou falso. Na linguagem C(++), quaisquer n\u00fameros inteiros podem tamb\u00e9m ser avaliados como verdadeiro ou falso, seguindo a seguinte regra: \\begin{itemize} \\item 0 corresponde a falso. \\item qualquer outro n\u00famero corresponde a verdadeiro. \\end{itemize} Em C++, tamb\u00e9m \u00e9 poss\u00edvel utilizar os valores \\lstinline|true| e \\lstinline|false|, que correspondem, respectivamente, a 1 e 0. Estes dois valores comp\u00f5em o conjuntos dos booleanos, ou melhor, o tipo primitivo \\lstinline|bool|. Isto \u00e9, \\lstinline|true| e \\lstinline|false| est\u00e3o para \\lstinline|bool| assim como -100, 10, 12, \\ldots est\u00e3o para \\lstinline|int|. {Exerc\u00edcios} \\begin{exercicio} Muitas pessoas acreditam que um ano \u00e9 bissexto se for m\u00faltiplo de 4. Contudo, a regra \u00e9 um pouco mais complexa do que esta: \\begin{itemize} \\item Um ano \u00e9 bissexto se for m\u00faltiplo de 4 mas n\u00e3o de 100, ou \\item se for m\u00faltiplo de 100, ent\u00e3o for m\u00faltiplo de 400. \\end{itemize} Escreva um programa que leia um ano, chame uma fun\u00e7\u00e3o para calcular se o ano \u00e9 bissexto e imprima sim ou n\u00e3o de acordo. \\begin{lstlisting} include using namespace std; bool bissexto(int ano) { if(ano % 4 == 0) { if(ano % 100 == 0) { if (ano % 400 == 0) { return true; } else { return false; } } else { return true; } } else { return false; } } int main() { int ano; cout << \"Digite o ano que deseja verificar se e bissexto: \"; cin >> ano; cout << \"O ano \" << ano; if(bissexto(ano)) cout << \" e bissexto\" << endl; else cout << \" nao e bissexto\" << endl; return 0; } \\end{lstlisting} \\end{exercicio} \\begin{exercicio} Este exerc\u00edcio \u00e9 dividido em v\u00e1rias partes: \\begin{enumerate} \\item Escreva uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais e retorne a m\u00e9dia dos tr\u00eas n\u00fameros. \\item Escreva uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais e retorne o menor dentre eles. \\item Escreva uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais e retorne o maior dentre eles. \\item Escreva a fun\u00e7\u00e3o \\verb|main| de forma a ler tr\u00eas n\u00fameros reais, calcular a m\u00e9dia dos mesmos e, caso a m\u00e9dia seja menor que 0, imprima o menor dentre os tr\u00eas, ou, caso a m\u00e9dia seja maior ou igual a zero, imprima o maior dentre os tr\u00eas. Sua fun\u00e7\u00e3o \\verb|main| deve usar as fun\u00e7\u00f5es escritas nos itens anteriores para c\u00e1lculo da m\u00e9dia e impress\u00e3o dos n\u00fameros. \\end{enumerate} \\end{exercicio} \\[\\begin{exercicio} Escreva um programa que contenha \\begin{enumerate} \\item Uma fun\u00e7\u00e3o \\verb|celsius_fahrenheit| que receba uma temperatura em graus celsius e converta para fahrenheit. \\item Uma fun\u00e7\u00e3o \\verb|fahrenheit_celsius| que receba uma temperatura em fahrenheit e converta para graus celsius. \\item Fun\u00e7\u00e3o \\verb|main| que leia uma temperatura do teclado, pergunte ao usu\u00e1rio se a temperatura \u00e9 em celsius ou fahrenheit, e imprima a temperatura convertida para a outra medida. \\end{enumerate} \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o denominada \\emph{ehPar} que receba um n\u00famero inteiro como argumento e retorne verdadeiro se este n\u00famero for par ou falso, caso contr\u00e1rio. A fun\u00e7\u00e3o \\verb|main| deve ler o n\u00famero e imprimir o valor retornado pela fun\u00e7\u00e3o auxiliar. \\end{exercicio}\\] \\[\\begin{exercicio} Elabore um programa com as seguinte descri\u00e7\u00e3o: \\begin{itemize} \\item Uma fun\u00e7\u00e3o que retorna verdadeiro se tr\u00eas n\u00fameros reais recebidos como argumentos formam um tri\u00e2ngulo ou falso, caso contr\u00e1rio. \\item Uma fun\u00e7\u00e3o que recebe tr\u00eas n\u00fameros reais como argumento representado os lados de um tri\u00e2ngulo e retorna 0 caso os n\u00fameros formem um tri\u00e2ngulo equil\u00e1tero, 1 caso formem um tri\u00e2ngulo is\u00f3sceles, ou 2 caso sejam os lados de um tri\u00e2ngulo escaleno. \\item Por fim, a fun\u00e7\u00e3o \\verb|main| deve ler os 3 n\u00fameros que representam os lados, e caso formem um tri\u00e2ngulo, imprimir se o tri\u00e2ngulo formado \u00e9 equilatero, is\u00f3sceles ou escaleno. \\end{itemize} \\end{exercicio}\\] {Laborat\u00f3rio} Refa\u00e7a no computador os exerc\u00edcios propostos acima. \\chapter{Sele\u00e7\u00e3o Simples (II)} Uma vez apresentado a estrutura condicional \\emph{if-else}, veremos agora como realizar testes mais complexos utilizando operadores l\u00f3gicos. {\\lstinline|if-else| e Operadores L\u00f3gicos} At\u00e9 o ponto atual fizemos apenas testes simples dentro da condi\u00e7\u00e3o dos nossos \\lstinline!if!, por exemplo: \\begin{lstlisting} ... /* * esta funcao retorna verdadeiro se a pessoa de sexo * (1=Masculino, 2=Feminino) e idade passados como argumentos * for maior que idade ou falso, caso contrario */ bool ehMaior(int sexo, int idade) { if(sexo == 1) // masculino { if(idade >= 18) { return true; } else { return false; } } else if(sexo == 2) // feminino { if(idade >= 21) { return true; else { return false; } } else // sexo informado errado { return false; } } \\end{lstlisting} Observe que na fun\u00e7\u00e3o \\verb|ehMaior| temos \\lstinline{if} \\emph{aninhados}, ou seja, \\lstinline{if} dentro de \\lstinline{if}. Isto porque um pessoa deve ser do sexo masculino \\emph{E} possuir idade maior ou igual a 18 anos para ser considerada maior de idade. \\emph{OU} ainda, ela pode ser do sexo feminino \\emph{E} possuir idade igual ou maior a 21 anos. Quando esta situa\u00e7\u00e3o ocorre, as condi\u00e7\u00f5es podem ser combinadas em um \u00fanico \\lstinline!if! utilizando-se operadores l\u00f3gicos. Os operadores l\u00f3gicos que usaremos s\u00e3o o E, o OU e a N\u00c3O (nega\u00e7\u00e3o). Na linguagem C, eles s\u00e3o representados pelos s\u00edmbolos a seguir: \\begin {table}[!ht] \\begin{center} \\caption{Operadores l\u00f3gicos e seus s\u00edmbolos na linguagem C.} \\begin{tabular}{|c|c|c|}\\hline Operador L\u00f3gico & S\u00edmbolo & S\u00edmbolo novo\\footnote{Dispon\u00edvel somente em compiladores C++ ISO98} \\ \\hline \\hline E & \\&\\& & and\\ OU & || & or\\ N\u00c3O & ! & not\\ \\hline \\end{tabular} \\end{center} \\end{table} Os operadores l\u00f3gicos podem ser resumidos nas tabelas a seguir: \\begin {table}[!ht] \\begin{center} \\caption{N\u00c3O l\u00f3gico.} { \\begin{tabular}{|c|c|} \\hline \\textbf{A} & \\textbf{!A} \\ \\hline \\hline V & F \\ \\hline F & V \\ \\hline\\hline \\end{tabular} } \\end{center} \\end{table} \\begin {table}[!ht] \\begin{center} \\caption{E l\u00f3gico.} { \\begin{tabular}{|c|c|c|} \\hline \\textbf{A} & \\textbf{B} & \\textbf{A \\&\\& B} \\ \\hline \\hline V & V & V \\ \\hline V & F & F \\ \\hline F & V & F \\ \\hline F & F & F \\ \\hline\\hline \\end{tabular} } \\end{center} \\end{table} \\begin {table}[!ht] \\begin{center} \\caption{OU l\u00f3gico.} { \\begin{tabular}{|c|c|c|} \\hline \\textbf{A} & \\textbf{B} & \\textbf{A || B} \\ \\hline \\hline V & V & V \\ \\hline V & F & V \\ \\hline F & V & V \\ \\hline F & F & F \\ \\hline\\hline \\end{tabular} } \\end{center} \\end{table} Voltando ao nosso exemplo, a fun\u00e7\u00e3o anterior pode ser reescrita da seguinte forma: \\[\\begin{lstlisting} ... /* * esta funcao retorna verdadeiro se a pessoa de sexo * (1=Masculino, 2=Feminino) e idade passados como argumentos * for maior de idade ou falso, caso contrario */ bool ehMaior(int sexo, int idade) { if((sexo == 1 && idade >=18) || (sexo == 2 && not(idade < 21)) { return true; } else // sexo errado ou idade errada { return false; } } \\end{lstlisting}\\] Perceba que em apenas um \\lstinline!if! colocamos a condi\u00e7\u00e3o completa, ou seja, ``se sexo igual a 1 E idade maior ou igual a 18 OU sexo igual a 2 e idade N\u00c3O menor do que 21 ent\u00e3o \u00e9 maior de idade''. {Prioridade dos Operadores} Quando mais de um operador l\u00f3gico aparece em uma express\u00e3o, a preced\u00eancia pode ser expressa da seguinte maneira: primeiro o N\u00c3O, depois o E, por \u00faltimo o OU. Quando houver par\u00eanteses, primeiro avalia-se o que estiver dentro dos mesmos. Em diversas express\u00f5es e testes, diversos operadores dos v\u00e1rios tipos podem aparecer. A avalia\u00e7\u00e3o dessa express\u00e3o deve obedecer \u00e0 seguinte ordem de prioridade em rela\u00e7\u00e3o aos operadores: \\begin{enumerate} \\item Par\u00eanteses, incremento e decremento (\\lstinline|++|, \\lstinline|--|) \\item \\lstinline|not| (!) \\item Multiplica\u00e7\u00e3o, divis\u00e3o e m\u00f3dulo (o que aparecer primeiro); \\item Soma e subtra\u00e7\u00e3o; \\item Operadores relacionais (<, <=, >, >=) \\item Operadores relacionais (==, !=) % \\item OU-Exclusivo (\\lstinline|^| ) \\item \\lstinline|and| (\\&\\&) \\item \\lstinline|or| (||) \\item Atribui\u00e7\u00e3o (=, +=, -=, *=, /=, \\%=) \\end{enumerate} Embora os operadores l\u00f3gicos fa\u00e7am sentido somente para operandos \\lstinline!bool!, \u00e9 importante relembrar que, para o computador, verdadeiro e falso s\u00e3o apenas formas de interpretar n\u00fameros na mem\u00f3ria. Na linguagem C, qualquer n\u00famero diferente de 0 \u00e9 tratado como \\lstinline!true! e 0 \u00e9 tratado como \\lstinline!false!. Sendo assim, \u00e9 poss\u00edvel aplicar operadores l\u00f3gicos tamb\u00e9m \u00e0 n\u00fameros. Contudo, sempre que requisitado a representar o valor \\lstinline!true! como n\u00famero, o computador usar\u00e1 o valor 1, o que faz com que nem todas as computa\u00e7\u00f5es tenham resultados \u00f3bvios. Por exemplo, o c\u00f3digo \\lstinline!cout<<(2||0);! imprime, na tela, o valor 1. Isto por qu\u00ea 2 \u00e9 tratado como verdadeiro e 0 como falso, e o resultado de verdadeiro OU falso \u00e9 verdadeiro, que \u00e9 ent\u00e3o convertido para 1. Da mesma forma, \\lstinline|!!3| \u00e9 1, pois \\lstinline|!3| \u00e9 falso e sua nega\u00e7\u00e3o \u00e9 verdadeiro, que \u00e9 1. {Exerc\u00edcios} \\[\\begin{exercicio} Avalie o resultado de cada express\u00e3o a seguir (verdadeiro ou falso): \\begin{itemize} \\item \\lstinline|2 < 5 && 15/3 == 5| \\item \\lstinline|pow(3,2) - 5 > 0 && 5/2 == 3 - 4| \\item \\lstinline?F || 20 == 18/3 != 21/3 / 2? \\item \\lstinline?!V || 3*3/3 < 15 - 35%7? \\item \\lstinline?!(5 != 10/2) || V && 2 - 5 > 5 - 2 || V? \\item \\lstinline?pow(2,4) != 4 + 2 || 2 + 3 * 5/3%5 < 0? \\item \\lstinline|!1+1| %1 \\item \\lstinline|!2+1| %1 \\item \\lstinline|!0+1| %2 \\end{itemize} \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a um programa que: \\begin{enumerate} \\item contenha uma fun\u00e7\u00e3o que retorna verdadeiro se um n\u00famero for divis\u00edvel por 3 ou 5, mas n\u00e3o simultaneamente pelos dois, e; \\item na fun\u00e7\u00e3o principal sejam lidos dois n\u00fameros inteiros, que dever\u00e3o ser passados para a fun\u00e7\u00e3o criada, tendo seu resultado impresso. \\end{enumerate} \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais (\\lstinline|float|) correspondentes aos lados de um tri\u00e2ngulo e retorne \\lstinline|true| caso esse tri\u00e2ngulo seja ret\u00e2ngulo ou \\lstinline|false| caso n\u00e3o o seja. A fun\u00e7\u00e3o principal deve ler os valores dos lados do tri\u00e2ngulo, verificar se realmente formam um tri\u00e2ngulo e imprimir \"sim\" se \u00e9 ou \"n\u00e3o\", caso n\u00e3o seja tri\u00e2ngulo ret\u00e2ngulo; se n\u00e3o formar um tri\u00e2ngulo, imprimir \"n\u00e3o forma\". \\end{exercicio}\\] {Laborat\u00f3rio} \\begin{lab} Escreva um programa que implemente uma calculadora com as quatro opera\u00e7\u00f5es +,-,* e /. Sua calculadora deve ler um n\u00famero real X, seguido de um inteiro representando um dos operadores definidos (1 para -, 2 para +, 3 para * e 4 para /), seguido de outro n\u00famero real Y. Finalmente, seu programa deve escrever o resultado da opera\u00e7\u00e3o desejada. \\end{lab} \\todo{Revisado at\u00e9 aqui} \\chapter{Switch} Em diversas situa\u00e7\u00f5es em programa\u00e7\u00e3o, \u00e9 necess\u00e1rio testar se uma determinada vari\u00e1vel tem um dentre diversos poss\u00edveis valores. Nesta situa\u00e7\u00e3o, embora seja poss\u00edvel usar v\u00e1rios \\lstinline|if|, outra solu\u00e7\u00e3o nos \u00e9 dada em linguagem C: o uso de \\lstinline|switch|. {\\lstinline|switch-case-default|} Considere o problema de transformar o m\u00eas de uma representa\u00e7\u00e3o num\u00e9rica de uma data em sua representa\u00e7\u00e3o textual. Isto \u00e9, transformar, por exemplo, 25/12/2012 em 25 de Dezembro de 2012. Uma poss\u00edvel solu\u00e7\u00e3o para este problema, em C(++), \u00e9 o seguinte. \\begin{lstlisting} include using namespace std; int main() { int dia, mes, ano; cout << \"Dia? \" <<endl; cin >> dia; cout << \"Mes? \" <<endl; cin >> mes; cout << \"Ano? \" <<endl; cin >> ano; cout << dia << \" de \"; if(mes == 1) cout << \"Janeiro\"; else if(mes == 2) cout << \"Fevereiro\"; else if(mes == 3) cout << \"Marco\"; else if(mes == 4) cout << \"Abril\"; else if(mes == 5) cout << \"Maio\"; else if(mes == 6) cout << \"Junho\"; else if(mes == 7) cout << \"Julho\"; else if(mes == 8) cout << \"Agosto\"; else if(mes == 9) cout << \"Setembro\"; else if(mes == 10) cout << \"Outubro\"; else if(mes == 11) cout << \"Novembro\"; else if(mes == 12) cout << \"Dezembro\"; else cout << \"Hein?-zembro\"; cout << \" de \" << ano << endl; return 0; } \\end{lstlisting} Em vez de usar v\u00e1rios \\lstinline|if| e \\lstinline|else-if|, uma solu\u00e7\u00e3o melhor seria usar \\lstinline|switch|, criado exatamente para tratar estas situa\u00e7\u00f5es. A sintaxe do uso do \\lstinline|switch| \u00e9 a seguinte.\\ \\lstinline|switch| (identificador)\\ {\\ \\lstinline|case| valor1: bloco_comandos1\\ \\lstinline|case| valor2: bloco_comandos2\\ \\ldots\\ \\lstinline|case| valorN: bloco_comandosN\\ \\lstinline|default|: bloco_comandos_default\\ } \\[\\begin{itemize} \\item identificador: Identificador da vari\u00e1vel a ser testada \\item valor1: primeiro caso a ser testado \\item bloco\\_comandos1: bloco de comandos a ser executado caso a vari\u00e1vel tenha valor igual a valor1 \\item valor2: segundo caso a ser testado \\item bloco\\_comandos2: bloco de comandos a ser executado caso a vari\u00e1vel tenha valor igual a valor2 \\item \\ldots outros casos a serem testados \\item valor n: \u00faltimo caso a ser testado \\item bloco\\_comandosN: bloco de comandos a ser executado caso a vari\u00e1vel tenha valor igual a valorN \\item default: um valor especial, que sempre ``casa'' com o valor da vari\u00e1vel \\item bloco\\_comandos\\_default: bloco de comandos a ser executado caso a vari\u00e1vel ``case'' com default. \\end{itemize}\\] Usando \\lstinline|switch-case-default|, o exemplo acima pode ser reescrito assim. \\begin{lstlisting} include using namespace std; int main() { int dia, mes, ano; cout << \"Dia? \" <<endl; cin >> dia; cout << \"Mes? \" <<endl; cin >> mes; cout << \"Ano? \" <<endl; cin >> ano; cout << dia << \" de \"; switch(mes) { case 1: cout << \"Janeiro\"; case 2: cout << \"Fevereiro\"; case 3: cout << \"Marco\"; case 4: cout << \"Abril\"; case 5: cout << \"Maio\"; case 6: cout << \"Junho\"; case 7: ... case 11: cout << \"Novembro\"; case 12: cout << \"Dezembro\"; default: cout << \"Hein?-zembro\"; } cout << \" de \" << ano << endl; return 0; } \\end{lstlisting} Execute este c\u00f3digo e digite, por exemplo, a data 1/1/2012 para ver que ele funciona ``quase'' corretamente. O problema, voc\u00ea deve ter observado, \u00e9 que al\u00e9m de imprimir o nome do m\u00eas correto, o programa imprime tamb\u00e9m o nome de todos os meses subsequentes e o valor \\lstinline|default|. Isso ocorre por que, na verdade, o \\lstinline|switch| come\u00e7a a executar o bloco correspondente ao \\lstinline|case| com o valor da vari\u00e1vel mas, a partir da\u00ed, executa todos os blocos a n\u00e3o ser que seja instru\u00eddo a fazer diferente, o que \u00e9 feito via a instru\u00e7\u00e3o \\lstinline|break|. {\\lstinline|break|} A instru\u00e7\u00e3o \\lstinline|break| diz ao computador que pare de executar o \\lstinline|switch| no ponto em que \u00e9 invocada.\\footnote{Mais tarde veremos outros blocos no qual o \\lstinline|break| pode ser utilizado.} Sendo assim, podemos reescrever o programa mais uma vez para obter exatamente o comportamento da vers\u00e3o usando \\lstinline|if|. \\begin{lstlisting} include using namespace std; int main() { int dia, mes, ano; cout << \"Dia? \" <<endl; cin >> dia; cout << \"Mes? \" <<endl; cin >> mes; cout << \"Ano? \" <<endl; cin >> ano; cout << dia << \" de \"; switch(mes) { case 1: cout << \"Janeiro\"; break; case 2: cout << \"Fevereiro\"; break; case 3: cout << \"Marco\"; break; case 4: cout << \"Abril\"; break; case 5: cout << \"Maio\"; break; case 6: cout << \"Junho\"; break; case 7: cout << \"Julho\"; break; case 8: cout << \"Agosto\"; break; case 9: cout << \"Setembro\"; break; case 10: cout << \"Outubro\"; break; case 11: cout << \"Novembro\"; break; case 12: cout << \"Dezembro\"; break; default: cout << \"Hein?-zembro\"; break; } cout << \" de \" << ano << endl; return 0; } \\end{lstlisting} {Exerc\u00edcios} \\begin{exercicio} \\label{exe:switch:1} Implemente uma fun\u00e7\u00e3o chamada \\lstinline|menu| que imprima o seguinte menu na tela: \\begin{enumerate} \\item Soma \\item M\u00e9dia \\item Menor \\item Maior \\end{enumerate} Leia e que retorne o n\u00famero da op\u00e7\u00e3o escolhida. Implemente a fun\u00e7\u00e3o \\lstinline|main| de forma a ler tr\u00eas n\u00fameros e, ent\u00e3o, invocar a fun\u00e7\u00e3o definida acima para decidir o que fazer. O resultado da fun\u00e7\u00e3o deve ser armazenando em uma vari\u00e1vel e seu conte\u00fado testado com \\lstinline|switch|. Cada op\u00e7\u00e3o deve invocar a fun\u00e7\u00e3o respectiva, que calcular\u00e1 e retornar\u00e1 o que se pede. A fun\u00e7\u00e3o \\lstinline|main| imprimir\u00e1 ent\u00e3o o resultado. \\begin{lstlisting} include include include using namespace std; int menu() { int opcao; cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; return opcao; } int menor(int x, int y, int z) { if(x <= y && x <= z) return x; if(y <= x && y <= z) return y; return z; } int maior(int x, int y, int z) { if(x >= y && x >= z) return x; else if(y >= x && y<= z) return y; else return z; } int soma(int x, int y, int z) { return x+y+z; } float media(int x, int y, int z) { float somatorio = soma(x,y,z); return somatorio / 3.0; } int main() { int a, b, c; int opcao; cout << \"digite tres numero inteiros\" <<endl; cin >> a >> b >> c; opcao = menu(); switch(opcao) { case 1: cout << \"A soma dos tres numeros eh \" << soma(a,b,c); break; case 2: cout << \"A media dos tres numeros eh \" << media(a,b,c); break; case 3: cout << \"O menor dentre os tres numeros eh \" << menor(a,b,c); break; case 4: cout << \"O maior dentre os tres numeros eh \" << maior(a,b,c); break; default: cout << \"Opcao invalida. Execute o programa novamente e leia direito as opcoes.\"; } return 0; } \\end{lstlisting} \\end{exercicio} \\[\\begin{exercicio} Escreva um programa com uma fun\u00e7\u00e3o que receba um inteiro entre 1 e 7, inclusive, e escreva o dia correspondente da semana (1 para domingo e 7 para s\u00e1bado). \\end{exercicio}\\] \\begin{exercicio} \\label{exe:switch:3} Escreva um programa com uma fun\u00e7\u00e3o que receba um inteiro de 1 a 12 e retorne a quantidade de dias no m\u00eas correspondente (assuma que o ano n\u00e3o \u00e9 bisexto). Para este exerc\u00edcio, a solu\u00e7\u00e3o mais simples envolve n\u00e3o colocar \\lstinline|break| em alguns dos \\lstinline|case|. \\end{exercicio} {Laborat\u00f3rio} Implemente os exerc\u00edcios de \\ref{exe:switch:1} a \\ref{exe:switch:3}. \\chapter{Repeti\u00e7\u00e3o (I)} Em certas situa\u00e7\u00f5es \u00e9 necess\u00e1ria a repeti\u00e7\u00e3o de um conjunto de comandos. Em situa\u00e7\u00f5es como esta, temos duas op\u00e7\u00f5es: ou copiamos e colamos todo o trecho que desejamos repetir, fazendo os ajustes necess\u00e1rios; ou utilizamos uma sa\u00edda mais inteligente por meio de comandos especiais que permitem automatizar a repeti\u00e7\u00e3o. Neste cap\u00edtulo veremos o comando de repeti\u00e7\u00e3o \\lstinline|while| e alguns exemplos de seu uso. {Motiva\u00e7\u00e3o} Suponha de voc\u00ea deseja fazer um programa para ler duas notas, calcular e imprimir a m\u00e9dia de dez alunos da disciplina. A maneira menos pr\u00e1tica de fazer isso seria: \\[\\begin{lstlisting} ... float nota1, nota2, media; cout << \"Entre nota 1 e nota 2 do aluno 1: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 2: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 3: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 4: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 5: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 6: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 7: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 8: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 9: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 10: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; ... \\end{lstlisting}\\] Este c\u00f3digo tem v\u00e1rios problemas. Primeiro, ele \u00e9 mais propenso a erros; se, por exemplo, voc\u00ea resolve renomear a vari\u00e1vel \\lstinline|nota2| para \\lstinline|notab|, voc\u00ea ter\u00e1 que faz\u00ea-lo em diversos pontos do programa, aumentando a possibilidade de esquecer algum. Em segundo lugar, o c\u00f3digo exigiu grande retrabalho, isto \u00e9, a repeti\u00e7\u00e3o de uma mesma tarefa por parte do programador. Finalmente, se voc\u00ea precisar aumentar a quantidade de repeti\u00e7\u00f5es para, digamos, 100 alunos, ter\u00e1 que estender o c\u00f3digo por p\u00e1ginas e p\u00e1ginas. Para evitar tais problemas, para estas situa\u00e7\u00f5es a linguagem C(++) fornece estruturas de repeti\u00e7\u00f5es, as quais permitem repetir um determinado conjunto de comandos. {O comando \\lstinline|while|} Um destes comandos \u00e9 o comando \\lstinline|while| (enquanto, em portugu\u00eas). Sua forma geral \u00e9 muito simples: \\[\\begin{lstlisting} while (<condicao>) { // bloco de comandos a ser repetido } \\end{lstlisting}\\] O bloco de comandos entre as chaves ser\u00e1 repetido \\textbf{enquanto a condi\u00e7\u00e3o dentro dos par\u00eanteses for verdadeira}. Utilizando o \\lstinline|while|, o exemplo anterior pode ser reescrito de maneira bem mais pr\u00e1tica: \\begin{lstlisting} ... float nota1, nota2, media; int i = 1; // valor inicial do identificador do aluno while (i <= 10) { cout << \"Entre nota 1 e nota 2 do aluno: \" << endl; cin << nota1 << nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; i = i +1; // aumentamos o valor de i no final de cada calculo da media } ... \\end{lstlisting} Observe as seguintes modifica\u00e7\u00f5es: \\begin{itemize} \\item Uma nova vari\u00e1vel, \\lstinline|i|, foi criada para contabilizar o n\u00famero de alunos. \\item Esta vari\u00e1vel \u00e9 inicializada com o valor 1, representando o primeiro aluno. \\item A condi\u00e7\u00e3o dentro do comando de repeti\u00e7\u00e3o ser\u00e1 verdadeira enquanto o valor de \\lstinline|i| for menor ou igual a 10. \\item Por este motivo, devemos incrementar o valor de \\lstinline|i| ao fim de cada ciclo. \\end{itemize} Normalmente, a vari\u00e1vel que conta a quantidade de itera\u00e7\u00f5es executadas, \\lstinline|i| no exemplo dado, \u00e9 chamada de contadora. No exemplo, a vari\u00e1vel contadora foi usada apenas para este fim, contar, e n\u00e3o aparece no bloco de comandos sendo repetido. Isto nem sempre \u00e9 o caso, como veremos em outros exemplos. Antes, por\u00e9m, vejamos uma varia\u00e7\u00e3o do \\lstinline|while|. {O comando \\lstinline|do-while|} Se por acaso a condi\u00e7\u00e3o verificada no \\lstinline|while| for inicialmente falsa, o bloco n\u00e3o ser\u00e1 repetido nem mesmo uma vez. Para situa\u00e7\u00f5es em que \u00e9 preciso executar o bloco pelo menos uma vez, uma varia\u00e7\u00e3o do comando \\lstinline|while| \u00e9 fornecida pela linguagem C. Trata-se do comando \\lstinline|do-while| (fa\u00e7a-enquanto ou repita-enquanto, em portugu\u00eas). Sua forma geral \u00e9 dada por: \\begin{lstlisting} do { \\ bloco de comandos \\ a ser repetido } while ( ); \\end{lstlisting} O mesmo exemplo anterior pode ser reescrito utilizando este comando: \\[\\begin{lstlisting} do { cout << \"Entre nota 1 e nota 2 do aluno : \" << endl; cin >> nota1 >> nota2; i = 1+1; // aumentamos o valor de i no final de cada calculo da media media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; } while (i <= 10); \\end{lstlisting}\\] Em compara\u00e7\u00e3o ao comando \\lstinline|while|, a \u00fanica diferen\u00e7a existente \u00e9 o fato do teste da condi\u00e7\u00e3o ser feito ap\u00f3s a execu\u00e7\u00e3o do bloco de comandos que se deseja repetir. Uma implica\u00e7\u00e3o disto \u00e9 que, em casos em que a condi\u00e7\u00e3o \u00e9 falsa logo no primeiro teste, o bloco de comandos \u00e9 executado com \\lstinline|do-while|, mas n\u00e3o \u00e9 executado com \\lstinline|while|. Isto aconteceria para a vari\u00e1vel \\lstinline|i| com valor inicial de 11, por exemplo. {Mais exemplos} Considere que deseja-se somar todos os n\u00fameros pares entre 1 e 999. Ou fazemos uma soma com todos os valores em uma linha enorme, ou utlizamos o que apresendemos sobre comandos de repeti\u00e7\u00e3o. Utilizando o \\lstinline|while|, ter\u00edamos: \\[\\begin{lstlisting} ... int n = 2, // primeiro par maior do que 1 soma = 0; // soma inicialmente zerada while (n < 999) { soma = soma + n; n = n + 2; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] Observe que a cada itera\u00e7\u00e3o o valor de soma \u00e9 acrescido do pr\u00f3ximo n\u00famero par, o qual \u00e9 obtido somando-se 2 ao valor de \\lstinline|n|. Imagine que se deseja obter o maior entre 10 n\u00fameros inteiros lidos. Utilizando o \\lstinline|do-while|, uma poss\u00edvel solu\u00e7\u00e3o seria: \\[\\begin{lstlisting} ... int i = 0, // contador da qtde de numeros lidos maior, n; do { cout << \"Entre um numero: \"; cin >> n; if (i == 0) // se for o primeiro numero lido { // ele sera o menor maior = n; } else // a partir do segundo { if(n > maior) // atualizo o maior { maior = n; } } i = i + 1; } while (i < 10); ... \\end{lstlisting}\\] Neste exemplo temos uma situa\u00e7\u00e3o especial em que, no primeiro caso (\\lstinline|i = 0|), o maior valor \u00e9 o \u00fanico valor lido. A partir do segundo n\u00famero, se o n\u00famero lido for maior do que o valor armazenado na vari\u00e1vel \\lstinline|maior|, esta ser\u00e1 atualizada. Em outro exemplo, imagine que queira ler n\u00fameros at\u00e9 que leia um n\u00famero maior que 100. Neste caso, o seguinte programa resolveria nosso problema. \\[\\begin{lstlisting} ... int num; do { cout << \"Entre um numero: \"; cin >> num; } while (! num > 100); ... \\end{lstlisting}\\] Neste exemplo utilizamos \\lstinline|do-while| pois \u00e9 necess\u00e1rio ler pelo menos um n\u00famero. Reescreva o c\u00f3digo utilizando \\lstinline|while| e veja como fica, necessariamente, mais complexo. {Operadores de incremento e outras constru\u00e7\u00f5es especiais} Nos exemplos apresentados, a vari\u00e1vel contadora foi manipulada em todas as repeti\u00e7\u00f5es de uma forma bem comum, sendo incrementada de 1 em 1 ou de 2 em 2. Repeti\u00e7\u00f5es tem esta caracter\u00edstica, embora as opera\u00e7\u00f5es aplicadas aos contadores n\u00e3o sejam sempre simples incrementos e decrementos. Com a finalidade de agilizar o desenvolvimento e simplificar algumas opera\u00e7\u00f5es aritm\u00e9ticas mais comuns, a linguagem C(++) permite algumas constru\u00e7\u00f5es especiais envolvendo operadores. Considere o seguinte trecho de c\u00f3digo: \\begin{lstlisting} int a, b; ... a = a + b; b = b * 2; a = a / 7; \\end{lstlisting} Observe que nas tr\u00eas atribui\u00e7\u00f5es (indicadas pelo sinal de igualdade), as vari\u00e1veis que s\u00e3o atualizadas tamb\u00e9m aparecem como primeiro elemento da opera\u00e7\u00e3o aritm\u00e9tica \u00e0 esquerda. Nestas situa\u00e7\u00f5es, podemos reescrever as atribui\u00e7\u00f5es assim: \\begin{lstlisting} int a, b; ... a += b; b *= 2; a /= 7; \\end{lstlisting} As opera\u00e7\u00f5es de incremento (aumento de uma unidade) e o decremento (diminui\u00e7\u00e3o de uma unidade) de uma vari\u00e1vel s\u00e3o muito comuns em programa\u00e7\u00e3o. Sendo assim, a linguagem C define dois operadores para as mesmas: \\verb|++| e \\verb|--|, respectivamente. Veja o exemplo. \\[\\begin{lstlisting} int a = 0; a = a + 1; cout << \"a = \" << a << endl; a += 1; cout << \"a = \" << a << endl; a++; cout << \"a = \" << a << endl; a--; cout << \"a = \" << a << endl; \\end{lstlisting}\\] O trecho acima deve imprimir os valores de \\lstinline|a|, ou seja, 1, 2, 3 e 2. \\newpage {Exerc\u00edcios} \\[\\begin{exercicio} Diga o que ser\u00e1 escrito na tela durante a execu\u00e7\u00e3o do seguinte trecho de c\u00f3digo: \\begin{lstlisting} int a, b = 0, c = 0; a = ++b + ++c; cout << a << \", \" << b << \", \" << c << endl; a = b++ + c++; cout << a << \", \" << b << \", \" << c << endl; a = ++b + c++; cout << a << \", \" << b << \", \" << c << endl; a = b-- + --c; cout << a << \", \" << b << \", \" << c << endl; \\end{lstlisting} \\end{exercicio}\\] \\todo{Incluir exerc\u00edcios mais simples como os da lista 1 do Prof. Anilton.} Fa\u00e7a os exerc\u00edcios a seguir \u00e0 m\u00e3o. \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o que recebe um n\u00famero inteiro positivo e retorna o fatorial deste n\u00famero. A fun\u00e7\u00e3o principal deve ler o n\u00famero do qual se deseja calcular o fatorial e imprimir o resultado. \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o que recebe um n\u00famero inteiro positivo e retorna \\lstinline|true| se o n\u00famero for primo ou \\lstinline|false|, caso contr\u00e1rio. A fun\u00e7\u00e3o principal (\\lstinline|main|) deve ler o n\u00famero e imprimir o resultado. \\end{exercicio}\\] \\[\\begin{exercicio} Modifique o programa anterior para imprimir todos os n\u00fameros primos abaixo de dois milh\u00f5es. \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a um programa que leia um n\u00famero inteiro positivo e imprima esse n\u00famero de tr\u00e1s pra frente. A impress\u00e3o deve ser feita pela fun\u00e7\u00e3o auxiliar \\texttt{inverteNumero}. \\end{exercicio}\\] \\newpage {Laborat\u00f3rio} \\[\\begin{lab} Implemente os exerc\u00edcios acima no Code::Blocks. \\end{lab}\\] \\[\\begin{lab} Escreva uma fun\u00e7\u00e3o que receba dois par\u00e2metros inteiros, $x$ e $y$, $x < y$ e que imprima $y$ pontos na tela e que a cada $x$ pontos, imprima um acento circunflexo. \\end{lab}\\] \\begin{lab} \\label{exer:floyd} O exerc\u00edcio \\ref{exer:menu} pedia que voc\u00ea escrevesse uma fun\u00e7\u00e3o que gerasse um menu na tela. A fun\u00e7\u00e3o que voc\u00ea escreveu tinha um problema: ela aceitava qualquer valor, mesmo algum n\u00e3o correspondendo a nenhuma op\u00e7\u00e3o do menu. Usando \\lstinline|do-while|, altere sua fun\u00e7\u00e3o para que continue exibindo o menu e lendo uma op\u00e7\u00e3o at\u00e9 que uma op\u00e7\u00e3o v\u00e1lida seja digitada pelo usu\u00e1rio. \\end{lab} \\begin{lab} Implemente uma fun\u00e7\u00e3o chamada \\lstinline|pot| que receba um n\u00famero real e um inteiro, respectivamente \\lstinline|base| e \\lstinline|expoente|, como par\u00e2metros e que calcule \\small{ \\(\\texttt{base}^\\texttt{expoente}\\) }. A fun\u00e7\u00e3o \\lstinline|pot|, que voc\u00ea implementar\u00e1, deve usar multiplica\u00e7\u00f5es sucessivas para calcular seu resultado (isto \u00e9, \u00e9 proibido o uso da fun\u00e7\u00e3o \\lstinline|pow|). \\end{lab} \\begin{lab} Execute o seguinte programa em seu computador e observe o que acontece. \\[\\begin{lstlisting} ... int num = 10; do { cout << num; num *= 2; } while (1); ... \\end{lstlisting}\\] \u00c0 prop\u00f3sito, para terminar um programa basta digitar a combina\u00e7\u00e3o de teclas \\texttt{ctrl+c}. \\end{lab} \\[\\begin{lab} Escreva um programa que leia um numero inteiro positivo \\texttt{n} e em seguida imprima \\texttt{n} linhas do chamado Tri\u00e2ngulo de Floyd:\\\\ \\begin{verbatim} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \\end{verbatim} \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que gera um n\u00famero inteiro aleat\u00f3rio de 1 a 1000 em uma fun\u00e7\u00e3o denominada \\lstinline|geraNumero|. Na fun\u00e7\u00e3o principal, o usu\u00e1rio deve tentar acertar qual o n\u00famero foi gerado. A cada tentativa o programa dever\u00e1 informar se o chute \u00e9 menor ou maior que o n\u00famero gerado. O programa acaba quando o usu\u00e1rio acerta o n\u00famero gerado. O programa deve informar em quantas tentativas o n\u00famero foi descoberto. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que receba como entrada o valor do saque realizado pelo cliente de um banco e retorne quantas notas de cada valor ser\u00e3o necess\u00e1rias para atender ao saque com a menor quantidade de notas poss\u00edvel. Ser\u00e3o utilizadas notas de 100, 50, 20, 10, 5, 2 e 1 reais. O c\u00e1lculo e impress\u00e3o do resultado deve ser efetuado por uma fun\u00e7\u00e3o auxiliar denominada \\texttt{imprimeNotas}. \\end{lab}\\] \\chapter{Repeti\u00e7\u00e3o (II)} Voc\u00ea deve ter percebido que no uso de \\lstinline|do-while| e \\lstinline|while| quase sempre seguimos os mesmos passos: \\begin{itemize} \\item declarar uma vari\u00e1vel que sirva de controle para a itera\u00e7\u00e3o; \\item iniciar a vari\u00e1vel de controle (e possivelmente outras); \\item verificar a condi\u00e7\u00e3o para itera\u00e7\u00e3o \\item executar itera\u00e7\u00e3o \\item executar incremento/decremento (mudan\u00e7a da vari\u00e1vel de controle) \\end{itemize} A linguagem C tem um comando itera\u00e7\u00e3o que agrega todos estes passos, chamado \\lstinline|for|. {\\lstinline|for|} Sua forma geral do comando \\lstinline|for| \u00e9 a seguinte: \\begin{lstlisting} for(DI; C; I) { \\bloco de comandos a ser repetido } \\end{lstlisting} O comando \\lstinline|for| tem tr\u00eas partes em sua declara\u00e7\u00e3o, al\u00e9m dos comandos a serem repetidos. \\begin{itemize} \\item DI -- em DI vari\u00e1veis podem ser \\textbf{D}eclaradas e \\textbf{I}niciadas. Vari\u00e1veis j\u00e1 existentes tamb\u00e9m podem ter seus valores ajustados em DI; \\item C -- C define a \\textbf{C}ondi\u00e7\u00e3o necess\u00e1ria \u00e0 execu\u00e7\u00e3o do bloco de comandos. \\emph{Enquanto} a condi\u00e7\u00e3o for verdadeira, o bloco ser\u00e1 executado. \\item I -- comandos de modifica\u00e7\u00e3o de vari\u00e1veis, como \\textbf{I}ncremento e decremento, s\u00e3o colocados diretamente na declara\u00e7\u00e3o do \\lstinline|for|. O comando \u00e9 executado ao final de cada itera\u00e7\u00e3o. \\end{itemize} A execu\u00e7\u00e3o do \\lstinline|for| segue os seguintes passos: \\begin{enumerate} \\item Inicia\u00e7\u00e3o (execu\u00e7\u00e3o de DI) \\item Avalia\u00e7\u00e3o (teste da condi\u00e7\u00e3o em C) \\item Execu\u00e7\u00e3o do bloco de comandos \\item Incremento \\item De volta ao passo 2 \\end{enumerate} Considere o exemplo do cap\u00edtulo anterior em que deseja-se somar todos os n\u00fameros pares entre 1 e 999. O c\u00f3digo pode ser escrito, como vimos, usando \\lstinline|while|. \\[\\begin{lstlisting} ... int n = 2, // primeiro par maior do que 1 soma = 0; // soma inicialmente zerada while (n < 999) { soma = soma + n; n += 2; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] O c\u00f3digo equivalente, usando \\lstinline|for| \u00e9 essencialmente o mesmo. \\[\\begin{lstlisting} ... int n, // primeiro par maior do que 1 soma = 0; // soma inicialmente zerada for (n = 2; n < 999; n += 2) { soma = soma + n; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] O c\u00f3digo, contudo, pode ser simplificado colocando-se a declara\u00e7\u00e3o da vari\u00e1vel de controle no pr\u00f3prio \\lstinline|for|. \\[\\begin{lstlisting} ... int soma = 0; // soma inicialmente zerada for (int n = 2; n < 999; n += 2) { soma = soma + n; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] \u00c9 poss\u00edvel declarar e iniciar mais de uma vari\u00e1vel no DI, mas n\u00e3o \u00e9 poss\u00edvel definir novas vari\u00e1veis e iniciar outras j\u00e1 definidas. No exemplo abaixo, errado, a vari\u00e1vel soma sendo iniciada no \\lstinline|for| \u00e9 diferente da vari\u00e1vel definida antes do comando, apesar do nome ser igual. \\[\\begin{lstlisting} ... int soma = 0; // soma inicialmente zerada for (int n = 2, soma = 0; n < 999; n += 2) { soma = soma + n; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] {Mais Exemplos} Tamb\u00e9m do cap\u00edtulo anterior, imagine o exemplo em que se deseja obter o maior entre 10 n\u00fameros inteiros lidos. Utilizando o \\lstinline|for|, uma poss\u00edvel solu\u00e7\u00e3o seria: \\begin{lstlisting} ... int i, // contador da qtde de numeros lidos maior, n; cout << \"Entre um numero: \"; cin >> n; maior = n; for(i = 0; i < 9; i++) { cout << \"Entre um numero: \"; cin >> n; if(n > maior) // atualizo o maior { maior = n; } } ... \\end{lstlisting} Observe que a primeira leitura aconteceu fora do \\lstinline|for|. {Declara\u00e7\u00f5es especiais} Em certas situa\u00e7\u00f5es pode ser desej\u00e1vel omitir partes da declara\u00e7\u00e3o do \\lstinline|for|. Por exemplo, se as vari\u00e1veis de controle j\u00e1 tiverem sido iniciadas ou, simplesmente, se n\u00e3o existirem, ou se n\u00e3o houver incremento a ser feito, ent\u00e3o estas partes da declara\u00e7\u00e3o podem ser deixadas em branco. Por exemplo, \\begin{lstlisting} int menu() { int opcao = 0; for( ; opcao < 1 || opcao > 4 ; ) { cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; } return opcao; } \\end{lstlisting} Observe que embora neste exemplo tanto DI quanto I est\u00e3o vazias, isso n\u00e3o \u00e9 necess\u00e1rio. Isto \u00e9, qualquer das partes da declara\u00e7\u00e3o podem estar vazias independentemente, inclusive a segunda parte. {Alterando a repeti\u00e7\u00e3o com o \\lstinline!break! e \\lstinline!continue!} Caso a segunda parte do comando esteja vazia, a repeti\u00e7\u00e3o ser\u00e1 executada \\emph{ad infinitum} ou at\u00e9 que seja interrompida. A interrup\u00e7\u00e3o de uma itera\u00e7\u00e3o pode ser feita usando-se o comando \\lstinline{break}. Veja o exemplo anterior reescrito para usar tal comando. \\begin{lstlisting} int menu() { int opcao; for(;;) { cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; if(opcao > 0 && opcao < 5) break; else cout << \"Opcao invalida\" << endl << endl; } return opcao; } \\end{lstlisting} Outra forma de se alterar o fluxo \u00e9 via o comando \\lstinline{continue}, que faz com que a o restante do bloco de comandos seja ignorado e, conseq\u00fcentemente, incremento e condi\u00e7\u00e3o sejam reavaliados. Por exemplo, reescrevendo o c\u00f3digo acima para o usar o \\lstinline{continue}. \\begin{lstlisting} int menu() { int opcao; for(;;) { cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; if(opcao < 1 || opcao > 4) continue; cout << \"A opcao escolhida foi \" << opcao; break; } return opcao; } \\end{lstlisting} {Exerc\u00edcios} \\[\\begin{exercicio} Refa\u00e7a os exec\u00edcios do cap\u00edtulo anterior usando \\lstinline|for|. \\end{exercicio}\\] {Laborat\u00f3rio} \\[\\begin{lab} Refa\u00e7a o laborat\u00f3rio do cap\u00edtulo anterior usando \\lstinline|for|. \\end{lab}\\] \\begin{lab} Escreva uma fun\u00e7\u00e3o que receba dois par\u00e2metros inteiros, X e Y, e imprima X linhas na tela, cada uma com Y ``.''. Por exemplo, se sua fun\u00e7\u00e3o for invocada com X igual 3 e Y igual 2, o resultado deveria ser o seguinte \\begin{verbatim} .. .. .. \\end{verbatim} \\end{lab} \\[\\begin{lab} Escreva uma fun\u00e7\u00e3o que receba dois par\u00e2metros inteiros, X e Y, e imprima de forma decrescente os n\u00fameros de X*Y at\u00e9 1, em X linhas de Y n\u00fameros. Por exemplo, se sua fun\u00e7\u00e3o for invocada com X igual 4 e Y igual 3, o resultado deveria ser o seguinte \\begin{verbatim} 12 11 10 9 8 7 6 5 4 3 2 1 \\end{verbatim} \\end{lab}\\] \\chapter{Arranjos Unidimensionais} Tente resolver o seguinte problema: \\begin{enumerate} \\item ler um conjunto de 6 n\u00fameros inteiros \\item calcular sua m\u00e9dia \\item imprimir todos os n\u00fameros maiores que a m\u00e9dia na tela do computador \\end{enumerate} F\u00e1cil, certo? Basta declarar 6 vari\u00e1veis do tipo \\lstinline|int|, ler seus valores, somar seus valores e dividir por 6, calculando a m\u00e9dia. Finalmente, basta escolher aquelas vari\u00e1veis com n\u00fameros maiores que a m\u00e9dia e imprim\u00ed-las. Mas e se alter\u00e1ssemos o problema para que, em vez de 6, precisasse ler 10 n\u00fameros, ou 100? Ainda assim se poderia usar o mesmo algoritmo, com 10 ou 100 vari\u00e1veis em vez de 6. Mas ter muitas vari\u00e1veis distintas com a mesma finalidade n\u00e3o \u00e9 vi\u00e1vel por duas raz\u00f5es: \\begin{itemize} \\item dif\u00edcil de manter: se voc\u00ea precisar renomear uma vari\u00e1vel, ter\u00e1 que faz\u00ea-lo em todas as vari\u00e1veis;\\ se precisar aumentar ou diminuir o n\u00famero de vari\u00e1veis, ter\u00e1 que apagar/copiar e renomear. \\item evita reuso de c\u00f3digo: se uma mesma opera\u00e7\u00e3o precisa ser aplicada a cada vari\u00e1vel, o mesmo c\u00f3digo deve ser reescrito para cada vari\u00e1vel, dificultado o reuso de c\u00f3digo. \\end{itemize} A solu\u00e7\u00e3o para esta situa\u00e7\u00e3o \u00e9 o uso de vetores (ou vari\u00e1veis indexadas, ou arranjo, ou \\emph{array}). {Vetores} Continuando com nossa analogia da mem\u00f3ria do computador como uma planilha eletr\u00f4nica, um vetor \u00e9 uma vari\u00e1vel que nomeia diversas c\u00e9lulas cont\u00edguas da mem\u00f3ria do computador. Isto \u00e9, de certa forma, enquanto uma vari\u00e1vel \\lstinline|int| corresponde a uma \u00e1rea da mem\u00f3ria que cabe 1 inteiro, um vetor de 10 \\lstinline|int| \u00e9 uma vari\u00e1vel que cabe 10 inteiros. A sintaxe para a declara\u00e7\u00e3o est\u00e1tica de vetores \u00e9 bem simples (em cap\u00edtulos futuros veremos como declarar vetores din\u00e2micos, isto \u00e9, que podem variar seus tamanhos). \\[\\begin{verbatim} tipo identificador[tamanho]; \\end{verbatim}\\] Onde \\begin{itemize} \\item tipo -- \u00e9 o tipo do dado a ser armazenado em cada posi\u00e7\u00e3o do vetor; \\item identificador -- \u00e9 o nome do vetor; \\item tamanho -- \u00e9 a quantidade de c\u00e9lulas no vetor; \\end{itemize} O acesso a uma c\u00e9lula, para leitura ou atribui\u00e7\u00e3o, \u00e9 feito usando-se o identificador seguido pela posi\u00e7\u00e3o a ser acessada, entre colchetes (\\lstinline{[]}). Por exemplo, \\lstinline{x[3] = 0} atribui o valor 0 \u00e0 posi\u00e7\u00e3o de \u00edndice 3 do vetor \\lstinline|x|. Algo importante a ser observado aqui \u00e9 que a primeira posi\u00e7\u00e3o de um vetor de tamanho \\(n\\) tem \u00edndice 0 e a \u00faltima tem \u00edndice \\(n-1\\) . O exemplo a seguir resolve o problema apresentado na se\u00e7\u00e3o anterior usando vetores. \\begin{lstlisting} include using namespace std; define TAMANHO 10 int main() { int num[TAMANHO]; int soma = 0; int media; for(int i = 0; i < TAMANHO; i++) { cout << \"Digite o \" << i << \"-esimo valor: \"; cin >> num[i]; soma += num[i]; } media = soma/TAMANHO; cout << \"Os valores acima da media \" << media << \" sao\" << endl; for(int i = 0; i < TAMANHO; i++) { if(num[i] > media) cout << num[i] << endl; } return 0; } \\end{lstlisting} Observe a defini\u00e7\u00e3o e o uso da palavra \\lstinline{TAMANHO} no programa. Uma vez definido que \\lstinline{TAMANHO} tem o valor 10, o computador substituir\u00e1 toda ocorr\u00eancia desta palavra no programa pelo valor correspondente, \\emph{antes} da compila\u00e7\u00e3o. Uma varia\u00e7\u00e3o interessante do problema calcula a m\u00e9dia apenas de n\u00fameros positivos e a entrada de um n\u00famero negativo serve para finalizar o fim da entrada. O c\u00f3digo seguinte resolve o problema. \\begin{lstlisting} include using namespace std; define TAMANHO 100 int main() { int num[TAMANHO]; int soma = 0; int media; int contador = 0; for(int i = 0; i < TAMANHO; i++) { cout << \"Digite o \" << i << \"-esimo valor: \"; cin >> num[i]; if(num[i] >= 0) { soma += num[i]; contador++; } else { break; } } media = soma/contador; cout << \"Os valores acima da media \" << media << \" sao\" << endl; for(int i = 0; i < contador; i++) { if(num[i] > media) cout << num[i] << endl; } return 0; } \\end{lstlisting} Observe como a vari\u00e1vel \\lstinline|contador| \u00e9 usada para contar a quantidade de n\u00fameros v\u00e1lidos lidos e como ela \u00e9 usada como limitante da varredura do vetor no segundo \\lstinline|for|. Observe tamb\u00e9m como o \\lstinline|break| \u00e9 utilizado para interromper o \\lstinline|for|. {Exerc\u00edcios} \\[\\begin{exercicio} Escreva um programa que leia 10 n\u00fameros e imprima o menor e o maior entre eles (n\u00e3o \u00e9 necess\u00e1rio usar vetores aqui). \\end{exercicio}\\] \\[\\begin{exercicio} Escreva um programa que leia 10 n\u00fameros e calcule e imprima a m\u00e9dia e desvio padr\u00e3o dos mesmos. Lembre-se que o desvio padr\u00e3o \u00e9 definido como a raiz quadrada dos quadrados das diferen\u00e7as dos valores para a m\u00e9dia dos valores. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva um programa que leia 11 n\u00fameros reais e imprima os valores dos 10 primeiros multiplicados pelo 11-\u00e9simo. Por exemplo, se os valores digitados foram 1, 2, 3 ,4 ,5 ,6, 7, 8, 9, 10 e 1.1, ent\u00e3o seu programa deve imprimir 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 e 11.0. \\end{exercicio}\\] {Laborat\u00f3rio} \\[\\begin{lab} Escreva um programa que leia um n\u00famero inteiro \\lstinline|n| e ent\u00e3o leia \\lstinline|n| n\u00fameros reais. Em seguida, seu programa deve imprimir a m\u00e9dia e desvio padr\u00e3o dos n\u00fameros lidos. Seu programa deve \\textbf{ignorar} n\u00fameros negativos. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia \\lstinline|n| n\u00fameros reais e imprima seus valores na tela. Em seguida, leia mais um n\u00famero real \\lstinline|x| e imprima o valor dos \\lstinline|n| n\u00fameros multiplicados \\lstinline|x|. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia \\lstinline|n| booleanos e imprima seus valores na tela. Em seguida, imprima todos os booleanos invertidos, na linha seguinte. \\end{lab}\\] \\chapter{Caracteres, Vetores de Caracteres e Strings} {Representa\u00e7\u00e3o de caracteres} Al\u00e9m dos tipos de dados num\u00e9ricos com os quais temos trabalhado at\u00e9 agora, outro tipo de dado \u00e9 muito importante no desenvolvimento de programas de computador, o tipo caractere. Estes tipos s\u00e3o a base para representa\u00e7\u00e3o de informa\u00e7\u00e3o textual como, por exemplo, a frase \"eu amo programar em C\"? Vari\u00e1veis com caracteres, em C(++), s\u00e3o declarados com sendo do tipo \\lstinline|char|, e sua leitura e escrita ocorre como para qualquer outro tipo de dados. Por exemplo, \\begin{lstlisting} include using namespace std; int main() { char letra; cout << \"digite uma letra qualquer seguida de enter \"; cin >> letra; cout << \"voce digitou \"<< letra << endl; return 0; } \\end{lstlisting} Se voc\u00ea pretende atribuir um caracter diretamente a uma vari\u00e1vel, \u00e9 importante se atentar \u00e0 seguinte nota\u00e7\u00e3o: caracteres s\u00e3o sempre escritos entre aspas simples. Por exemplo, \\lstinline|'a'|, \\lstinline|'3'| ou \\lstinline|'.'|. Raramente voc\u00ea trabalhar\u00e1 com caracteres um a um, normalmente usando vetores para armazenar palavras e frases. {Vetores de Caracteres} Vetores podem conter dados de quaisquer tipos. Isto \u00e9, voc\u00ea pode declarar vetores de n\u00fameros reais ou inteiros, booleanos, e at\u00e9 tipos definidos por voc\u00ea, uma vez que aprenda como definir novos tipos. Um outro tipo interessante \u00e9 o caractere, ou simplesmente \\lstinline|char|. Por exemplo, vamos definir um programa que leia um vetor de 10 caracteres e depois os escreva de volta \u00e0 tela. \\begin{lstlisting} include using namespace std; define TAMANHO 10 int main() { char nome[TAMANHO]; cout << \"Digite \" << TAMANHO << \" caracteres: \"; for(int i = 0; i < TAMANHO; i++) { cin >> nome[i]; } cout << \"Os caracteres digitados foram: \"; for(int i = 0; i < TAMANHO; i++) { cout << nome[i]; } cout << endl; return 0; } \\end{lstlisting} Agora, s\u00f3 para tornar as coisas mais interessantes, alteremos o programa para que leia \\emph{at\u00e9} 100 caracteres, mas que pare de l\u00ea-los t\u00e3o logo um ``.'' seja digitado. Para representar um caractere em C(++), use aspas simples, isto \u00e9, \\lstinline|'.'|. \\begin{lstlisting} include using namespace std; define TAMANHO 100 int main() { char nome[TAMANHO]; int i = 0; cout << \"Digite ate \" << TAMANHO << \" caracteres. Para terminar antes, digite '.' \"; do { cin >> nome[i]; i++; }while( i < TAMANHO && nome[i-1] != '.'); cout << \"Os caracteres digitados foram: \" for(int i = 0; i < TAMANHO && nome[i] != '.'; i++) { cout << nome[i]; } cout << endl; return 0; } \\end{lstlisting} Caracteres s\u00e3o, na verdade, n\u00fameros disfar\u00e7ados e seguem uma codifica\u00e7\u00e3o espec\u00edfica. Uma pessoa pode decidir que o 'a' ser\u00e1 o 1, o 'b' ser\u00e1 o 2 e assim por diante. Mas como outra pessoa que receber a informa\u00e7\u00e3o saber\u00e1 disso? Para evitar este problema a representa\u00e7\u00e3o de caracteres como n\u00fameros foi padronizada. Os principais padr\u00f5es existentes s\u00e3o: ASCII, EBCDIC e Unicode. *{ASCII} ASCII, ou \\emph{American Standard Code for Information Interchange}, \u00e9 o padr\u00e3o mais utilizado, presente em todos os nossos computadores pessoais. Trata-se de uma codifica\u00e7\u00e3o de caracteres de oito bits baseada no alfabeto ingl\u00eas. A codifica\u00e7\u00e3o define 256 caracteres ( \\(2^8\\) ). Desses, 33 n\u00e3o s\u00e3o imprim\u00edveis, como caracteres de controle atualmente n\u00e3o utiliz\u00e1veis para edi\u00e7\u00e3o de texto, por\u00e9m amplamente utilizados em dispositivos de comunica\u00e7\u00e3o, que afetam o processamento do texto. Exceto pelo caractere de espa\u00e7o, o restante \u00e9 composto por caracteres imprim\u00edveis. A Figura~\\ref{fig:ascii} exibe a tabela ASCII. \\[\\begin{figure}[!ht] \\centering \\subfigure{ \\includegraphics[width=0.3\\textwidth]{imagens/ascii-1.png} } \\subfigure{ \\includegraphics[width=0.3\\textwidth]{imagens/ascii-2.png} } \\subfigure{ \\includegraphics[width=0.3\\textwidth]{imagens/ascii-3.png} } \\caption{Tabela ASCII} \\label{fig:ascii} \\end{figure}\\] A linguagem C prov\u00ea um atalho para que voc\u00ea n\u00e3o tenha que recorrer \u00e0 tabela ASCII sempre que precisar do valor de um caractere: para obter o valor de um caractere qualquer, basta coloc\u00e1-lo entre aspas simples. Isto \u00e9, para verificar se um caracter \\lstinline{c} \u00e9 uma letra mai\u00fascula, por exemplo, basta efetuar o teste \\lstinline{if(c >= 'A' && c <= 'Z')}. *{Outras representa\u00e7\u00f5es} As representa\u00e7\u00f5es EBCDIC (\\textit{Extended Binary Coded Decimal Interchange Code}) e Unicode tamb\u00e9m mapeiam os caracteres em n\u00fameros de 8 e 16 bits, respectivamente. EBCDIC \u00e9 utilizado principalmente em \\textit{mainframes} IBM. O padr\u00e3o Unicode foi criado para acomodar alfabetos com mais de 256 caracteres. {Exerc\u00edcios} \\[\\begin{exercicio} Escreva um programa que leia 10 caracteres e os imprima na ordem inversa \u00e0quela em que foram digitados. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva um programa que leia 10 caracteres e os imprima na ordem inversa \u00e0quela em que foram digitados, trocando mai\u00fasculas por min\u00fasculas e vice-versa. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva seu nome na codifica\u00e7\u00e3o ASCII. \\end{exercicio}\\] {Laborat\u00f3rio} \\[\\begin{lab} Escreva um programa que leia 100 caracteres ou at\u00e9 que \\lstinline|'#'| seja digitado e os imprima na ordem inversa \u00e0quela em que foram digitados. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia e imprima \\textit{strings} at\u00e9 que o usu\u00e1rio digite a palavra 'fim'. Considere que cada \\textit{string} n\u00e3o possui espa\u00e7os. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia e imprima \\textit{strings} at\u00e9 que o usu\u00e1rio digite a palavra 'fim'. As \\textit{strings} podem conter espa\u00e7os. \\end{lab}\\] \\begin{lab} Acompanhe as atividades a seguir: Execute o seguinte programa e observe o que ser\u00e1 impresso. Atente para as atribui\u00e7\u00f5es! \\begin{lstlisting} include using namespace std; int main() { int a; char c; for(a = 65; a < 91; a++) { c = a; cout << c << endl; } return 0; } \\end{lstlisting} Voc\u00ea deve ter observado que os n\u00fameros n\u00e3o foram impressos, e sim as letras de 'A' a 'Z'. Olhe a tabela na Figura \\ref{fig:ascii} e descubra o porqu\u00ea. \\end{lab} \\[\\begin{lab} Modifique o programa a seguir para imprimir as letras de 'a' a 'z', ou seja, as letras min\u00fasculas do alfabeto ingl\u00eas. \\end{lab}\\] \\[\\begin{lab} Agora fa\u00e7a um programa que leia caracteres informados pelo usu\u00e1rio enquanto ele n\u00e3o pressionar a tecla ESC. Para cada caractere informado pelo usu\u00e1rio, escreva o n\u00famero correspondente na tabela ASCII. \\end{lab}\\] \\[\\begin{lab} Modifique o programa anterior para que solicite que o usu\u00e1rio entre com letras min\u00fasculas de 'a' a 'z' e imprima na tela, para cada letra, a mai\u00fascula correspondente. \\end{lab}\\] {Vetores de Caracteres como \\textit{Strings}} Um vetor de caracteres \u00e9 essencialmente uma palavra ou uma frase. Assim, durante a leitura de um vetor de caracteres dificilmente sabe-se quantos caracteres ser\u00e3o digitados pelo usu\u00e1rio, por exemplo, quando deseja-se ler o nome de um indiv\u00edduo. Por este motivo, a maioria das linguagem de programa\u00e7\u00e3o fornece m\u00e9todos especiais de leitura, impress\u00e3o e manipula\u00e7\u00e3o desses vetores de caracteres, ou como chamaremos agora, \\textit{strings}. Na linguagem C++, os comandos \\lstinline|cout| e \\lstinline|cin| permitem imprimir e ler \\textit{strings} de maneira direta: \\begin{lstlisting} include using namespace std; define TAMANHO 100 int main() { char nome[TAMANHO]; cout << \"Digite ate \" << TAMANHO << \" caracteres. Para terminar pressione ENTER:\"; cin >> nome; cout << \"Os caracteres digitados foram: \" << nome << endl; return 0; } \\end{lstlisting} Entretanto, o comando \\lstinline|cin|, n\u00e3o permite, da forma como vimos at\u00e9 agora, a leitura de uma \\textit{string} que contenha espa\u00e7os (uma frase, por exemplo). Para que isso seja poss\u00edvel precisamos utilizar a fun\u00e7\u00e3o \\lstinline|cin.getline()|. Esta fun\u00e7\u00e3o necessita de dois argumentos: o vetor de caracteres representando a \\textit{string} e o tamanho m\u00e1ximo de caracteres que ser\u00e1 lido. A leitura \u00e9 realizada at\u00e9 que seja atingido ou n\u00famero m\u00e1ximo de caracteres ou o usu\u00e1rio pressione a tecla ENTER. A seguir uma modifica\u00e7\u00e3o do exemplo anterior: \\begin{lstlisting} include using namespace std; define TAMANHO 100 int main() { char nome[TAMANHO]; cout << \"Digite seu nome completo. Para terminar pressione ENTER:\"; cin.getline(nome, TAMANHO); cout << \"Seu nome eh: \" << nome << endl; return 0; } \\end{lstlisting} Por \u00faltimo, \u00e9 importante entender que para marcar no vetor de caracteres at\u00e9 onde foi feita a leitura a linguagem C adiciona o caractere especial \\lstinline{'\\0'} ap\u00f3s o \u00faltimo caractere digitado pelo usu\u00e1rio. Desta forma, quando se deseja percorrer uma string, diferentemente de um vetor n\u00famero, define-se como condi\u00e7\u00e3o de parada a posi\u00e7\u00e3o em que se encontra o \\lstinline{'\\0'} e n\u00e3o o fim do vetor. {Laborat\u00f3rio} \\[\\begin{lab} Fa\u00e7a um programa que leia uma string e calcule e imprima o tamanho desta string em uma fun\u00e7\u00e3o auxiliar. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia uma string e verifique se a string lida \u00e9 uma pal\u00edndrome. A verifica\u00e7\u00e3o deve ser feita em uma fun\u00e7\u00e3o auxiliar, que deve retornar \\lstinline{true} em caso afirmativo ou \\lstinline{false} caso contr\u00e1rio. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia uma string e a imprima de tr\u00e1s para frente, trocando as vogais pelo caractere '*'. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia duas strings e concatene a segunda na primeira, separadas por um espa\u00e7o em branco. A concatena\u00e7\u00e3o deve ser feita em uma fun\u00e7\u00e3o auxiliar. \\end{lab}\\] {Fun\u00e7\u00f5es para manipula\u00e7\u00e3o \\textit{Strings}} Quando trabalhamos com \\textit{strings} \u00e9 muito comum a realiza\u00e7\u00e3o de algumas tarefas como descobrir o tamanho da palavra digitada pelo usu\u00e1rio, comparar duas palavras para saber a ordem, ou ainda, concatenar duas palavras em uma \u00fanica. Para isso, a biblioteca \\texttt{string.h} fornece algumas fun\u00e7\u00f5es prontas, como pode ser visto na tabela \\ref{tab:string_func} \\begin{table}[!ht] \\centering \\begin{tabular}{l|l} Fun\u00e7\u00e3o & Descri\u00e7\u00e3o \\\\hline strlen & retorna o tamanho (em caracteres) da palavra passada como argumento.\\ strcpy & copia o conte\u00fado da segunda \\textit{string} para a primeira.\\ strcat & concatena o texto da segunda \\textit{string} na primeira.\\ strcmp & compara duas \\textit{strings} (vide exemplo a seguir).\\ stricmp & compara duas \\textit{strings} sem diferenciar mai\u00fasculas e min\u00fasculas.\\ atoi & converte uma \\textit{string} para o inteiro correspondente.\\ atof & converte uma \\textit{string} para o n\u00famero real correspondente.\\\\hline \\end{tabular} \\caption{Algumas fun\u00e7\u00f5es para trabalhar com \\textit{strings}.} \\label{tab:string_func} \\end{table} O exemplo a seguir mostra a utiliza\u00e7\u00e3o destas fun\u00e7\u00f5es: \\begin{lstlisting} #include #include using namespace std; int main() { char str1[50], str2[50]; int i; float f; cout << ``Entre primeiro nome:''; cin >> str1; cout << ``Entre ultimo nome:''; cin >> str2; strcat(str1, `` ''); //junto espaco com str1 strcat(str1, str2); cout << ``Seu nome completo eh '' << str1 << endl; cout << ``Ele possui '' << strlen(str1) << `` caracteres.'' << endl; cout << ``Entre outro nome:''. cin >> str2; //comparacao de strings if(strcmp(str1, str2) == 0) { cout << ``os dois nomes sao iguais.'' << endl; } else if(strcmp(str1, str2) < 0) { cout << str1 << `` vem antes de'' << str2 << endl; } else { cout << str2 << `` vem antes de '' << str1 << endl; } return 0; } \\end{lstlisting} No uso destas fun\u00e7\u00f5es, \u00e9 importante manter-se em mente que o espa\u00e7o adequado deve ser alocado para a string resultante das opera\u00e7\u00f5es. Por exemplo, ao se concatenar duas strings de no m\u00e1ximo 100 caracteres, o resultado ter\u00e1, no m\u00e1ximo, 200 caracteres. {Fun\u00e7\u00f5es com vetores como par\u00e2metros} As fun\u00e7\u00f5es descritas acima recebem strings como par\u00e2metros. Agora, veremos como definir suas fun\u00e7\u00f5es pr\u00f3prias fun\u00e7\u00f5es que recebem n\u00e3o somente strings, mas vetores de outros tipos de dados. A declara\u00e7\u00e3o de uma vari\u00e1vel do tipo vetor segue, como j\u00e1 visto, a seguinte forma. \\[\\begin{verbatim} tipo identificador[tamanho]; \\end{verbatim}\\] A declara\u00e7\u00e3o de par\u00e2metros segue uma sintaxe parecida, no qual o tamanho do vetor n\u00e3o aparece \\begin{verbatim} tipo identificador[] \\end{verbatim} Isto ocorre por que, para que a fun\u00e7\u00e3o seja gen\u00e9rica e opere em qualquer vetor passado, o par\u00e2metro n\u00e3o pode ser especificado em c\u00f3digo. Assim, a declara\u00e7\u00e3o de uma fun\u00e7\u00e3o que recebe um vetor como par\u00e2metro segue a seguinte receita: \\[\\begin{verbatim} tipo identificadorDaFuncao(tipo identificador1[], int tamanho1, ...) { Corpo da Funcao } \\end{verbatim}\\] Por exemplo, veja como definir uma fun\u00e7\u00e3o que transforme todos os caracteres de uma string para letras ma\u00edusculas. \\begin{lstlisting} #include #include using namespace std; void maiusculas(char str[], int tam) { for(int i = 0; i < tam && i < strlen(str); i++) if(str[i] >= 'a' && str[i] <= 'z') str[i] = str[i] - 'a' + 'A'; } int main() { char str[50]; cout << ``Digite seu primeiro nome:''; cin >> str; maiusculas(str, 50) cout << str << endl; return 0; } \\end{lstlisting} Observe que a fun\u00e7\u00e3o \\textbf{altera} a string passada como par\u00e2metro, um comportamento diferente do que aconteceu quando uma vari\u00e1vel que n\u00e3o \u00e9 um vetor \u00e9 passada. Este comportamento ser\u00e1 estudado mais a fundo em cap\u00edtulos posteriores. Da mesma forma que uma string, um vetor de outro tipo de dados pode ser passado como par\u00e2metro. A fun\u00e7\u00e3o a seguir, por exemplo, calcula qual o maior inteiro em um vetor de inteiros. \\begin{lstlisting} #include using namespace std; int maior(int v[], int tam) { int maior = -1; for(int i = 0; i < tam ; i++) if(v[i] > maior) maior = v[i]; return maior; } \\end{lstlisting} {Laborat\u00f3rio} \\begin{lab} Fa\u00e7a um programa que dado uma string, retorne 1 se ela for pal\u00edndromo e 0 se ela n\u00e3o for pal\u00edndromo. Lembrando que um pal\u00edndromo \u00e9 uma palavra que tenha a propriedade de poder ser lida tanto da direita para a esquerda como da esquerda para a direita. Deve-se obrigatoriamente utilizar uma \\texttt{string} auxiliar e a fun\u00e7\u00e3o \\texttt{strcmp} para fazer a resolu\u00e7\u00e3o. Ex: SUBI NO ONIBUS\\ ARARA \\ANOTARAM A DATA DA MARATONA \\end{lab} \\[\\begin{lab} Fa\u00e7a um programa que troque todas as ocorr\u00eancias de uma letra L1 pela letra L2 em uma \\textit{string}. A \\textit{string} e as letras L1 e L2 devem ser fornecidas pelo usu\u00e1rio. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia 3 \\textit{strings} e as imprima em ordem alfab\u00e9tica. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa com uma fun\u00e7\u00e3o que receba um vetor de inteiros e um inteiro X, e que retorne como resultado o maior inteiro do vetor que \u00e9 menor que o inteiro X. \\end{lab}\\] \\[\\begin{lab} Usando a resposta do problema anterior, fa\u00e7a um programa com uma fun\u00e7\u00e3o que receba dois vetores de inteiros, e que fa\u00e7a com que o segundo torne-se uma c\u00f3pia do primeiro, ordenado de forma decrescente. \\end{lab}\\] \\chapter{Bits, bytes e bases num\u00e9ricas} At\u00e9 agora temos trabalhado essencialmente com os tipos num\u00e9ricos, inteiros e reais, e booleanos. Para que possamos usar outros tipos, \u00e9 essencial que antes entendamos como os dados s\u00e3o representados na mem\u00f3ria do computador. {Bit \\& Byte} Como dito anteriormente, a mem\u00f3ria do computador pode ser entendida como uma grande planilha eletr\u00f4nica, podendo cada c\u00e9lula ser endere\u00e7ada (atribu\u00edda, lida, nomeada) individualmente. Na mem\u00f3ria do computador n\u00e3o existem n\u00fameros ou caracteres, mas v\u00e1rias ``lamp\u00e2das'' que podem estar ligadas ou desligadas. N\u00f3s humanos atribu\u00edmos significado a tais estados como sendo 0's e 1's. Cada posi\u00e7\u00e3o da mem\u00f3ria, que pode armazenar 0 ou 1, \u00e9 denominado um \\emph{bit}. Por serem m\u00ednimos, normalmente trabalhamos com conjuntos de 8 bits por vez, o que denominamos \\emph{bytes}. {Base Bin\u00e1ria} Os bits de um byte podem assumir todas as combina\u00e7\u00f5es de ligado e desligado (0 e 1). Dado um contexto, cada combina\u00e7\u00e3o corresponde a um certo valor. Por exemplo, se estiver usando um byte para representar n\u00fameros inteiros, ent\u00e3o provavelmente a correspond\u00eancia na Tabela~\\ref{tab:bindec} se aplica. \\[\\begin{table} \\caption{Exemplos de valores em bin\u00e1rio e decimal correspondente.} \\centering \\begin{tabular}{c|r} \\hline bits & N\u00famero\\\\ \\hline 00000000 & 0\\\\ 00000001 & 1\\\\ 00000010 & 2\\\\ 00000011 & 3\\\\ 00000100 & 4\\\\ 00000101 & 5\\\\ 00000110 & 6\\\\ 00000111 & 7\\\\ 00001000 & 8\\\\ 00001001 & 9\\\\ 00001010 & 10\\\\ \\ldots\\\\ 11111101 & 253\\\\ 11111110 & 254\\\\ 11111111 & 255\\\\ 00000000 & 0\\\\ \\ldots\\\\ \\end{tabular} \\label{tab:bindec} \\end{table}\\] Talvez isso seja novidade para voc\u00ea, mas voc\u00ea representa n\u00fameros na base decimal usando 10 d\u00edgitos (de 0 a 9). Contudo, outras bases existem. Como os bits s\u00f3 possuem dois estados, \u00e9 natural na computa\u00e7\u00e3o usar a base bin\u00e1ria, que usa 2 d\u00edgitos (0 e 1). Os valores \u00e0 esquerda na tabela podem ser entendidos como n\u00fameros nesta base.\\footnote{sempre que n\u00e3o for colocada a base, considera-se a base 10, mais natural aos seres de vida baseada em carbono do nosso planeta, A.K.A., voc\u00ea.} Para conseguir converter n\u00fameros de uma base para a outra, basta entender o que exatamente significa a representa\u00e7\u00e3o de um n\u00famero em uma base gen\u00e9rica X. Nesta base, \\(ABCD_X\\) significa \\(A*X^3 + B*X^2 + C*X^1 + D*X^0\\) . O n\u00famero \\(1234_{10}\\) , por exemplo, significa \\(1*X^3 + 2*X^2 + 3*X^1 + 4*X^0 = 1*1000 + 2 * 100 + 3*10 + 4*1\\) que \u00e9 igual a, t\u00e1 d\u00e1, \\(1234_{10}\\) . Para um exemplo mais interessante, o n\u00famero \\(10101010_2 = 1*2^7 + 0*2^6 + 1*2^5 + 0*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 128+0+32+8+2 = 170\\) . Observe que, pela tabela, o maior n\u00famero que se pode representar com 8 bits \u00e9 \\(11111111_2 = 255_{10}\\) . Via de regra, com X bits pode se representar \\(2^X\\) na base bin\u00e1ria, de 0 a \\(2^X-1\\) . {Base Hexadecimal} Embora se possa usar qualquer base num\u00e9rica, as que fazem mais sentido no mundo computacional s\u00e3o as bin\u00e1ria e hexadecimal. A base hexadecimal usa 16 d\u00edgitos em cada posi\u00e7\u00e3o representando valores de 0 a 15. Para isto, usa os valores de 0 a 9 iguais aos da base decimal e tamb\u00e9m as letras de A a F representado os valores de 10 a 15. Por exemplo, o n\u00famero 1A2F \\(_{16}\\) equivale a \\(1*16^3 + 10*16^2 + 2*16^1 + 15*16^0 = 4096 + 2560 + 32 + 15 = 6703\\) . {Convers\u00e3o entre bases num\u00e9ricas} Enquanto n\u00f3s trabalhamos com base decimal, o computador armazena informa\u00e7\u00e3o e realiza opera\u00e7\u00f5es na base bin\u00e1ria. Por isso, a todo momento ocorre a convers\u00e3o entre um decimal que informamos como entrada em um programa, por exemplo, para a base bin\u00e1ria (para efetuar o c\u00e1lculo), bem como da base bin\u00e1ria (resultado do c\u00e1lculo) para a base decimal exibida na tela. *{Convers\u00e3o de Bin\u00e1rio para Decimal} A convers\u00e3o de bin\u00e1rio (e qualquer outra base) para decimal pode ser feita facilmente usando a nota\u00e7\u00e3o da base gen\u00e9rica apresentada acima. Isto \u00e9, para realizar a convers\u00e3o basta multiplicar o valor de cada posi\u00e7\u00e3o pelo seu peso (base elevada \u00e0 posi\u00e7\u00e3o). Por exemplo, o n\u00famero \\(1111011_2\\) equivale a \\(1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 64 + 32 + 16 + 8 + 0 + 2 + 1 = 123_{10}\\) . *{Convers\u00e3o de Decimal para Bin\u00e1rio} A convers\u00e3o de decimal para bin\u00e1rio \u00e9 feita realizando-se divis\u00f5es sucessivas pela base de interesse (2, no nosso caso) at\u00e9 que o resultado seja zero. Os restos das divis\u00f5es, na ordem inversa, correspondem ao n\u00famero convertido. Por exemplo, considere a convers\u00e3o do n\u00famero 169 para a base bin\u00e1ria. O processo de convers\u00e3o \u00e9 o seguinte:\\ \\(169 / 2 = 84, Resto = 1\\) \\ \\(84 / 2 = 42, Resto = 0\\) \\ \\(42 / 2 = 21, Resto = 0\\) \\ \\(21 / 2 = 10, Resto = 1\\) \\ \\(10 / 2 = 5, Resto = 0\\) \\ \\(5 / 2 = 2, Resto = 1\\) \\ \\(2 / 2 = 1, Resto = 0\\) \\ \\(1 / 2 = 0, Resto = 1\\) \\ O n\u00famero bin\u00e1rio equivalente \u00e9, portanto, \\(10101001_2\\) . *{Convers\u00e3o entre Bin\u00e1rio e Hexadecimal} Sabendo-se que com 4 bits \u00e9 poss\u00edvel representar at\u00e9 16 n\u00fameros (de 0 a 15) e que a base hexadecimal tem exatamente 16 d\u00edgitos, conclu\u00edmos que \u00e9 poss\u00edvel representar cada d\u00edgito hexadecimal com 4 d\u00edgitos bin\u00e1rios. Sendo assim, a convers\u00e3o bin\u00e1rio/hexadecimal pode ser feita facilmente substituindo conjuntos de 4 bits bin\u00e1rios por um d\u00edgito hexadecimal e vice-versa. Por exemplo, para convertermos \\(11101010_2\\) convertemos \\(1110_2\\) para E \\(_{16}\\) e \\(1010_2\\) para A \\(_{16}\\) , obtendo o n\u00famero EA \\(_{16}\\) . Na dire\u00e7\u00e3o inversa, para convertermos o n\u00famero 7B \\(_{16}\\) para bin\u00e1rio convertemos 7 \\(_{16}\\) para \\(0111_2\\) e B \\(_{16}\\) para \\(1011_2\\) , obtendo o n\u00famero \\(01111011_2\\) . \\[\\begin{table} \\caption{Exemplos de valores em bin\u00e1rio, decimal e hexadecimal correspondentes.} \\centering \\begin{tabular}{c|r|r} \\hline Bin\u00e1rio & Decimal & Hexadecimal\\\\ \\hline 00000000 & 0 & 0\\\\ 00000001 & 1 & 1\\\\ 00000010 & 2 & 2\\\\ 00000011 & 3 & 3\\\\ 00000100 & 4 & 4\\\\ 00000101 & 5 & 5\\\\ 00000110 & 6 & 6\\\\ 00000111 & 7 & 7\\\\ 00001000 & 8 & 8\\\\ 00001001 & 9 & 9\\\\ 00001010 & 10 & A\\\\ 00001011 & 11 & B\\\\ 00001100 & 12 & C\\\\ 00001101 & 13 & D\\\\ 00001110 & 14 & E\\\\ 00001111 & 15 & F\\\\ 00010000 & 16 & 10\\\\ \\ldots\\\\ 11111101 & 253 & FD\\\\ 11111110 & 254 & FE\\\\ 11111111 & 255 & FF\\\\ 00000000 & 0 & 0\\\\ \\ldots\\\\ \\end{tabular} \\label{tab:bindechex} \\end{table}\\] {Tipos Num\u00e9ricos Inteiros} Na linguagem C, os principais tipos, a quantidade de bits utilizada para sua representa\u00e7\u00e3o e o intervalo de valores aceitos s\u00e3o resumidos na tabela a seguir: \\footnote{A quantidade de bits pode variar de acordo com o compilador e a arquitetura do sistema} \\[\\begin{table}[h!] \\caption{Intervalo de representa\u00e7\u00e3o dos tipos num\u00e9ricos inteiros.} \\centering \\begin{tabular}{l|c|c} \\hline Tipo & Quantidade de Bits & Intervalo\\\\ \\hline char & 8 & -128 a 127\\\\ unsigned char & 8 & 0 a 255\\\\ int & 16 & -32.768 a 32.767\\\\ unsigned int & 16 & 0 a 65.535\\\\ long & 32 & -2.147.483.648 a 2.147.483.647\\\\ unsignet long & 32 & 0 a 4.294.967.295\\\\ \\end{tabular} \\end{table}\\] Observe que o tipo caractere tamb\u00e9m \u00e9 armazenado internamente como um n\u00famero inteiro de 8 bits. Com 8 bits podemos representar \\(2^8\\) n\u00fameros. Se considerarmos n\u00fameros sem sinal (\\textit{unsigned}) teremos de 0 a 255; se considerarmos n\u00fameros com sinal, teremos metade para positivos e metade para negativos, ou seja, de -128 a 127. O mesmo racioc\u00ednio se aplica para os outros tipos de dados da tabela. A partir desta tabela podemos observar a import\u00e2ncia da escolha adequada do tipo correto de acordo com sua aplica\u00e7\u00e3o. Se utilizarmos um inteiro para somarmos 20.000 e 50.000, por exemplo, o resultado ser\u00e1 inesperado, uma vez que o maior valor que um inteiro aceita \u00e9 32.767. Quando isto ocorre, dizemos que houve um \\textit{overflow}. {N\u00fameros Bin\u00e1rios Negativos} Os exemplos que vimos at\u00e9 agora de convers\u00e3o n\u00e3o contemplam n\u00fameros negativos. Na base decimal, o sinal de menos (-) antes do valor do n\u00famero tem a finalidade de representar n\u00fameros negativos. Como a mem\u00f3ria do computador armazena apenas 0's e 1's, uma poss\u00edvel estrat\u00e9gia \u00e9 ``desperdi\u00e7ar'' um dos bits do n\u00famero para o sinal. Adota-se, por padr\u00e3o, o zero para representar um n\u00famero positivo e o um para negativo. O bit do sinal \u00e9 armazenado na posi\u00e7\u00e3o mais \u00e0 esquerda. Para representar o valor de um n\u00famero negativo h\u00e1 duas principais abordagens: \\textbf{sinal-magnitude} e \\textbf{complemento de 2}. Na representa\u00e7\u00e3o \\textbf{sinal-magnitude}, o n\u00famero negativo tem seu valor absoluto (magnitude) representado da mesma forma que um n\u00famero positivo e o bit mais significativo, que representa o sinal, ser\u00e1 igual a um. A tabela a seguir mostra alguns exemplos de n\u00fameros na base decimal e na representa\u00e7\u00e3o sinal-magnitude. \\[\\begin{table}[!ht] \\caption{Exemplos de valores na representa\u00e7\u00e3o sinal-magnitude.} \\centering \\begin{tabular}{c|c} \\hline Decimal & Bin\u00e1rio Sinal-Magnitude\\\\ \\hline +20 & \\textbf{0}0010100\\\\ -20 & \\textbf{1}0010100\\\\ +115 & \\textbf{0}1110011\\\\ -115 & \\textbf{1}1110011\\\\ \\end{tabular} \\end{table}\\] Com 8 bits, temos, ent\u00e3o n\u00fameros de \\(11111111_2\\) a \\(01111111_2\\) (-127 a +127). Um problema que aparece com esta representa\u00e7\u00e3o \u00e9 o zero. Qual a representa\u00e7\u00e3o correta, \\(00000000\\) ou \\(10000000\\) ? E por que precisar\u00edamos de duas representa\u00e7\u00f5es? A representa\u00e7\u00e3o \\textbf{complemento de 2} utiliza uma maneira um pouco diferente de representar n\u00fameros negativos. Para express\u00e1-los devemos inverter cada bit do n\u00famero positivo e somar 1 ao resultado. Por exemplo, o n\u00famero -15 \u00e9 representado em complemento de 2 com 5 bits como 10001, ou seja, calcula-se o valor de +15 = \\(01111_2\\) , e, em seguida invertemos e somamos 1: \\(10000_2 + 1_2 = 10001_2\\) . Se a representa\u00e7\u00e3o usar 8 bits, ent\u00e3o \\(15_{10} = 00001111_{2}\\) e \\(-15_{10} = 11110001_{2}\\) . {Aritm\u00e9tica Inteira Bin\u00e1ria} Aritm\u00e9tica bin\u00e1ria \u00e9 t\u00e3o simples como \\(1 + 1 = 10\\) . S\u00e9rio, \u00e9 assim que se faz: \\(0 + 0 = 0, 0+1 = 1+0 = 1, 1 + 1 = 10_2\\) . Logo, em sistemas computacionais as somas e subtra\u00e7\u00f5es geralmente s\u00e3o realizadas aos pares, da mesma forma que na base bin\u00e1ria. {N\u00fameros positivos} A \\textbf{adi\u00e7\u00e3o} de n\u00fameros positivos \u00e9 muito simples. Para faz\u00ea-la, basta somar os valores na mesma posi\u00e7\u00e3o, do menos significativo para o mais significativo. O ``vai-um'' funciona da mesma forma como fazemos na base decimal. Por exemplo, para somarmos 5 e 9, fazemos: \\begin{verbatim} 1 0101 + 1001 1110 \\end{verbatim} Como a quantidade de bits para determinado tipo de dados \u00e9 limitado, durante uma soma pode ocorrer de o resultado ultrapassar o maior valor permitido para aquela quantidade de bits, quando isto ocorre, temos um \\emph{overflow} (derramamento). Considere a soma de 7 e 9, ambos com 4 bits. \\begin{verbatim} 1 111 0111 + 1001 1 0000 \u2190 overflow! \\end{verbatim} Houve um ``vai-um'' al\u00e9m do bit mais significativo, caracterizando um \\textit{overflow}. Neste caso, o resultado da opera\u00e7\u00e3o est\u00e1 errado. {N\u00fameros em Complemento de 2} Como vimos anteriormente, o computador usa duas principais representa\u00e7\u00f5es para n\u00fameros negativos. A representa\u00e7\u00e3o complemento de 2 \u00e9 a mais utilizada porque permite que a soma de n\u00fameros negativos seja feita da mesma maneira que a soma de n\u00fameros positivos. Por exemplo considere as soma de -2 + 5 e -1+(-1), em complemento de 2: \\begin{verbatim} 1 1 (-2) 1110 + (+5) 0101 ---- 1 0011 \u2190 N\u00e3o \u00e9 overflow! Esse \"vai-um\" deve ser desprezado! 1 111 (-1) 1111 + (-1) 1111 ---- 1 1110 \u2190 N\u00e3o \u00e9 overflow! Esse \"vai-um\" deve ser desprezado! \\end{verbatim} Observe que nestes exemplos tivemos um vai-um'' al\u00e9m do bit mais significativo. Em soma de n\u00fameros em complemento de 2 isto n\u00e3o \u00e9 suficiente para caracterizar um \\textit{overflow}. Um \\emph{overflow} apenas ocorrer\u00e1 quando, ao somarmos dois n\u00fameros de mesmo sinal, obtivermos um n\u00famero de sinal diferente. Desta maneira, no exemplo apresentado, este vai-um'' a mais deve simplesmente ser ignorado. J\u00e1 os exemplos a seguir mostram opera\u00e7\u00f5es problem\u00e1ticas. \\begin{verbatim} 111 (+7) 0111 + (+7) 0111 ---- 1110 \u2190 O resultado come\u00e7a com 1, logo \u00e9 negativo. Absurdo! 1 (-3) 1101 + (-6) 1010 ---- 1 0111 \u2190 O resultado come\u00e7a com 0, logo \u00e9 positivo. Absurdo! \\end{verbatim} {E a subtra\u00e7\u00e3o?} Na verdade, a maioria dos computadores n\u00e3o sabe fazer subtra\u00e7\u00e3o. O que eles fazem \u00e9 utilizar um truque para transformar uma subtra\u00e7\u00e3o em uma soma. Por exemplo, a opera\u00e7\u00e3o \\(7 - 5\\) pode ser reescrita como \\(7 + (-5)\\) , ou seja, para realizar a subtra\u00e7\u00e3o basta inverter o segundo n\u00famero (em complemento de 2) e som\u00e1-lo ao primeiro da maneira usual. {Tipos Num\u00e9ricos Reais} Para representarmos n\u00fameros reais no computador, definimos que uma quantidade de bits do n\u00famero ser\u00e1 usada para representar a mantissa e o restante o expoente do n\u00famero. Por exemplo, se dispusermos de 8 bits, podemos definir que os quatro primeiros bits ser\u00e3o a mantissa e os quatro \u00faltimos ser\u00e3o o expoente, em nota\u00e7\u00e3o cient\u00edfica. Assim, \\(10101010_2 = 1,0*10^{11}\\) e \\(10111010_2 = 1,1*10^{11}\\) . Antes que voc\u00ea saia dizendo por a\u00ed que o ideal \u00e9 usar tais n\u00fameros pois podemos representar n\u00fameros t\u00e3o grandes como \\(11111111_2 = 15*10^{15}\\) , que \u00e9 muito mais que os \\(2^{16}-1\\) da nota\u00e7\u00e3o bin\u00e1ria convencional, pense em como representaria o n\u00famero 161 \\(_{10}\\) , j\u00e1 que a maior mantissa represent\u00e1vel \u00e9 1,5. Al\u00e9m disso, como representar 1,1111, j\u00e1 que s\u00f3 dispomos de 4 d\u00edgitos na mantissa? Al\u00e9m disso, se representa\u00e7\u00f5es de n\u00fameros reais pecam em sua precis\u00e3o, tamb\u00e9m pecam na velocidade de processamento. A aritm\u00e9tica de n\u00fameros bin\u00e1rios \u00e9 muito mais simples que a de n\u00fameros reais (ou de ponto flutuante, como costumamos dizer na computa\u00e7\u00e3o). Para manipular n\u00fameros reais, computadores normalmente precisam de componentes dedicados a este fim e que tem alto tempo de execu\u00e7\u00e3o. Para saber mais sobre representa\u00e7\u00f5es de n\u00fameros em pontos flutuantes visite a URL \\url{ http://en.wikipedia.org/wiki/Floating_point } {Exerc\u00edcios e laborat\u00f3rio} {} Quantos n\u00fameros se pode representar, na base bin\u00e1ria, com 1, 8, 16, 32 e 64 bits? {} Escreva os seguintes n\u00fameros nas bases bin\u00e1ria e hexadecimal: \\begin{enumerate} \\item 16 \\item 45 \\item 129 \\item 23 \\item 1290 \\end{enumerate} {} Converta os n\u00fameros a seguir para a base decimal: \\begin{enumerate} \\item \\(16_{16}\\) \\item D5 \\(_{16}\\) \\item \\(1100101101_2\\) \\item 2C04 \\(_{16}\\) \\item \\(11101_2\\) \\end{enumerate} {} Escreva os n\u00fameros a seguir nas representa\u00e7\u00f5es sinal-magnitude e complemento de 2 com 8 bits: \\begin{enumerate} \\item -19 \\item +47 \\item -29 \\item -37 \\item -105 \\end{enumerate} {} Realize as seguintes opera\u00e7\u00f5es aritm\u00e9ticas em complemento de 2 com n\u00fameros de 8 bits: \\begin{enumerate} \\item 16 - 9 \\item -45 - 7 \\item -12 + 12 \\end{enumerate} {} \\[\\begin{lab} Fa\u00e7a um programa para descobrir quantos bits tem uma vari\u00e1vel do tipo \\lstinline{int}? E um \\lstinline{unsigned int}? \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia um n\u00famero de 2 d\u00edgitos na base decimal e imprima o mesmo n\u00famero na base bin\u00e1ria. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia um n\u00famero bin\u00e1rio de at\u00e9 10 bits e imprima o mesmo n\u00famero na base decimal. \\end{lab}\\] %\\chapter{Strings e Fun\u00e7\u00f5es} %Neste cap\u00edtulo veremos algumas fun\u00e7\u00f5es muito usadas na manipula\u00e7\u00e3o de (\\textit{strings}) assim como definir suas pr\u00f3prias fun\u00e7\u00f5es que recebem vetores como %par\u00e2metros. \\chapter{Fun\u00e7\u00f5es \u00dateis I} {Fun\u00e7\u00f5es Matem\u00e1ticas} A biblioteca \\texttt{math.h} fornece algumas fun\u00e7\u00f5es aritm\u00e9ticas muito \u00fateis no desenvolvimento de programas. A Tabela~\\ref{tab:math_func} apresenta algumas destas fun\u00e7\u00f5es. \\[\\begin{table}[!ht] \\centering \\begin{tabular}{l|l} Fun\u00e7\u00e3o & Descri\u00e7\u00e3o/Exemplo \\\\\\hline abs & valor absoluto do argumento. Ex: \\verb|int x = abs(-9);| \\\\ sin & seno do argumento (em radianos). Ex: \\verb|double x = sin(3.14159);|\\\\ cos & cosseno do argumento (em radianos). Ex: \\verb|double x = cos(3.14159);|\\\\ tan & tangente do argumento (em radianos). Ex: \\verb|double x = tan(3.14159);|\\\\ asin& arco cujo seno \u00e9 passado como argumento. Ex: \\verb|double x = asin(1);|\\\\ acos& arco cujo cosseno \u00e9 passado como argumento. Ex: \\verb|double x = acos(1);|\\\\ atan& arco cuja tangente \u00e9 passada como argumento. Ex: \\verb|double x = atan(sqrt(2)/2);|\\\\ floor& piso do valor passado como argumento. Ex: \\verb|double x = floor(3.2); //=3|\\\\ ceil& teto do valor passado como argumento. Ex: \\verb|double x = floor(3.2); //=4|\\\\ round& arredonda o argumento para o inteiro mais pr\u00f3ximo. Ex: \\verb|double x = round(9.9); //=10|\\\\ pow& eleva o primeiro argumento ao expoente no segundo. Ex: \\verb|double x = pow(2,3); //=8|\\\\ sqrt& retorna a raiz quadrada do argumento. Ex: \\verb|double x = sqrt(169); //=13|\\\\ log& retorna logaritmo natural do argumento.\\\\ log10& retorna log. do argumento na base 10.\\\\ log2& retornar log do argumento na base 2\\\\\\hline \\end{tabular} \\caption{Algumas fun\u00e7\u00f5es aritm\u00e9ticas.} \\label{tab:math_func} \\end{table}\\] Al\u00e9m das fun\u00e7\u00f5es em \\lstinline{math.h}, duas outras fun\u00e7\u00f5es, da biblioteca \\lstinline{stdlib.h}, s\u00e3o particularmente interessantes na manipula\u00e7\u00e3o de n\u00fameros. Estas fun\u00e7\u00f5es s\u00e3o apresentadas na Tabela~\\ref{tab:rand_func}. \\[\\begin{table}[!ht] \\centering \\begin{tabular}{l|l} Fun\u00e7\u00e3o & Descri\u00e7\u00e3o/Exemplo \\\\\\hline rand & retorna um n\u00famero aleat\u00f3rio (biblioteca \\texttt{stdlib.h})\\\\ srand& define a semente para a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios por \\texttt{rand} (biblioteca \\texttt{stdlib.h})\\\\\\hline \\end{tabular} \\caption{Fun\u00e7\u00f5es para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios.} \\label{tab:rand_func} \\end{table}\\] A fun\u00e7\u00e3o \\lstinline{rand()} \u00e9 utiliza para gerar n\u00fameros aleat\u00f3rios. Um n\u00famero aleat\u00f3rio \u00e9 gerado internamente pelo computador aplicando-se opera\u00e7\u00f5es aritm\u00e9ticas que o usu\u00e1rio desconhece a partir de um valor inicial chamado de \\emph{semente}. O valor dessa semente \u00e9 definido com a fun\u00e7\u00e3o \\lstinline{srand()}. O exemplo a seguir imprime na tela 30 n\u00fameros ``aleat\u00f3rios''. \\newpage \\begin{lstlisting} include include . . . int main() { for (int i = 0; i < 10; i++) { cout << rand() << endl; } for (int i = 0; i < 10; i++) { cout << rand() << endl; } //Configuracao da semente //com valor que depende da hora atual. //Isto garante maior 'aleatoriedade' srand(time(NULL)); for (int i = 0; i < 10; i++) { cout << rand() << endl; } return 0; } \\end{lstlisting} O codigo a seguir \u00e9 para um jogo de adivinha\u00e7\u00e3o. O programa gera um n\u00famero aleat\u00f3rio entre 1 e 10, e o usu\u00e1rio deve descobrir qual \u00e9 este n\u00famero\\footnote{\\url{ http://www.cplusplus.com/reference/clibrary/cstdlib/rand/ }}. \\begin{lstlisting} /* rand example: guess the number */ include include include using namespace std; int main () { int iSecret, iGuess; /* initialize random seed: */ srand ( time(NULL) ); /* generate secret number: */ iSecret = rand() % 10 + 1; do { printf (\"Guess the number (1 to 10): \"); cin >> iGuess; if (iSecret iGuess) puts (\"The secret number is higher\"); } while (iSecret!=iGuess); puts (\"Congratulations!\"); return 0; } \\end{lstlisting} {Laborat\u00f3rio} \\[\\begin{lab} Fa\u00e7a um programa que leia os catetos de um tri\u00e2ngulo e imprima o valor de sua hipotenusa. Utiliza as fun\u00e7\u00f5es aritm\u00e9ticas. \\end{lab}\\] \\begin{lab} O valor de \\(\\pi\\) pode ser dado pela s\u00e9rie: \\(\\pi = \\sum_{n=0}^{\\infty} (-1)^n\\frac{4}{2n+1}\\) Fa\u00e7a uma fun\u00e7\u00e3o chamada \\texttt{pi} que recebe o valor de \\texttt{n} e retorna o valor calculado de acordo com a fun\u00e7\u00e3o informada. A fun\u00e7\u00e3o principal deve ler o valor de \\texttt{n}, invocar a fun\u00e7\u00e3o \\texttt{pi} e imprimir o resultado. \\end{lab} \\[\\begin{lab} Fa\u00e7a um programa que leia dois n\u00fameros $x$ e $y$ e calcule $log_y x$. O c\u00e1lculo deve ser feito em uma fun\u00e7\u00e3o auxiliar. \\end{lab}\\] \\begin{lab} Fa\u00e7a uma fun\u00e7\u00e3o que receba como par\u00e2metro o valor de um \u00e2ngulo em graus e o n\u00famero de itera\u00e7\u00f5es (n) e calcule o valor do cosseno hiperb\u00f3lico desse \u00e2ngulo usando sua respectiva s\u00e9rie de Taylor: \\(cosh(x) = \\sum_{n=1}^{\\infty} \\frac{x^{2n}}{(2n)!}\\) , onde x \u00e9 o valor do \u00e2ngulo em \\emph{radianos}. Considerar pi = 3.141593. \\end{lab} \\chapter{Arranjos Multidimensionais} Embora os arranjos unidimensionais sejam \u00fateis em v\u00e1rias situa\u00e7\u00f5es, eles n\u00e3o s\u00e3o suficientes para resolver todos os problemas relacionados a arranjos. Em certas situa\u00e7\u00f5es, v\u00e1rias dimens\u00f5es precisam ser representadas. Um exemplo simples \u00e9 o problema de multiplica\u00e7\u00e3o de matrizes.\\footnote{A bem da verdade, \u00e9 poss\u00edvel representar qualquer matriz finita como um arranjo unidimensional, mas a complexidade \u00e9 muito maior em rela\u00e7\u00e3o ao uso de arranjos multidimensionais.} {Declara\u00e7\u00e3o e Inicia\u00e7\u00e3o} Como j\u00e1 visto, a declara\u00e7\u00e3o de arranjos tem a seguinte sintaxe, \\begin{verbatim} tipo identificador[tamanho]; \\end{verbatim} A declara\u00e7\u00e3o de uma vari\u00e1vel do tipo matriz tem uma forma semelhante, apenas aumentando uma segunda dimens\u00e3o ao arranjo, como a seguir. \\begin{verbatim} tipo identificador[tamanho1][tamanho2]; \\end{verbatim} Assim, uma declara\u00e7\u00e3o como \\begin{lstlisting} int matriz[10][20]; \\end{lstlisting} declara uma matriz de 10 linhas por 10 colunas, cujas c\u00e9lulas s\u00e3o n\u00fameros inteiros. A matriz pode ser iniciada como em arranjos unidimensionais, colocando-se os valores do elemento dentro de chaves ap\u00f3s a declara\u00e7\u00e3o da matriz. Os valores para cada linha devem ficar dentro de chaves pr\u00f3prias e s\u00e3o separados por v\u00edrgula: \\[\\begin{lstlisting} {int matriz[2][3] = {{1, 2, 3}, {4, 5, 6}}; \\end{lstlisting}\\] A matriz criada pode ser visualizada da seguinte maneira: \\begin{center} \\begin{tabular}{|ccc|} 1 & 2 & 3\\ 4 & 5 & 6 \\end{tabular} \\end{center} {Acesso aos elementos} O acesso \u00e0s c\u00e9lulas \u00e9 feito tamb\u00e9m como em arranjos unidimensionais, exceto que ambas as coordenadas devem ser especificadas. O exemplo a seguir mostra a cria\u00e7\u00e3o, inicia\u00e7\u00e3o, e impress\u00e3o dos elementos de uma matriz bidimensional. \\begin{lstlisting} include define M 5 define N 10 using namespace std; int main() { int m[M][N]; cout << \"Digite o valor dos elementos de uma matriz \" << M << \" por \" << N; for(int i = 0; i < M; i++) for(int j = 0; j < N; j++) { cout << i << \",\" << j; cin >> m[i][j]; } cout << \"A matriz lida foi a seguinte \"<< endl; for(int i = 0; i < M; i++) { for(int j = 0; j < N; j++) { cout << m[i][j] << \" \"; } cout << endl; } } \\end{lstlisting} Observe que tanto na leitura como impress\u00e3o da matriz, o la\u00e7o mais externo percorre as linhas. Para cada valor da vari\u00e1vel \\lstinline!i!, a vari\u00e1vel \\lstinline|j|, dentro do la\u00e7o interno percorre os valores de 0 a \\(N-1\\) . Desta maneira, a matriz \u00e9 lida e impressa linha a linha. Observe a impress\u00e3o. Para que serve o comando \\lstinline|cout<<endl;|? {Mais Dimens\u00f5es} Agora voc\u00ea j\u00e1 deve ter deduzido que para adicionar mais dimens\u00f5es aos seus arranjos, basta colocar esta dimens\u00e3o na declara\u00e7\u00e3o dos mesmos. Por exemplo, o seguinte trecho de c\u00f3digo declara um arranjo com tr\u00eas dimens\u00f5es, em que cada c\u00e9lula \u00e9 um inteiro. \\begin{lstlisting} char matriz[100][100][100]; \\end{lstlisting} Outra forma de ver tal arranjo \u00e9 como um livro com v\u00e1rias ``p\u00e1ginas'', em que cada uma \u00e9 uma matriz bidimensional. {Multiplica\u00e7\u00e3o de Matrizes} Agora que voc\u00ea viu alguns exemplos de declara\u00e7\u00f5es de arranjos multidimensionais, vejamos alguns usos reais, como a j\u00e1 mencionada multiplica\u00e7\u00e3o de matrizes. Sejam duas matrizes \\(A\\) e \\(B\\) , tal que \\(A\\) tem dimens\u00f5es \\(m \\times n\\) e \\(B, n \\times o\\) ; ent\u00e3o, a matriz \\(AB\\) tem dimens\u00f5es \\(m\\times o\\) , e \\(C_i,j = \\sum_{k = 1}^{m}A_{m,n}B_{n,o}\\) . Observe que na matem\u00e1tica os \u00edndices come\u00e7am, normalmente, em 1. Na computa\u00e7\u00e3o, contudo, os arranjos tem seu menor \u00edndice igual a zero. Logo, o c\u00f3digo para multiplicar as duas matrizes fica assim. \\begin{lstlisting} int main() { int soma = 0, m, n, o; int a[100][100], b[100][100], ab[100][100]; //m,n e 0 precisam ser menores que 100. //ler as dimensoes cout << \"Quais as dimensoes das matrizes?\"; cin >> m >> n >> o; for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) cin >> a[i][j]; for(int j = 0; j < m; j++) for(int k = 0; k < n; k++) cin >> a[j][k]; for(int i = 0 ; i < m ; i++ ) { for(int j = 0 ; j < o ; j++ ) { for(int k = 0 ; k < n ; k++ ) { sum = sum + a[i][k] * b[k][j]; } ab[i][j] = sum; sum = 0; } } } \\end{lstlisting} Observe que fizemos nosso c\u00f3digo de manipula\u00e7\u00e3o da matriz dentro da fun\u00e7\u00e3o \\lstinline!main!. Fizemos isso por que usar matrizes como par\u00e2metro \u00e9 bem mais complicado do que vetores unidimensionais. Contudo, n\u00e3o se aflija, pois veremos isso logo a seguir. {Passagem de matriz como par\u00e2metro em fun\u00e7\u00f5es} Vimos que, ao passar vetores para uma fun\u00e7\u00e3o, n\u00e3o era necess\u00e1rio especificar o n\u00famero de elementos no vetor. Em matrizes bidimensionais, n\u00e3o \u00e9 necess\u00e1rio especificar o n\u00famero de linhas na matriz, apenas o n\u00famero de colunas. O programa a seguir usa a fun\u00e7\u00e3o \\lstinline|exibeMatriz| para exibir o conte\u00fado de matrizes bidimensionais: \\begin{lstlisting} include define ncol 10 using namespace std; void exibeMatriz(int matriz[][ncol], int linhas) { int i, j; for (i = 0; i < linhas; i++) { for (j = 0; j < 10; j++) { cout << matriz[i][j] << ``\\t''; } cout << endl; } } int main() { int a[1][10] = {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}}; int b[2][10] = {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19,20}}; int c[3][10] = {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19, 20}, {21, 22, 23, 24, 25, 26, 27, 28, 29, 30}}; exibeMatriz(a, 1); exibeMatriz(b, 2); exibeMatriz(c, 3); return 0; } \\end{lstlisting} Via de regra, n\u00e3o \u00e9 necess\u00e1rio especificar a primeira dimens\u00e3o da matriz. Isto \u00e9, em vetores, voc\u00ea n\u00e3o passava qualquer dimens\u00e3o. Em matrizes bidimensionais, n\u00e3o precisa especificar a quantidade de linhas. Em uma matriz tridimensional, n\u00e3o precisaria especificar a quantidade de ``p\u00e1ginas'', e assim por diante. Lembre-se, semelhante ao que acontece com vetores, matrizes alteradas em fun\u00e7\u00f5es auxiliares implicam em altera\u00e7\u00e3o na matriz original. {Matrizes de Caracteres} Da mesma forma que vetores de caracteres podem ser manipuladas de forma especial no C(++), tamb\u00e9m podem as matrizes de caractere. Na verdade, se um vetor de caracteres \u00e9 o que chama-se de uma string, ent\u00e3o uma matriz bidimensional de caracteres \u00e9, na verdade, um vetor de strings. Por exemplo, \\begin{lstlisting} char nomes[10][20]; \\end{lstlisting} pode ser visto como um vetor de 10 strings, cada uma com 20 caracteres, e cada string pode ser manipulada como tal, como no exemplo a seguir. \\begin{lstlisting} include define M 10 define N 11 using namespace std; int main() { char m[M][N]; cout << \"Digite \" << M << \" palavras de no maximo \" << N-1 << \" caracteres\" << endl; for(int i = 0; i < M; i++) { cout << i << \": \"; cin >> m[i]; } cout << \"As palavras lidas foram as seguintes \"<< endl; for(int i = 0; i < M; i++) { cout << m[i] << \" (com tamanho = \" << strlen(m[i]) << \")\" << endl; } } \\end{lstlisting} {Exercicios} \\[\\begin{lab} Escreva um programa com uma fun\u00e7\u00e3o que receba como par\u00e2metro uma matriz bidimensional e suas dimens\u00f5es, e que incremente cada elemento da matriz em 10\\%. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia e \\href{http://pt.wikipedia.org/wiki/Adi\u00e7\u00e3o_de_matrizes}{some} duas matrizes, imprimindo o resultado. Utilize fun\u00e7\u00f5es auxiliares para leitura, impress\u00e3o e soma. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia uma matriz e diga se ela \u00e9 a matriz \\href{http://pt.wikipedia.org/wiki/Matriz_identidade}{identidade} ou n\u00e3o. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia uma matriz e imprima sua \\href{http://pt.wikipedia.org/wiki/Matriz_transposta}{transposta}. \\end{lab}\\] \\iffalse \\chapter{Arranjos Multidimensionais (II)} {Introdu\u00e7\u00e3o} Como voc\u00ea j\u00e1 percebeu, arranjos multidimensionais s\u00e3o muito divertidos. Neste cap\u00edtulo, veremos alguns t\u00f3picos mais avan\u00e7ados em seu uso. {Matrizes Bidimensionais Como Unidimensionais e Vice-Versa} Uma matriz bidimensional pode ser utilizada sem precisar acessar os elementos em suas posi\u00e7\u00f5es de linha ou coluna. Ela pode ser tratada como se tivesse uma \u00fanica dimens\u00e3o. O programa a seguir calcula a soma dos valores em uma matriz bidimensional, inicialmente utilizando as duas dimens\u00f5es e em seguida da mesma forma que com vetores. \\begin{lstlisting} include define ncol 10 using namespace std; int somaMatrizBi(int matriz[][ncol], int linhas) { int soma = 0; for (int i = 0; i < linhas; i++) for (int j = 0; j < ncol; j++) soma += matriz[i][j]; return soma; } int somaMatrizUni(int matriz[], int elementos) { int soma = 0; int i; for (i = 0; i < elementos; i++) soma += matriz[i]; return soma; } int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[2][10]={{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19,20}}; int c[3][10]={{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19, 20}, {21, 22, 23, 24, 25, 26, 27, 28, 29,30}}; cout << \"Soma dos elementos da primeira matriz: \" << somaMatrizUni(a, 10); cout << \"Soma dos elementos da primeira matriz de novo: \" << somaMatrizBi(a, 1); cout << \"Soma dos elementos da segunda matriz: \" << somaMatrizUni(b, 20); cout << \"Soma dos elementos da segunda matriz de novo: \" << somaMatrizBi(b, 2); cout << \"Soma dos elementos da terceira matriz: \" << somaMatrizUni(c, 30); cout << \"Soma dos elementos da terceira matriz de novo: \" << somaMatrizBi(c, 3); return 0; } \\end{lstlisting} Observe que a fun\u00e7\u00e3o \\lstinline!somaMatrizUni! recebe como argumento o total de elementos e percorre a matriz da mesma forma que um vetor. Isto pode ser feito porque na mem\u00f3ria do computador a matriz \u00e9 armazenada como um vetor de \\lstinline|nlinha| \\(\\times\\) \\lstinline|ncolunas| elementos. A fun\u00e7\u00e3o \\lstinline|somaMatrizBi| recebe o n\u00famero de linhas e faz a mesma soma utilizando as duas dimens\u00f5es. Uma vez que a matriz multidimensional pode ser acessada como unidimensional, voc\u00ea pode criar fun\u00e7\u00f5es que recebam uma matriz unidimensional e passar, como par\u00e2metro, todas as suas dimens\u00f5es. Internamente a esta fun\u00e7\u00e3o, a matriz pode ser percorrida usando-se as dimens\u00f5es e um pouco de aritm\u00e9tica b\u00e1sica. \\begin{lstlisting} include using namespace std; int somaMatrizBiDisfarcadaDeUni(int matriz[], int linhas, int colunas) { int soma = 0; for (int i = 0; i < linhas; i++) for (int j = 0; j < colunas; j++) soma += matriz[i * colunas + j]; return soma; } int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[2][8]={{1, 2, 3, 4, 5, 6, 7, 8}, {11, 12, 13, 14, 15, 16, 17, 18}}; int c[3][7]={{1, 2, 3, 4, 5, 6, 7}, {11, 12, 13, 14, 15, 16, 17}, {21, 22, 23, 24, 25, 26, 27}}; cout << \"Soma dos elementos da primeira matriz: \" << somaMatrizBiDisfarcadaDeUni(a, 1, 10); cout << \"Soma dos elementos da segunda matriz: \" << somaMatrizBiDisfarcadaDeUni(b[0], 2, 8); cout << \"Soma dos elementos da terceira matriz: \" << somaMatrizBiDisfarcadaDeUni(c[0], 3, 7); return 0; } \\end{lstlisting} %TODO: escrever o vice-versa. {Exerc\u00edcios} \\fi \\chapter{Ordena\u00e7\u00e3o de Arranjos} {Introdu\u00e7\u00e3o} Uma das aplica\u00e7\u00f5es mais estudadas e realizadas sobre arranjos \u00e9 a \\textbf{ordena\u00e7\u00e3o}. Ordenar um arranjo significa permutar seus elementos de tal forma que eles fiquem em ordem crescente, ou seja, \\(v[0] <= v[1] <= v[2] <= \\dots{} <= v[n-1]\\) . Por exemplo, suponha o vetor\\ \\(v = {5, 6, -9, 9, 0, 4}\\) . \\ Uma ordena\u00e7\u00e3o desse vetor resultaria em um rearranjo de seus elementos: \\ \\(v = {-9, 0, 4, 5, 6, 9}\\) . Exitem diversos algoritmos de ordena\u00e7\u00e3o para vetores. Eles variam em rela\u00e7\u00e3o \u00e0 dificuldade de implementa\u00e7\u00e3o e desempenho. Usualmente algoritmos mais f\u00e1ceis de serem implementados apresentam desempenho inferior. Veremos 3 algoritmos diferentes de ordena\u00e7\u00e3o: \\begin{enumerate} \\item Algoritmo de Inser\u00e7\u00e3o (\\textit{Insertion Sort}); \\item Algoritmo de Sele\u00e7\u00e3o (\\textit{Selection Sort}); e \\item Algoritmo de Ordena\u00e7\u00e3o por Troca (\\textit{Bubble Sort}). \\end{enumerate} {Algoritmos de Ordena\u00e7\u00e3o} {Algoritmo de Inser\u00e7\u00e3o (\\textit{Insertion Sort})} Trata-se de um dos algoritmos de implementa\u00e7\u00e3o mais simples. Seu m\u00e9todo de ordena\u00e7\u00e3o semelhante ao que usamos para ordenar as cartas de um baralho. A id\u00e9ia b\u00e1sica do algoritmo \u00e9 descrita a seguir: \\begin{itemize} \\item Compare a chave (\\texttt{x}) com os elementos \u00e0 sua esquerda, deslocando para direita cada elemento maior do que a chave; \\item Insira a chave na posi\u00e7\u00e3o correta \u00e0 sua esquerda, onde os elementos j\u00e1 est\u00e3o ordenados; \\item Repita os passos anteriores atualizando a chave para a pr\u00f3xima posi\u00e7\u00e3o \u00e0 direita at\u00e9 o fim do vetor. \\end{itemize} A figura \\ref{fig:insertion_sort} apresenta um exemplo de uma etapa da execu\u00e7\u00e3o do algoritmo. \\begin{figure}[ht] \\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/insercao.png} \\end{center} \\caption{Exemplo do algoritmo \\textit{Insertion Sort}.} \\label{fig:insertion_sort} \\end{figure} O c\u00f3digo a seguir implementa o algoritmo em C, considerando um vetor \\texttt{v} de tamanho \\texttt{n}. \\begin{lstlisting} void insertionSort(int v[], int n) { int i, j, x; for(i = 1; i < n; i++) { x = v[i]; j = i - 1; while(j >= 0 && v[j] > x) { v[j+1] = v[j]; j--; } v[j+1] = x; } } \\end{lstlisting} {Algoritmo de Sele\u00e7\u00e3o (\\textit{Selection Sort})} A implementa\u00e7\u00e3o deste m\u00e9todo de ordena\u00e7\u00e3o \u00e9 muito simples. A id\u00e9ia b\u00e1sica \u00e9 descrita a seguir: \\begin{itemize} \\item Selecione o menor elemento do vetor de tamanho \\texttt{n}; \\item Troque esse elemento com o elemento da primeira posi\u00e7\u00e3o do vetor; \\item Repita as duas opera\u00e7\u00f5es anteriores considerando apenas os \\texttt{n-1} elementos restantes, em seguida repita com os \\texttt{n-2} elementos restantes; e assim sucessivamente at\u00e9 que reste apenas um elemento no vetor a ser considerado. \\end{itemize} A figura \\ref{fig:selection_sort} apresenta um exemplo da execu\u00e7\u00e3o do algoritmo. \\begin{figure}[h] \\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/selecao.png} \\end{center} \\caption{Exemplo do algoritmo \\textit{Selection Sort}.} \\label{fig:selection_sort} \\end{figure} O c\u00f3digo a seguir implementa o algoritmo em C, considerando um vetor \\texttt{v} de tamanho \\texttt{n}. \\begin{lstlisting} void selectionSort(int v[], int n) { int i, j, aux, min; for(i = 0; i < n-1; i++) { min = i; for(j = i+1; j < n; j++) { if(v[j] < v[min]) { min = j; } } aux = v[i]; v[i] = v[min]; v[min] = aux; //troca } } \\end{lstlisting} {Algoritmo de Ordena\u00e7\u00e3o por Troca (\\textit{Bubble Sort})} Outro algoritmo simples, muito \u00fatil para ordena\u00e7\u00e3o de vetores pequenos, mas n\u00e3o indicado para vetores maiores devido ao seu baixo desempenho computacional. Sua d\u00e9ia b\u00e1sica \u00e9 apresentada a seguir: \\begin{itemize} \\item Compare o primeiro elemento com o segundo. Se estiverem desordenados, ent\u00e3o efetue a troca de posi\u00e7\u00e3o. Compare o segundo elemento com o terceiro e efetue a troca de posi\u00e7\u00e3o, se necess\u00e1rio; \\item Repita a opera\u00e7\u00e3o anterior at\u00e9 que o pen\u00faltimo elemento seja comparado com o \u00faltimo. Ao final desta repeti\u00e7\u00e3o o elemento de maior valor estar\u00e1 em sua posi\u00e7\u00e3o correta, a n-\u00e9sima posi\u00e7\u00e3o do vetor; \\item Continue a ordena\u00e7\u00e3o posicionando o segundo maior elemento, o terceiro,..., at\u00e9 que todo o vetor esteja ordenado. \\end{itemize} A figura \\ref{fig:bubble_sort} apresenta um exemplo de um vetor sendo ordenado pelo algoritmo. \\begin{figure}[h] \\begin{center} \\includegraphics[width=.9\\textwidth]{imagens/bubblesort.png} \\end{center} \\caption{Exemplo de ordena\u00e7\u00e3o usando o algoritmo \\textit{Bubble Sort}.} \\label{fig:bubble_sort} \\end{figure} O c\u00f3digo a seguir implementa o algoritmo em C, considerando um vetor \\texttt{v} de tamanho \\texttt{n}. \\begin{lstlisting} void bubbleSort(int v[], int n) { int i, j, aux; for(i = n-1; i > 0; i--) { for(j = 0; j < i; j++) { if(v[j] > v[j+1]) { aux = v[j]; v[j] = v[j+1]; v[j+1] = aux; //troca } } } } \\end{lstlisting} {Exerc\u00edcios} {} Implemente na linguagem C o algoritmo de ordena\u00e7\u00e3o \\textit{insertion sort}. Utilize fun\u00e7\u00f5es auxiliares para implementar a ordena\u00e7\u00e3o, a leitura do vetor desordenado e a impress\u00e3o do vetor ordenado. {} Implemente na linguagem C o algoritmo de ordena\u00e7\u00e3o \\textit{selection sort}. Utilize fun\u00e7\u00f5es auxiliares para implementar a ordena\u00e7\u00e3o, a leitura do vetor desordenado e a impress\u00e3o do vetor ordenado. {} Implemente na linguagem C o algoritmo de ordena\u00e7\u00e3o \\textit{bubble sort}. Utilize fun\u00e7\u00f5es auxiliares para implementar a ordena\u00e7\u00e3o, a leitura do vetor desordenado e a impress\u00e3o do vetor ordenado. %TODO: Busca bin\u00e1ria %TODO: Inser\u00e7\u00e3o ordenada \\part{Intermedi\u00e1rio} \\chapter{Estruturas N\u00e3o-Homog\u00eaneas} {Introdu\u00e7\u00e3o} Imagine que voc\u00ea deseje armazenar informa\u00e7\u00f5es sobre um funcion\u00e1rio de uma empresa. Entre estas informa\u00e7\u00f5es podemos ter, por exemplo, nome, endere\u00e7o, telefone, sexo, estado civil, cargo, setor e sal\u00e1rio. Em um programa, isto seria representado por oito vari\u00e1veis apenas para um funcion\u00e1rio. Se voc\u00ea desejar incluir mais informa\u00e7\u00f5es, isto implicar\u00e1 em mais vari\u00e1veis, aumentando a complexidade do programa. Por esta raz\u00e3o, em muitas aplica\u00e7\u00f5es, \u00e9 importante a capacidade de se tratar todas as informa\u00e7\u00f5es de uma entidade (uma pessoa, por exemplo), como sendo uma \u00fanica unidade de armazenamento, ou seja, uma \u00fanica vari\u00e1vel. Por outro lado, deve ser poss\u00edvel, que esta \u00fanica vari\u00e1vel permita acesso a cada informa\u00e7\u00e3o em separado. Outros exemplos de informa\u00e7\u00e3o com esta caracter\u00edstica \u00e9 o endere\u00e7o, que pode ser decomposto em: logradouro, n\u00famero, complemento, CEP, cidade, estado, pa\u00eds. Neste tipo de informa\u00e7\u00e3o \u00e9 poss\u00edvel observar que, diferentemente de vari\u00e1veis indexadas (vetores e matrizes), n\u00e3o h\u00e1 homogeneidade quanto ao tipo de dados tratado. Por isso, deve haver um mecanismo para trabalhar com vari\u00e1veis estruturadas heterog\u00eaneas, tamb\u00e9m conhecidas simplesmente como \\textit{estruturas} ou \\textit{structs}. {Declara\u00e7\u00e3o} Na linguagem C, a palavra reservada \\lstinline|struct| \u00e9 destinada \u00e0 declara\u00e7\u00e3o de vari\u00e1veis n\u00e3o-homog\u00eaneas, e seu uso segue a seguinte sintaxe: \\[\\begin{verbatim} struct identificador{ tipo_campo_1 nome_campo_1; ... tipo_campo_n nome_campo_n; }; \\end{verbatim}\\] Em primeiro lugar, cada estrututura tem um identificador, usado na declara\u00e7\u00e3o de vari\u00e1veis do tipo desta estrutura. Em seguida, s\u00e3o declarados os campos da estrutura, especificadas entre as chaves. Os campos podem ter qualquer tipo, inclusive ser outra estrutura. O exemplo a seguir declara uma estrutura para o armazenamento de endere\u00e7os e v\u00e1rias vari\u00e1veis deste tipo. \\[\\begin{lstlisting} struct endereco { char logradouro[15]; int numero; char complemento[6], bairro[10]; char cidade[10], estado[3], pais[10]; }; ... struct endereco e1, e2, e3; \\end{lstlisting}\\] O uso da palavra reservada \\lstinline|struct| \u00e9 obrigat\u00f3rio na declara\u00e7\u00e3o de vari\u00e1veis, pois ela faz parte do tipo da vari\u00e1vel. O uso repetido desta palavra reservada pode ``poluir'' o c\u00f3digo, e por essa raz\u00e3o recomenda-se a defini\u00e7\u00e3o de novos tipos baseados na estrutura. {\\lstinline|typedef|} A palavra chave \\lstinline!typedef! permite que se defina novos tipos de dados a partir de tipos j\u00e1 existentes. Por exemplo, \u00e9 poss\u00edvel definir um tipo numero\\_real'' ou um tipo caractere''. A sintaxe para o uso \\lstinline|typedef| \u00e9 a seguinte: \\[\\begin{verbatim} typedef tipo_antigo tipo_novo; \\end{verbatim}\\] Os exemplos apenas dados s\u00e3o implementados assim: \\begin{lstlisting} typedef float numero_real; typedef char caractere; \\end{lstlisting} Mais importante, \u00e9 poss\u00edvel definir um tipo basedo na estrutura. Neste caso, h\u00e1 duas formas de faz\u00ea-lo. O exemplo a seguir mostra a mais verborr\u00e1gica. \\begin{lstlisting} struct end{ char logradouro[15]; int numero; char complemento[6], bairro[10]; char cidade[10], estado[3], pais[10]; }; ... typedef end endereco; endereco e1, e2, e3; \\end{lstlisting} Embora mais expl\u00edcita, esta forma n\u00e3o \u00e9 usada normalmente, em fun\u00e7\u00e3o forma mais compacta a seguir. \\[\\begin{lstlisting} typedef struct{ char logradouro[15]; int numero; char complemento[6], bairro[10]; char cidade[10], estado[3], pais[10]; } endereco; ... endereco e1, e2, e3; \\end{lstlisting}\\] {Acesso aos Campos de Uma Estrutura} Embora as estruturas agreguem v\u00e1rios campos, com raras exce\u00e7\u00f5es, o manuseio da mesma deve ser feito campo a campo, como vari\u00e1veis normais. Para acessar um dos campos de uma estrutura, usa-se o operador '.' (ponto). Diferentemente de vari\u00e1veis indexadas, vari\u00e1veis do tipo estrutura podem receber o valor de outra do mesmo tipo (desde que nenhum dos campos seja vetor). Por exemplo: \\begin{lstlisting} typedef struct st1 st1; struct st1 { char l; int i; float b; }; ... st1 s1 = {'c', -9, 4.76}, //Atribuicao na iniciacao. s1Copia, s2; s2.l = 'z'; //Atribuicao... s2.i = -4; //... campo a ... s2.b = 0.89; //... campo. s1Copia = s1; //Copia de valores de todos os campos. ... \\end{lstlisting} {Exemplo} Considere a estrutura \\texttt{complexo}, a qual representa um n\u00famero imagin\u00e1rio na forma \\(a + b \\times i\\) , em que o valor de \\(a\\) \u00e9 armazenado na vari\u00e1vel \\texttt{real} e o valor de \\(b\\) \u00e9 armazenado na vari\u00e1vel \\texttt{imag}. O exemplo a seguir apresenta uma matriz de \\(3 \\times 3\\) em que cada elemento \u00e9 do tipo \\texttt{complexo}. \\begin{lstlisting} include using namespace std; typedef struct{ float real, imag; } complexo; int main() { int i, j; complexo A[3][3] = { { {1.0, -0.1}, {2.0, -0.2}, {2.0, -0.2} }, //real { {4.0, -3.4}, {5.0, 4.1}, {6.0, -2.6} } //imag }; for ( i= 0; i < 3; i++) { for (j = 0; j < 3; j++) cout << A[i][j].real << \" + \" A[i][j].imag << \"*i\" << \\t; cout << endl; } return 0; } \\end{lstlisting} {Exerc\u00edcios} {} Fa\u00e7a um programa que leia informa\u00e7\u00f5es sobre 15 pessoas. Essa informa\u00e7\u00e3o deve ficar em um vetor de vari\u00e1veis do tipo estruturado \\texttt{pessoa}, o qual deve conter as seguintes informa\u00e7\u00f5es: \\begin{itemize} \\item Nome: string de tamanho 30; \\item Sexo: tipo enumerativo com os valores \\texttt{masc}, \\texttt{fem}; \\item Idade: valor inteiro; \\item Estado Civil: tipo enumerativo com os valores \\texttt{solteiro}, \\texttt{casado}, \\texttt{separado}, \\texttt{vi\u00favo}. \\item Sal\u00e1rio: valor real. \\end{itemize} Em seguida, imprima o n\u00famero de homens, n\u00famero de mulheres e informa\u00e7\u00f5es da pessoa com maior sal\u00e1rio. {} Fa\u00e7a um programa que leia o nome, duas notas e n\u00famero de faltas de 10 alunos. As informa\u00e7\u00f5es desses alunos devem ser armazenadas em um vetor de vari\u00e1veis do tipo estruturado \\texttt{aluno}, o qual deve conter as seguintes informa\u00e7\u00f5es de cada aluno: \\begin{itemize} \\item Nome: string de tamanho 30; \\item M\u00e9dia: n\u00famero real resultado da m\u00e9dia das duas notas lidas; \\item Situa\u00e7\u00e3o: caractere representando situa\u00e7\u00e3o, isto \u00e9, 'A' (Aprovado), se m\u00e9dia maior ou igual a 6 e n\u00famero de faltas menor que 10, e 'R' (Reprovado), caso contr\u00e1rio. \\item Faltas: n\u00famero de faltas (valor inteiro). \\end{itemize} Por fim, devem ser impressas as informa\u00e7\u00f5es de cada aluno. {Laborat\u00f3rio} Primeiramente, implemente sua solu\u00e7\u00e3o para o exerc\u00edcio anterior. Em seguida, implemente duas fun\u00e7\u00f5es, que ordenem os dados das pessoas por Nome e Idade, e imprimam todos os dados na tela. Finalmente, demonstre o uso destas fun\u00e7\u00f5es. %TODO: usar a analogia com planilha eletronica para mostrar como estrutura \u00e9 alocada na mem\u00f3ria. {Estruturas e fun\u00e7\u00f5es} Estruturas s\u00e3o utilizadas em fun\u00e7\u00f5es da mesma forma que os tipos b\u00e1sicos que vimos (\\lstinline|int, float, char|, \\ldots). Veja o exemplo a seguir: \\begin{lstlisting} include using namespace std; typedef struct pessoa pessoa; struct pessoa { char nome[40]; char sobrenome[40]; int idade; float salario; }; pessoa maisVelho(pessoa p1, pessoa p2) { return p1.idade > p2.idade ? p1 : p2; } int main() { pessoa pes1, pes2, mv; cout << entre nome, sobrenome, idade e salario da primeira pessoa: ''; cin >> pes1.nome >> pes1.sobrenome >> pes1.idade >> pes1.salario; cout << entre nome, sobrenome, idade e salario da segunda pessoa: ''; cin >> pes2.nome >> pes2.sobrenome >> pes2.idade >> pes2.salario; mv = maisVelho(pes1, pes2); cout << O mais velho eh '' << mv.nome << '' << mv.sobrenome << , com ''; cout << mv.idade << anos e salario de '' << mv.salario << endl; return 0; } \\end{lstlisting} De maneira an\u00e1loga, vetores de estruturas devem ser utilizados da mesma forma que vetores dos tipos b\u00e1sicos: \\begin{lstlisting} include define T 5 using namespace std; typedef struct pessoa pessoa; struct pessoa { char nome[40]; char sobrenome[40]; int idade; float salario; }; void lePessoas(pessoa p[]) { for(int i = 0; i < T; i++) { cout << entre nome, sobrenome, idade e salario da pessoa '' << (i+1) << :'' << endl; cin >> p[i].nome >> p[i].sobrenome >> p[i].idade >> p[i].salario; } } int maisVelho(pessoa p[]) { int idade = p[0].idade, posicao = 0; for(int i = 1; i < T; i++) { if(p[i].idade > idade) { idade = p[i].idade; posicao = i; } } return posicao; } int main() { pessoa p[T]; int pos; lePessoas(p); pos = maisVelho(p); cout << O mais velho eh '' << p[pos].nome << '' << p[pos].sobrenome << , com ''; cout << p[pos].idade << anos e salario de '' << p[pos].salario << endl; return 0; } \\end{lstlisting} {Laborat\u00f3rio} \\[\\begin{lab} Considerando a estrutura: \\begin{lstlisting} struct Ponto { int x; int y; }; \\end{lstlisting} para representar um ponto em uma grade 2D, implemente uma fun\u00e7\u00e3o que indique se um ponto \\texttt{p} est\u00e1 localizado dentro ou fora de um ret\u00e2ngulo. O ret\u00e2ngulo \u00e9 definido por seus v\u00e9rtices inferior esquerdo \\texttt{v1} e superior direito \\texttt{v2}. A fun\u00e7\u00e3o deve retornar 1 caso o ponto esteja localizado dentro do ret\u00e2ngulo e 0 caso contr\u00e1rio. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um fun\u00e7\u00e3o que recebe um valor em segundos e retorna o valor equivalente para o tipo hor\u00e1rio, o qual \u00e9 composto por hora, minuto e segundos. Em seguida imprima os campos da estrutura retornada. \\end{lab}\\] \\[\\begin{lab} Crie a estrutura baralho, baseado em um \u201cbaralho tradicional\u201d (cada carta tem seu naipe e seu valor). Implemente uma fun\u00e7\u00e3o que fa\u00e7a parte de distribui\u00e7\u00e3o (sorteio) de cartas para 2 jogadores, considerando que cada jogador ir\u00e1 receber 5 cartas. Exiba na tela as cartas que cada um dos jogadores recebeu. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que controla o consumo de energia dos eletrodom\u00e9sticos de uma casa. Leia um inteiro \\texttt{n} e, utilizando fun\u00e7\u00f5es auxiliares: \\begin{itemize} \\item Crie e leia \\texttt{n} eletrodom\u00e9sticos que cont\u00e9m nome (m\u00e1ximo 15 letras), potencia (real, em kW) e tempo ativo por dia (real, em horas). \\item Leia um tempo \\texttt{t} (em dias), calcule e mostre o consumo total na casa e o consumo relativo de cada eletrodom\u00e9stico (consumo/consumo total) nesse per\u00edodo de tempo. Apresente este \u00faltimo dado em porcentagem. \\end{itemize} \\end{lab}\\] \\chapter{Refer\u00eancias} O uso da analogia da mem\u00f3ria do computador com uma planilha eletr\u00f4nica nos permitiu entender como vari\u00e1veis simples e tamb\u00e9m arranjos s\u00e3o alocados em nossos programas. Agora que j\u00e1 conhecemos vetores, usaremos uma analogia mais precisa para entendermos refer\u00eancias, ou como s\u00e3o mais popularmente conhecidas, os famigerados ponteiros. {A mem\u00f3ria \u00e9 um grande vetor} \\label{sec:referencias.intro} A mem\u00f3ria de um computador pode ser vista como um grande vetor de bytes. O primeiro byte \u00e9 denominado byte 0, o segundo, byte 1 e assim por diante at\u00e9 o tamanho da mem\u00f3ria dispon\u00edvel ao seu programa. Quando em seu programa voc\u00ea, por exemplo, declara uma vari\u00e1vel do tipo caractere (\\lstinline|char|) com o nome \\lstinline|c|, o compilador separa um byte da mem\u00f3ria, digamos o byte 7542, e passa a cham\u00e1-lo de \\lstinline|c|. Assim, toda vez que se referir \u00e0 vari\u00e1vel \\lstinline|c| em seu programa, o computador sabe que est\u00e1 se referindo ao byte 7542. Neste caso, dizemos que o endere\u00e7o da vari\u00e1vel \\lstinline|c| \u00e9 7542. Similarmente, quando voc\u00ea aloca uma vari\u00e1vel do tipo inteiro, o compilador reserva quatro bytes para voc\u00ea, digamos, os bytes 8012, 8013, 8014 e 8015. Tal vari\u00e1vel tem o endere\u00e7o 8012 (como os tipos tem sempre tamanho fixo, o endere\u00e7o do primeiro byte mais a informa\u00e7\u00e3o sobre o tipo da vari\u00e1vel \u00e9 suficiente para o computador determinar de onde at\u00e9 onde na mem\u00f3ria cada vari\u00e1vel fica armazenada). Finalmente, quando voc\u00ea aloca um vetor de tamanho \\(n\\) de algum tipo qualquer, o compilador reserva um espa\u00e7o de tamanho \\(n \\times t\\) , onde \\(t\\) \u00e9 o tamanho do tipo em quest\u00e3o. Se s\u00e3o 10 inteiros, por exemplo, ent\u00e3o o vetor ter\u00e1 tamanho 40 bytes. O endere\u00e7o desta vari\u00e1vel \u00e9 o endere\u00e7o do primeiro byte da primeira c\u00e9lula. Assim, quando voc\u00ea, por exemplo, acessa a posi\u00e7\u00e3o 5 de um vetor de inteiros cujo endere\u00e7o \u00e9 1000, o computador faz o seguinte c\u00e1lculo para determinar a posi\u00e7\u00e3o de mem\u00f3ria que voc\u00ea est\u00e1 acessando, sabendo que cada inteiro ocupa 4 bytes: \\(1000+5*4\\) . {Vari\u00e1veis do Tipo Refer\u00eancia} Em certas situa\u00e7\u00f5es, o poder de se referir a posi\u00e7\u00f5es de mem\u00f3ria pelo seus endere\u00e7os em vez de por um nome de vari\u00e1vel \u00e9 muito \u00fatil. Por exemplo, imagine que precisemos calcular uma s\u00e9rie de estat\u00edsticas sobre os dados em um vetor. Neste caso, gostar\u00edamos de definir uma fun\u00e7\u00e3o que analisasse o vetor e desse como resultados as v\u00e1rias estat\u00edsticas, como m\u00e9dia, desvio padr\u00e3o, vari\u00e2ncia, intervalo de confian\u00e7a etc. Entretanto, como bem sabemos, fun\u00e7\u00f5es em C(++) retornam um \u00fanico resultado. Se, contudo, pud\u00e9ssemos passar como par\u00e2metro para a fun\u00e7\u00e3o as refer\u00eancias de onde gostar\u00edamos que os resultados fossem colocados, ent\u00e3o a fun\u00e7\u00e3o poderia coloc\u00e1-los diretamente nestas posi\u00e7\u00f5es de mem\u00f3ria. Esse mecanismo \u00e9 o que chamamos de passagem de par\u00e2metro por refer\u00eancia. Antes de se poder exercitar a passagem de par\u00e2metros por refer\u00eancia, contudo, precisamos aprender a declar\u00e1-las, a obter refer\u00eancias para posi\u00e7\u00f5es de mem\u00f3ria, e a usar tais refer\u00eancias. Estas opera\u00e7\u00f5es s\u00e3o feitas pelos operadores \\lstinline|*| e \\lstinline|&|. A declara\u00e7\u00e3o de vari\u00e1veis segue a seguinte sintaxe: \\[\\begin{verbatim} tipo *identificador; \\end{verbatim}\\] Assim, para se declarar vari\u00e1veis de refer\u00eancia para uma posi\u00e7\u00f5es de mem\u00f3ria que armazenam um inteiro, um caractere, e um float, voc\u00ea usaria as seguintes declara\u00e7\u00f5es: \\begin{lstlisting} int *ref_int; char *ref_char; float *zabumba; \\end{lstlisting} Observe que o \\lstinline|*| \u00e9 sempre considerado como ligado ao identificador e n\u00e3o ao tipo da vari\u00e1vel. Assim, a linha de c\u00f3digo \\begin{lstlisting} int *a, b, *c; \\end{lstlisting} declara duas refer\u00eancias para inteiro (\\lstinline|a| e \\lstinline|c|), e um inteiro (\\lstinline|b|). Para se evitar confus\u00f5es, sugere-se que n\u00e3o se declare vari\u00e1veis do tipo refer\u00eancia e n\u00e3o refer\u00eancia em conjunto. Ou seja, a c\u00f3digo acima deveria ser reescrito como \\begin{lstlisting} int *a, *c; int b; \\end{lstlisting} O operador \\lstinline|&| permite que se extraia o endere\u00e7o (ou uma refer\u00eancia) de uma vari\u00e1vel. No c\u00f3digo, \\begin{lstlisting} int *a; int b; a = &b; \\end{lstlisting} \\lstinline|a| recebe o endere\u00e7o da vari\u00e1vel \\lstinline|b|. Logo, se \\lstinline|b| est\u00e1 nos bytes 2012, 2013, 2014 e 2015, a vari\u00e1vel a recebe o valor 2012. Aqui, gostar\u00edamos de chamar a aten\u00e7\u00e3o para o seguinte fato: \\emph{em rar\u00edssimas situa\u00e7\u00f5es \u00e9 necess\u00e1rio saber o endere\u00e7o de uma vari\u00e1vel. Na maior parte dos casos, basta saber que uma vari\u00e1vel tem tal endere\u00e7o.}. Finalmente, o operador \\lstinline|*| tamb\u00e9m nos permite acessar o conte\u00fado de uma vari\u00e1vel referenciada, em do valor da refer\u00eancia. No c\u00f3digo, \\begin{lstlisting} int *a; int b; int c; a = &b; *a = 20; c = *a; c++; \\end{lstlisting} a vari\u00e1vel \\lstinline|b| termina com o valor 20, enquanto que a vari\u00e1vel c termina com o valor 21. {Passagem de Refer\u00eancias como Par\u00e2metros} Vari\u00e1veis do tipo refer\u00eancia, como outros tipos de vari\u00e1veis, podem ser passadas como par\u00e2metro em chamadas de fun\u00e7\u00e3o. A grande vantagem desta t\u00e9cnica, tamb\u00e9m conhecida como passagem de par\u00e2metros por refer\u00eancia, \u00e9 a possibilidade de modifica\u00e7\u00e3o da mem\u00f3ria para qual a refer\u00eancia foi passada. Por exemplo, analise o seguinte c\u00f3digo. \\begin{lstlisting} include include using namespace std; void sen_cos_tan(float val, float *seno, float *cosseno, float *tangente) { *seno = sin(val); *cosseno = cos(val); *tangente = tan(val); } int main() { float v = 0, s, c, t; sen_cos_tan(v, &s, &c, &t); cout << \"seno: \" << s << \" cosseno: \" << c << \" tangente: \"<< t; return 0; } \\end{lstlisting} Esse programa calcula em uma \u00fanica chamada, os valores do seno, cosseno e tangente da vari\u00e1vel \\lstinline|v|. Enquanto o feito n\u00e3o parece muito impressionante, pense no caso em que voc\u00ea precisa calcular diversas estat\u00edsticas de um vetor de n\u00fameros. Neste caso, devido \u00e0 forte depend\u00eancia do c\u00e1lculo de uma estat\u00edstica no c\u00e1lculo de outras, esta fun\u00e7\u00e3o poderia simplificar em muito o seu c\u00f3digo. {Laborat\u00f3rio} \\[\\begin{lab} Escreva um programa que contenha fun\u00e7\u00f5es que calculam a m\u00e9dia, vari\u00e2ncia e desvio padr\u00e3o de um vetor de n\u00fameros reais (uma fun\u00e7\u00e3o por dado estat\u00edstico). \\end{lab}\\] \\[\\begin{lab} Altere o programa do exerc\u00edcio anterior para que calcule as tr\u00eas estat\u00edsticas em uma fun\u00e7\u00e3o apenas, reaproveitado os c\u00e1lculos uns dos outros. \\end{lab}\\] \\chapter{Refer\u00eancias II} Continuando com o estudo de ponteiros, vamos ver como utiliz\u00e1-los para referenciar estruturas e arranjos. {Ponteiros para Structs} Se voc\u00ea recordar-se da anologia apresentada na se\u00e7\u00e3o \\ref{sec:referencias.intro}, em que a mem\u00f3ria \u00e9 comparada a um grande vetor e cada tipo de dados tem um tamanho pr\u00e9-definido, \u00e9 f\u00e1cil entender como uma estrutura \u00e9 representada na mem\u00f3ria. Considere a seguinte estrutura e responda: qual o tamanho desta estrutura na mem\u00f3ria do computador? \\begin{lstlisting} typedef struct { int i; char c; float j; } exemplo1; \\end{lstlisting} Para responder a esta pergunta precisamos entender que uma estrutura ocupa espa\u00e7o equivalente \u00e0 soma do espa\u00e7o ocupado por cada um de seus campos. Desta forma, o espa\u00e7o total ocupado por uma vari\u00e1vel do tipo \\lstinline|exemplo1| ser\u00e1 a soma dos tamanhos de 1 \\lstinline|int|, 1 \\lstinline|char| e 1 \\lstinline|float|, ou seja, \\(4 + 1 + 4 = 9\\) bytes. Assim, e voc\u00ea cria uma vari\u00e1vel \\lstinline{exemplo1 v[10]}, o compilador deve reservar um espa\u00e7o de \\(10 \\times 9 = 90\\) bytes. Assim como nos referimos a vari\u00e1veis dos tipos primitivos (inteiro, real, caractere) utilizando ponteiros, podemos tamb\u00e9m utilizar ponteiros para acessar uma vari\u00e1vel do tipo \\lstinline|struct| e seus campos. Veja o exemplo para a estrutura declarada anteriormente. \\[\\begin{lstlisting} exemplo1 a = {-5, 'z', 0.89}, b; exemplo1 *p; p = &a; cout << (*p).i << endl; p = &b; cin >> (*p).c; \\end{lstlisting}\\] Este trecho mostra na linha 1 a cria\u00e7\u00e3o de duas vari\u00e1veis do tipo \\lstinline|exemplo1| e na linha 2 a cria\u00e7\u00e3o de uma vari\u00e1vel do tipo ponteiro para \\lstinline|exemplo1|. As linhas 3 e 5 atualizando o ponteiro, fazendo com que referencie as vari\u00e1veis \\lstinline|a| e \\lstinline|b|, respectivamente. Desta maneira, a linha 4 ir\u00e1 imprimir o valor de \\lstinline|a.i|, enquanto a linha 6 ir\u00e1 ler a partir do teclado um valor para \\lstinline|b.c|. Quando usamos ponteiros e estruturas, aparece o incoveniente de termos que digitar toda vez entre par\u00eanteses a vari\u00e1vel do tipo ponteiro (\\lstinline{(*p).c}). Para simplificar a utiliza\u00e7\u00e3o de ponteiros no acesso a campos de uma estrutura, a linguagem C permite escrever esta mesma instru\u00e7\u00e3o de uma maneira mais f\u00e1cil de digitar: \\lstinline{p->c}. O c\u00f3digo anterior pode ser reescrito como: \\[\\begin{lstlisting} exemplo1 a = {-5, 'z', 0.89}, b; exemplo1 *p; p = &a; cout << p->i << endl; p = &b; cin >> p->c; \\end{lstlisting}\\] Por fim, a passagem de estruturas por refer\u00eancia em fun\u00e7\u00f5es auxiliares \u00e9 feita da mesma forma que vimos no cap\u00edtulo anterior: \\begin{lstlisting} void inverte_structs(exemplo1 *s1, exemplo2 *s2) { exemplo1 aux aux.i = s2->i; s2->i = s1->i; s1->i = aux.i; aux.c = s2->c; s2->c = s1->c; s1->c = aux.c; aux.j = s2->j; s2->j = s1->j; s1->j = aux.j; } int main() { exemplo1 a = {1, 'a', 1.0}, b = {2, 'b', 2.0}; inverte_structs(&a, &b); cout << a.i << \", \" << a.c << \",\" << a.j << endl; cout << b.i << \", \" << b.c << \",\" << b.j << endl; return 0; } \\end{lstlisting} A fun\u00e7\u00e3o auxiliar troca os valores de duas vari\u00e1veis do tipo \\lstinline|exemplo1| passadas por refer\u00eancia. Ap\u00f3s a invoca\u00e7\u00e3o da fun\u00e7\u00e3o auxiliar a partir da \\lstinline|main| os valores iniciais das vari\u00e1veis \\lstinline|a| e \\lstinline|b| ser\u00e3o trocados. {Arranjos e Ponteiros} At\u00e9 agora vimos vetores sem nenhuma rela\u00e7\u00e3o com ponteiros. No fundo, quando criamos um vetor com a instru\u00e7\u00e3o \\lstinline{int a[10]}, estamos dizendo ao compilador para reservar na mem\u00f3ria espa\u00e7o para 10 inteiros (40 bytes) e armazenar o endere\u00e7o em que come\u00e7a o vetor na vari\u00e1vel \\lstinline|a|. Em outras palavras, a vari\u00e1vel \\lstinline|a| \u00e9 um \\textit{ponteiro} para o primeiro elemento do vetor. Por esta raz\u00e3o, a rela\u00e7\u00e3o entre vetores e ponteiros \u00e9 mais direta e mais f\u00e1cil de utilizar. Uma vez que a vari\u00e1vel que usamos cont\u00e9m o endere\u00e7o do come\u00e7o do vetor, um ponteiro pode receber diretamente seu valor, sem necessidade do operador \\&. Considere o exemplo a seguir: \\[\\begin{lstlisting} float a[10]; float *p; p = a; cout << \"Digite 10 numeros reais: \"; for(int i = 0; i < 10; i++) cin >> a[i]; cout << \"Num. digitados: \"; for(int i = 0; i < 10; i++) cout << p[i]; \\end{lstlisting}\\] Observe a linha 3 e perceba como a atualiza\u00e7\u00e3o da refer\u00eancia do ponteiro \\lstinline|p| para o vetor \\lstinline|a| n\u00e3o utilizou o \\&. Isto porque \\lstinline|a| tamb\u00e9m \u00e9 um ponteiro. A diferen\u00e7a entre \\lstinline|p| e \\lstinline|a| \u00e9 que a primeira pode ter sua refer\u00eancia atualizada, enquanto a segunda n\u00e3o. A partir da linha 3, o vetor pode ser acessado tanto pela vari\u00e1vel \\lstinline|a| (linha 6) quanto pela vari\u00e1vel \\lstinline|p| (linha 9). \u00c9 por este motivo que vetores sempre s\u00e3o passados por refer\u00eancia em fun\u00e7\u00f5es auxiliares, sem a necessidade do \\& e do *. {Percorrendo vetores com ponteiros} \\label{ssec:referencias2-percorrendo_vetores} J\u00e1 sabemos a rela\u00e7\u00e3o entre ponteiros e vetores. Veremos a seguir algumas maneiras diferentes de acessar os elementos de um vetor utilizando ponteiros. Considere o trecho de um programa a seguir: \\[\\begin{lstlisting} char str[100]; char *s; int totalletras = 0; s = str; cout << \"entre uma frase com letras minusculas\" << endl; cin.getline(s,100); for(int i = 0; i < strlen(s); i++) { if(s[i] >= 'a' && s[i] <= 'z') { totalletras++; } } cout << \"O total de letras da frase eh \" << totalletras; \\end{lstlisting}\\] Neste trecho utilizamos o ponteiro \\lstinline|s| como o vetor \\lstinline|str|, pois a partir da linha 3 ele ``aponta'' para o vetor. Este mesmo trecho pode ser reescrito: \\[\\begin{lstlisting} char str[100]; char *s; int totalletras = 0; s = str; cout << \"entre uma frase com letras minusculas\" << endl; cin.getline(s,100); for(int i = 0; i < strlen(s); i++) { if( *(s+i) >= 'a' && *(s+i) <= 'z' ) { totalletras++; } } cout << \"O total de letras da frase eh \" << totalletras; \\end{lstlisting}\\] Observe a linha 9 de cada um dos dois trechos anteriores e veja a diferen\u00e7a na nota\u00e7\u00e3o. Quando utilizamos ponteiro, podemos acessar um vetor pelo \u00edndice (colchetes) ou por um deslocamento sobre o valor do endere\u00e7o inicial do vetor armazenado em \\lstinline{s}, ou seja, a nota\u00e7\u00e3o \\lstinline{*(s+i)}, significa o caractere localizado \\lstinline{i} caracteres a partir do caractere na primeira posi\u00e7\u00e3o do vetor. O mesmo trecho pode ser reescrito ainda de uma terceira forma: \\[\\begin{lstlisting} char str[100]; char *s; int totalletras = 0; s = str; cout << \"entre uma frase com letras minusculas\" << endl; cin.getline(s,100); for(int i = 0; i < strlen(str); i++) //Observe que aqui usamos str e nao s. Por que? { if( *s >= 'a' && *s <= 'z' ) { totalletras++; } s++; } cout << \"O total de letras da frase eh \" << totalletras; \\end{lstlisting}\\] Qual a diferen\u00e7a entre esta vers\u00e3o e as vers\u00f5es anteriores? Qual a diferen\u00e7a entre \\lstinline{s++} e \\lstinline{(*s)++}? Qual o valor de \\lstinline|s[0]| em cada vers\u00e3o? E de \\lstinline|*s|? E de \\lstinline|str[0]|? {Laborat\u00f3rio} \\begin{lab} Crie uma estrutura com os campos nome, idade e salario dos tipos \\textit{string}, inteiro e real, respectivamente. Em seguida, crie uma fun\u00e7\u00e3o que receba refer\u00eancias para duas vari\u00e1veis de tal tipo e uma vari\u00e1vel correspondente a uma porcentagem de aumento que deve ser aplicada sobre o campo sal\u00e1rio de cada estrutura. A fun\u00e7\u00e3o principal deve ler cada campo das duas vari\u00e1veis e imprimir o novo sal\u00e1rio. Finalmente, crie uma fun\u00e7\u00e3o que recebe duas vari\u00e1veis de tal tipo e que troque os valores de todos os campos das duas estruturas. A fun\u00e7\u00e3o principal deve agora imprimir as estruturas antes e depois da troca. \\end{lab} \\[\\begin{lab} Execute as tr\u00eas vers\u00f5es do programa da se\u00e7\u00e3o \\ref{ssec:referencias2-percorrendo_vetores} e veja se h\u00e1 diferen\u00e7a no resultado. Responda \u00e0s perguntas no final da se\u00e7\u00e3o. \\end{lab}\\] \\chapter{Aloca\u00e7\u00e3o Din\u00e2mica} Por mais interessante que seja poder criar ponteiros para vari\u00e1veis j\u00e1 existentes e passar par\u00e2metros por refer\u00eancia, o poder dos ponteiros s\u00f3 fica mesmo evidente quando se trabalha com aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria. Aloca\u00e7\u00e3o din\u00e2mica \u00e9 a habilidade de se criar novas vari\u00e1veis durante a execu\u00e7\u00e3o do programa, sem que elas tenham sido declaradas antes. Justamente por n\u00e3o terem sido declaradas antes da compila\u00e7\u00e3o, estas vari\u00e1veis alocadas dinamicamente n\u00e3o t\u00eam nomes e, assim, s\u00f3 podem ser acessadas por meio de refer\u00eancias. {Aloca\u00e7\u00e3o Din\u00e2mica de Tipos Simples} Existem v\u00e1rias formas de se alocar mem\u00f3ria dinamicamente, todas elas via fun\u00e7\u00f5es que retornam como resultado uma refer\u00eancia para o come\u00e7o da mem\u00f3ria alocada, na forma de uma refer\u00eancia gen\u00e9rica. A fun\u00e7\u00e3o mais simples para aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 a \\lstinline|malloc|. Esta fun\u00e7\u00e3o recebe como \u00fanico par\u00e2metro o tamanho da mem\u00f3ria a ser alocada, em bytes. Observe o seguinte c\u00f3digo para alguns exemplos. \\begin{lstlisting} char *s1; int *i1; float *f1; s1 = (char *) malloc(1); i1 = (int *) malloc(4); f1 = (float *) malloc(4); \\end{lstlisting} No exemplo acima voc\u00ea percebe que antes de cada \\lstinline|malloc| h\u00e1, entre par\u00eanteses, o tipo da vari\u00e1vel que guardar\u00e1 a refer\u00eancia. Isso \u00e9 o que chamamos de \\emph{casting}, e serve para transformar a refer\u00eancia gen\u00e9rica retornada pela fun\u00e7\u00e3o para o tipo de refer\u00eancia da vari\u00e1vel. \\textbf{Este \\emph{casting} \u00e9 obrigat\u00f3rio em seu c\u00f3digo}. Voc\u00ea tamb\u00e9m percebe que cada aloca\u00e7\u00e3o especifica exatamente o tamanho do tipo para o qual estamos alocando a mem\u00f3ria. Isto \u00e9, 1 para caracteres e 4 para inteiros e n\u00fameros reais. Estes tamanhos, contudo, podem variar de uma m\u00e1quina/sistema operacional para outra, o que tornaria complicado especificar tais tamanhos em cada invoca\u00e7\u00e3o \u00e0 \\lstinline|malloc|. \u00c9 por isso que a linguagem C(++) especifica o construto \\lstinline|sizeof|, que ``descobre'' o tamanho do tipo para voc\u00ea, conforme o seguinte exemplo. \\begin{lstlisting} char *s1; int *i1; float *f1; double *d1; s1 = (char *) malloc(sizeof(char)); i1 = (int *) malloc(sizeof(int)); f1 = (float *) malloc(sizeof(float)); d1 = (double *) malloc(sizeof(double)); \\end{lstlisting} {Aloca\u00e7\u00e3o Din\u00e2mica de Vetores} Como visto nos cap\u00edtulos anteriores, a diferen\u00e7a entre refer\u00eancias para tipos simples e vetores \u00e9... \\textbf{nenhuma}! Isso quer dizer que podemos alocar vetores usando um c\u00f3digo similar ao anterior, alterando apenas a quantidade de mem\u00f3ria alocada, como no seguinte exemplo. \\begin{lstlisting} char *s2; int *i2; float *f2; double *d2; s2 = (char *) malloc(sizeof(char) * 100); i2 = (int *) malloc(sizeof(int) * 10); f2 = (float *) malloc(sizeof(float) * 6); d2 = (double *) malloc(sizeof(double) * 8); cin.getline(s2,100); cout << s2; for(int i = 0; i < 10; i++) cin >> i2[i]; for(int i = 0; i < 10; i++) cout << i2[i] << endl; for(int i = 0; i < 6; i++) cin >> f2[i]; for(int i = 0; i < 6; i++) cout << f2[i] << endl; for(int i = 0; i < 8; i++) cin >> d2[i]; for(int i = 0; i < 8; i++) cout << d2[i] << endl; \\end{lstlisting} {Libera\u00e7\u00e3o de mem\u00f3ria} Todos os exemplos mostrados at\u00e9 agora neste cap\u00edtulo s\u00e3o incompletos. Isso por qu\u00ea nenhum programa que fa\u00e7a aloca\u00e7\u00e3o din\u00e2mica em C(++) pode ser completo sem que se fa\u00e7a a libera\u00e7\u00e3o da mem\u00f3ria alocada. Liberar ou ``desalocar'' a mem\u00f3ria consiste simplesmente na invoca\u00e7\u00e3o da fun\u00e7\u00e3o \\lstinline|free|, passando-se como par\u00e2metro a refer\u00eancia a ser desalocada. O uso de \\lstinline|free| ser\u00e1 exemplificado na pr\u00f3xima se\u00e7\u00e3o. {Aloca\u00e7\u00e3o Din\u00e2mica de Estruturas} Assim como declarar uma refer\u00eancia para uma estrutura \u00e9 t\u00e3o simples quanto declarar uma refer\u00eancia para um tipo primitivo(simples), alocar um vetor de estruturas dinamicamente \u00e9 t\u00e3o simples quanto alocar um vetor de tipos primitivos dinamicamente. O exemplo a seguir mostra exatamente como alocar um vetor com 10 estruturas do tipo definido. \\begin{lstlisting} define NUM_PESSOAS 10 typedef struct { char prim_nome[20], char ult_nome[20], int idade, float salario, char regiao, char sexo } pessoa_t; int main() { pessoa_t *pessoas; pessoas = (pessoa_t *) malloc(sizeof(pessoa) * NUM_PESSOAS); for(int i = 0; i < NUM_PESSOAS; i++) { cin >> pessoas[i].prim_nome; cin >> pessoas[i].ult_nome; cin >> pessoas[i].idade; cin >> pessoas[i].salario; cin >> pessoas[i].sexo; cin >> pessoas[i].regiao; } //Uso dos dados ... //Liberacao da memoria free(pessoas); return 0; } \\end{lstlisting} {Exerc\u00edcios} {} Escreva um programa que leia um numero inteiro N, aloque dinamicamente um vetor de N inteiros, leia cada um dos N inteiros, e imprima os N inteiros na tela. {} Escreva um programa que repita o seguinte procedimento X vezes: leia um numero inteiro N, aloque dinamicamente um vetor de N carateres, leia uma palavra de N caracteres, transforme todas as mai\u00fasculas em min\u00fasculas e vice-versa na palara e imprima o resultado na tela. X deve ser lido no in\u00edcio da execu\u00e7\u00e3o do programa. {Laborat\u00f3rio} {} Implemente os exerc\u00edcios acima. {} Escreva um programa que aloque um vetor de 100000 float e imprima os 10 primeiros e os 10 \u00faltimos (o lixo que estiver na mem\u00f3ria). \\footnote{Se tudo funcionar, aumente o vetor para 1000000 e assim por diante. O objetivo neste laborat\u00f3rio \u00e9 mostrar que a quantidade de mem\u00f3ria dispon\u00edvel para seu programa \u00e9 limitada, e que se extrapolada, seu programa incorrer\u00e1 em um erro.} %TODO: \\chapter{Vetores de Refer\u00eancias} %TODO: Combinando vetores para refer\u00eancias para tipos simples e estruturados. %TODO: \\chapter{Aloca\u00e7\u00e3o Din\u00e2mica II} %TODO: Aloca\u00e7\u00e3o de arranjos multi-dimensionais (caso cont\u00edguo) \\chapter{Arquivos} %\\todo{Mover para 4 ou 5 cap\u00edtulo. Alunos v\u00eaem mais exemplos pr\u00e1ticos de aplicabilidade} Muitas vezes desejamos guardar o resultado de alguma computa\u00e7\u00e3o para consulta posterior. Imagine, por exemplo, que voc\u00ea fez um programa que calcula a m\u00e9dia final e situa\u00e7\u00e3o de toda a turma. Se o resultado deste processamento n\u00e3o puder ser armazenado, toda vez que for necess\u00e1rio consultar a situa\u00e7\u00e3o de algum aluno, o programa dever\u00e1 ser executado e todos os dados inseridos novamente. Para solucionar este problema, o usu\u00e1rio pode salvar resultados de computa\u00e7\u00e3o em uma estrutura persistente. Esta estrutura de dados manipulada fora do ambiente do programa (mem\u00f3ria principal) \u00e9 conhecida como \\textbf{arquivo}. Um arquivo \u00e9 armazenado em um dispositivo de mem\u00f3ria secund\u00e1ria (CD, DVD, disco r\u00edgido, pendrive) e pode ser lido ou escrito por um programa. Em C, um arquivo pode representar diversas coisas, como documentos, uma impressora, um teclado, ou qualquer dispositivo de entrada ou sa\u00edda. Consideraremos apenas dados em disco, iniciando por dados na forma textual. {Arquivos de texto} Nesta se\u00e7\u00e3o estudaremos apenas arquivos texto, ou seja, arquivos que cont\u00eam apenas caracteres e podem ser visualizados em editores de textos como Notepad, Gedit, Vim, etc. A linguagem C++ d\u00e1 suporte \u00e0 utiliza\u00e7\u00e3o de arquivos por meio da biblioteca \\lstinline|fstream|. Esta biblioteca fornece v\u00e1rias fun\u00e7\u00f5es para manipula\u00e7\u00e3o de arquivos e define alguns tipos de dados para serem usados especificamente com arquivos. O principal tipo definido nessa biblioteca que ser\u00e1 usado \u00e9 o tipo \\lstinline|fstream|. Um vari\u00e1vel do tipo \\lstinline|fstream| \u00e9 capaz de identificar um arquivo no disco, direcionando-lhe todas as opera\u00e7\u00f5es. Essas vari\u00e1veis s\u00e3o declaradas da seguinte maneira: \\lstinline|fstream arq;| {Abertura e Fechamendo de Arquivos} Antes que o arquivo seja manipulado, \u00e9 preciso abr\u00ed-lo, o que \u00e9 feito via ``fun\u00e7\u00e3o'' \\lstinline|open| do arquivo. Uma vez aberto, o arquivo funciona como o \\lstinline|cin| e \\lstinline|cout|, com os quais voc\u00ea j\u00e1 est\u00e1 acostumado a usar \\lstinline|<<| e \\lstinline|>>|, como no exemplo a seguir. Ao terminar o uso do arquivo, \u00e9 importante fech\u00e1-lo, para garantir que tudo que, em teoria, est\u00e1 escrito no arquivo, realmente foi colocado no disco. \\begin{lstlisting} include include using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\"); arquivo << \"O que eu deveria escrever neste arquivo?\" << endl; arquivo.close(); return 0; } \\end{lstlisting} Nem sempre \u00e9 poss\u00edvel abrir o arquivo como no exemplo, o que ser\u00e1 explicado adiante. Para testar se o arquivo foi aberto ou n\u00e3o, use a fun\u00e7\u00e3o \\lstinline|is_open()|. \u00c9 importante que voc\u00ea teste se o arquivo realmente est\u00e1 aberto, antes de tentar us\u00e1-lo. \\begin{lstlisting} include include using namespace std; int main () { fstream arquivo; arquivo.open(\"arquivo.txt\"); if(arquivo.is_open()) { arquivo << \"O que eu deveria escrever neste arquivo?\" << endl; arquivo.close(); cout << \"tudo escrito\"; } else cout << \"falhou\"; return 0; } \\end{lstlisting} Se voc\u00ea tentou executar o c\u00f3digo acima, percebeu que a mensagem \"falhou\" foi escrita na tela. O problema \u00e9 que o c\u00f3digo abre um arquivo e escreve no mesmo, mas somente se ele j\u00e1 existir, o que n\u00e3o \u00e9 o caso. Por enquanto, v\u00e1 at\u00e9 a pasta onde est\u00e1 o seu projeto e crie o arquivo manualmente. Na se\u00e7\u00e3o seguinte veremos como criar um arquivo ``de dentro'' do programa. J\u00e1 no c\u00f3digo a seguir, veja como os dados do arquivo podem ser lidos. \\begin{lstlisting} include include using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\"); if(arquivo.is_open()) { cout << \"yeah\"; arquivo << \"Sera que isso foi escrito?\" << endl; arquivo.close(); arquivo.open (\"arquivo.txt\"); char str[1000]; arquivo.getline(str,1000); arquivo.close(); cout << str; } else cout << \"O arquivo nao foi aberto\"; return 0; } \\end{lstlisting} {Cria\u00e7\u00e3o de Arquivos} Para abrir um arquivo que n\u00e3o existe, ou seja, criar o arquivo, \u00e9 necess\u00e1rio passar um conjunto especial de instru\u00e7\u00f5es para a fun\u00e7\u00e3o de abertura. Infelizmente, o \u00fanico jeito de passar estas instru\u00e7\u00f5es \u00e9 bem mais complicado do que o que vimos at\u00e9 agora. Veja o seguinte c\u00f3digo, em especial a linha que abre o arquivo. \\begin{lstlisting} include include using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\", ios::out | ios::in | ios::trunc); if(arquivo.is_open()) cout << \"yeah\"; else cout << \"nope\"; arquivo << \"O que eu deveria escrever neste arquivo?\" << endl; arquivo.close(); arquivo.open (\"arquivo.txt\"); char str[1000]; arquivo.getline(str,1000); arquivo.close(); cout << str; return 0; } \\end{lstlisting} Na frente do par\u00e2metro com o nome do arquivo, na fun\u00e7\u00e3o \\lstinline|open|, foram passadas tr\u00eas op\u00e7\u00f5es para o modo de abertura do arquivo, que especifica o tipo de opera\u00e7\u00f5es que se intende fazer no arquivo (o caractere \\lstinline-|- combina as op\u00e7\u00f5es passadas). Algumas das op\u00e7\u00f5es poss\u00edveis s\u00e3o: \\[\\begin{itemize} \\item ios::in -- Opera\u00e7\u00f5es de escrita. \\item ios::out -- Opera\u00e7\u00f5es de leitura. \\item ios::app -- Posiciona no fim do arquivo. N\u00e3o pode ser reposicionado. N\u00e3o pode ser usado com ios::in. \\item ios::trunc -- Posiciona no in\u00edcio do arquivo. Se o arquivo j\u00e1 existe, ent\u00e3o seu conte\u00fado anterior \u00e9 perdido. \\end{itemize}\\] As op\u00e7\u00f5es para leitura e escrita do arquivo, e somente estas, s\u00e3o impl\u00edcitas, quando nenhuma op\u00e7\u00e3o \u00e9 especificada. Se voc\u00ea quiser, pode usar apenas uma destas por quest\u00f5es de seguran\u00e7a (o arquivo pode ser lido mas n\u00e3o escrito, ou o arquivo pode ser aumentado mas n\u00e3o lido). Usando somente as op\u00e7\u00f5es de leitura e escrita, contudo, o arquivo n\u00e3o \u00e9 criado caso n\u00e3o exista. Para que seja criado, \u00e9 necess\u00e1rio que se especifique ou \\lstinline|ios::trunc| ou \\lstinline|ios::app|, que far\u00e3o com que o arquivo seja ou truncado ou que toda modifica\u00e7\u00e3o seja adicionada ao fim do arquivo (\\emph{append}). {Cuidados com a Formata\u00e7\u00e3o dos Dados} Quando se escreve um dado em um arquivo de texto, precisa-se entender que o dado ocupa somente o espa\u00e7o que voc\u00ea especificar. Isto \u00e9, se voc\u00ea escrever a sequ\u00eancia de caracteres C(++) \u00e9 bom!!!'', 14 caracteres ser\u00e3o escritos, e pronto. Se escrever algo na linha seguinte depois resolver mudar a string acima para C(++) n\u00e3o \u00e9 bom!!!'', ent\u00e3o a divis\u00e3o entre as linhas (o \\lstinline|endl|) ter\u00e1 sido sobrescrito e as duas linhas se tornar\u00e3o uma. Estes cuidados n\u00e3o precisam ser tomados agora, com os exemplos simples com os quais estamos lidando, mas nos pr\u00f3ximos capitulos voc\u00ea ter\u00e1 que tom\u00e1-los. Assim, melhor que voc\u00ea j\u00e1 saiba sobre estes problemas desde agora. \\begin{lstlisting} include include using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\", ios::out | ios::in | ios::trunc); char str[1000]; if(arquivo.is_open()) { cout << \"O arquivo foi aberto!\"; arquivo << \"Escrevendo um numero pequeno:\" << endl; arquivo << 10 <<endl; arquivo << \"Numero pequeno escrito.\" << endl; cout << \"Fechando o arquivo.\"; arquivo.close(); cout << \"Reabrindo o arquivo.\"; arquivo.open (\"arquivo.txt\"); arquivo << \"Escrevendo um numero pequeno:\" << endl; arquivo << 10000 <<endl; cout << \"Fechando o arquivo.\"; arquivo.close(); cout << \"Reabrindo o arquivo.\"; arquivo.open (\"arquivo.txt\"); arquivo.getline(str,1000); cout << str; arquivo.getline(str,1000); cout << str; arquivo.getline(str,1000); cout << str; arquivo.close(); } else cout << \"nope\"; return 0; } \\end{lstlisting} {Laborat\u00f3rio} \\[\\begin{lab} Fa\u00e7a um programa que leia o nome e sobrenome de 30 alunos e armazene em um arquivo, de tal forma que o arquivo tenha um aluno por linha. Abra o arquivo usando um editor de textos qualquer, como o Notepad. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que tente abrir um arquivo e, caso n\u00e3o consiga, tente cri\u00e1-lo e abr\u00ed-lo. Com arquivo aberto, leia um vetor A de inteiros de tamanho 20 e guarde seus valores em um arquivo, um por linha. Em seguida, reabra o arquivo e leia os elementos para o vetor B, verificando se os valores foram gravados corretamente. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa em Linguagem C que receba do usu\u00e1rio um arquivo, e mostre na tela quantas linhas esse arquivo possui. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que receba dois arquivos do usu\u00e1rio, e crie um terceiro arquivo com o conte\u00fado dos dois primeiros juntos (o conte\u00fado do primeiro seguido do conte\u00fado do segundo). \\end{lab}\\] \\[\\begin{lab} Desenvolver um programa em C que l\u00ea o conte\u00fado de um arquivo e cria um arquivo com o mesmo conte\u00fado, mas com todas as letras min\u00fasculas convertidas para mai\u00fasculas. Os nomes dos arquivos ser\u00e3o fornecidos, via teclado, pelo usu\u00e1rio. A fun\u00e7\u00e3o que converte min\u00fascula para mai\u00fascula \u00e9 o toupper(). Ela \u00e9 aplicada em cada caractere da string. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa no qual o usu\u00e1rio informa o nome do arquivo, e uma palavra, e retorne o n\u00famero de vezes que aquela palavra aparece no arquivo. \\end{lab}\\] \\chapter{Navega\u00e7\u00e3o dentro do arquivo} Embora seja poss\u00edvel trabalhar com arquivos usando apenas as ferramentas apresentadas at\u00e9 agora, alguns problemas s\u00e3o de dif\u00edcil resolu\u00e7\u00e3o, a n\u00e3o ser que extendamos nosso conhecimento. Suponha por exemplo que voc\u00ea tenha o seguinte arquivo: \\[\\begin{verbatim} O rato roeu a roupa do rei de Roma e a rainha Ruinha resolveu rir-se pois o rei que remente suas ro\u00eddas roupagens. \\end{verbatim}\\] Observe que todas as linhas tem o mesmo tamanho (22 caracteres) e que a palavra ``remende'' est\u00e1 escrita de forma incorreta. Para corrigir esta palavra, podemos reescrever toda a frase, ou posicionar o cursor do arquivo exatamente sobre o caractere errado e corrigi-lo. H\u00e1 v\u00e1rias formas de se fazer isso, como veremos agora. {Posicionamento no arquivo} Como visto no cap\u00edtulo anterior, opera\u00e7\u00f5es de leitura e escrita no arquivo v\u00e3o mudando a posi\u00e7\u00e3o em que as pr\u00f3ximas opera\u00e7\u00f5es ser\u00e3o executadas. Isto \u00e9, se considerarmos que h\u00e1 um cursor dentro do arquivo, na posi\u00e7\u00e3o em escreveremos, caso uma escrita seja feita, ou leremos, caso uma leitura seja executada, ent\u00e3o se lermos ou escrevermos 3 caracteres, ent\u00e3o o cursor ``andar\u00e1'' 3 caracteres. Se quisermos colocar o cursor no fim do arquivo, podemos reabr\u00ed-lo usando \\lstinline|ios::app|. Caso queiramos colocar o cursor no come\u00e7o do arquivo, podemos simplesmente reabri-lo sem especificar qualquer op\u00e7\u00e3o ou usando \\lstinline|ios::trunc| (e com isso tamb\u00e9m zerarmos nosso arquivo). Caso precisemos posicionar o cursor no meio do arquivo, podemos usar a fun\u00e7\u00e3o \\lstinline|seekg|, que pode ser usada duas formas: \\begin{verbatim} seekg(nova posi\u00e7\u00e3o [em bytes]) seekg(diferen\u00e7a [em bytes] em rela\u00e7\u00e3o ao marco, marco) \\end{verbatim} Na primeira forma voc\u00ea pode especificar onde o cursor deve ser posicionado em rela\u00e7\u00e3o ao in\u00edcio do arquivo, em n\u00famero de bytes. Por exemplo, \\lstinline|arq.seekg(10)| posiciona o cursor no d\u00e9cimo byte do arquivo \\lstinline|arq|. J\u00e1 pela segunda forma, voc\u00ea especifica onde posicionar o cursor em rela\u00e7\u00e3o a um marco no arquivo, que pode ser seu in\u00edcio (\\lstinline|ios_base::beg|), fim (\\lstinline|ios_base::end|), ou posi\u00e7\u00e3o atual (\\lstinline|ios_base::cur|). A diferen\u00e7a em rela\u00e7\u00e3o ao marco \u00e9 especificada como um inteiro com sinal. Por exemplo, \\lstinline|arq.seekg(-10,ios_base::end)| posiciona o cursor no d\u00e9cimo caractere \\emph{antes do fim} do arquivo \\lstinline|arq|. Para resolver o problema apresentado acima, podemos ent\u00e3o usar as seguintes solu\u00e7\u00f5es. \\begin{lstlisting} include include using namespace std; int main() { fstream arq; arq.open(\"arquivo.txt\"); //Posicionando o cursor no inicio. arq.seekg(23*3+20); arq << 'd'; arq.close(); arq.open(\"arquivo.txt\"); //Buscando a partir do fim. arq.seekg(-23-3, ios_base::end); arq << 'd'; arq.close(); arq.open(\"arquivo.txt\", ios::out | ios::trunc); //Recriando o arquivo. arq << \"O rato roeu a roupa do\" << endl << \"rei de Roma e a rainha\" << endl << \"Ruinha resolveu rir-se\" << endl << \"pois o rei que remende\" << endl << \"suas roidas roupagens.\"; arq.close(); return 0; } \" \\end{lstlisting} {Arquivos formatados} Para que se possa movimentar o cursor dentro de um arquivo, \u00e9 importante que se conhe\u00e7a a estrutura do mesmo, principalmente se pretender sobrescrev\u00ea-lo sem destru\u00ed-lo. Por exemplo, considere o seguinte problema. Escrever um programa que leia matr\u00edcula e nome de alunos do curso de Engenharia Qu\u00edmica e armazene estas informa\u00e7\u00f5es em um arquivo. Em seguida, seu programa deve escrever todas as informa\u00e7\u00f5es na tela, precedidas por um n\u00famero identificando cada aluno. Finalmente, o programa deve ler n\u00fameros correspondentes a alunos e sobrescrever os dados do aluno com novas informa\u00e7\u00f5es. \\begin{lstlisting} include include define NOME_ARQ \"arquivo.txt\" using namespace std; bool mais_info() { char resp = 'x'; cout << \"Entrar com mais informacoes? (s/n)\"; while(true) { cin >> resp; switch(resp) { case 's': case 'S': return true; case 'n': case 'N': return false; } } } void ler_aluno(char mat[], int tmat, char nome[], int tnome) { cin.ignore(1000,'\\n'); cin.clear(); cout << \"Digite a matricula (max \" << tmat-1 << \" caracteres:)\"; cin.getline(mat,tmat); cout << \"Digite o nome (max \" << tnome-1 << \" caracteres\"; cin.getline(nome,tnome); } int main() { fstream arq; int totalcount = 0; int count; char linha[1000]; char mat[15]; char nome[100]; arq.open(NOME_ARQ); if(! arq.is_open()) arq.open(NOME_ARQ, ios::in | ios::out | ios::trunc); while(mais_info()) { ler_aluno(mat, 15, nome, 100); arq << mat << \" \" << nome << endl; } count = 1; arq.clear(); arq.seekg(0); cout << \"Dados atuais\" << endl; while(arq.getline(linha,1000)) { cout << count++ << \" - \"<< linha << endl; totalcount++; } while(mais_info()) { cout << \"Sobrescrever qual linha?\"; cin >> count; if(count > totalcount) { cout << \"Linha nao existente\"; } else { ler_aluno(mat, 15, nome, 100); arq.clear(); arq.seekg(0); while(count > 1) { arq.getline(linha,1000); count--; } arq << mat << \" \" << nome << endl; } } arq.clear(); count = 1; arq.seekg(0, arq.beg); cout << \"Dados atuais\" << endl; while(arq.getline(linha,1000)) { cout << count++ << \" - \"<< linha << endl; } return 0; } \\end{lstlisting} Este c\u00f3digo possui duas particularidades. Primeiro, ele usa a fun\u00e7\u00e3o \\lstinline|arq.clear()|, ainda n\u00e3o mencionada e, segundo, ele est\u00e1 errado. Toda vez que o arquivo \u00e9 lido at\u00e9 o seu fim, seu estado interno \u00e9 mudado para identificar o fato. Isto \u00e9 verific\u00e1vel pela fun\u00e7\u00e3o \\lstinline|arq.eof()|, que testa se o arquivo chegou ao \\emph{end of file}. Quando isso \u00e9 verdade, as fun\u00e7\u00f5es de reposicionamento n\u00e3o funcionar\u00e3o, a n\u00e3o ser que este status seja reiniciado, o que \u00e9 feito com a fun\u00e7\u00e3o \\lstinline|clear()|. No c\u00f3digo simplesmente usamos esta fun\u00e7\u00e3o sempre que formos fazer um \\emph{seek}, por simplicidade. Sobre o c\u00f3digo n\u00e3o funcionar como esperado, execute-o e insira um aluno apenas, com matr\u00edcula \"aaaaaaaaaa\" e nome \"bbbbbbbbbb\". Em seguida, altere os dados da linha 1 e insira matr\u00edcula \"cc\" e nome \"dd\". Ao final, os dados impressos ser\u00e3o os seguintes: \\[\\begin{verbatim} Dados atuais 1 - cc dd 2 - aaaa bbbbbbbbbb \\end{verbatim}\\] {Exerc\u00edcios} {} Corrija o programa exemplo mostrado acima para que escreva sempre linhas de um mesmo tamanho e que, portanto, n\u00e3o tenha o problema de fragmenta\u00e7\u00e3o de registros. \\[\\begin{tabular}{l-l} ios::ate & Posiciona no fim do arquivo. Se n\u00e3o for usado, \u00e9 posicionado no in\u00edcio.\\\\ \\end{tabular}\\] {Arquivos bin\u00e1rios} \\[\\begin{tabular}{l-l} ios::binary & Modo n\u00e3o formatado. (Pr\u00f3ximo cap\u00edtulo)\\\\ \\end{tabular}\\] O argumento \\lstinline{nome_do_arquivo} \u00e9 o caminho do arquivo que se deseja abrir, e \\lstinline{modo_de_abertura} representa como o arquivo ser\u00e1 aberto, de acordo com a tabela a seguir: \\begin{table}[h] \\centering \\begin{tabular}{|c|l|}\\hline \\textbf{Modo} & \\textbf{Descri\u00e7\u00e3o}\\\\hline r & Abre arquivo texto somente para leitura\\\\hline w & Cria arquivo texto somente para escrita\\\\hline a & Anexa dados a um arquivo texto\\\\hline r+ & Abre arquivo texto para leitura e escrita\\\\hline w+ & Cria arquivo onde poder\u00e3o ser realizadas leituras e escritas\\\\hline a+ & Anexa dados a um arquivo texto ou cria um para leitura e escrita\\\\hline \\end{tabular} \\caption{Modos de abertura de arquivo texto em C.} \\label{tab:fopen_modes} \\end{table} \\subsubsection{Fechamento de Arquivo} Um arquivo aberto sempre deve ser fechado antes do fim do programa. A fun\u00e7\u00e3o que realiza essa tarefa \u00e9 \\lstinline{fclose}. Seu prot\u00f3tipo \u00e9: \\lstinline{int fclose(FILE *arq);} O argumento \\lstinline{arq} \u00e9 a vari\u00e1vel que representa o arquivo aberto (com \\lstinline{fopen}) O retorno dessa fun\u00e7\u00e3o \u00e9 zero em caso de sucesso. Qualquer valor diferente de zero, significa erro. \\subsubsection{Leitura e Escrita de Arquivo} A fun\u00e7\u00e3o \\lstinline{fputc} escreve um caractere em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fputc(char ch, FILE *arq);| A fun\u00e7\u00e3o \\lstinline{fputs} escreve um cadeia de caracteres em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|char *fputs(char *cadeia, FILE *arq);| A fun\u00e7\u00e3o \\lstinline{fgetc} l\u00ea um caractere em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fgetc(FILE *arq);| A fun\u00e7\u00e3o \\lstinline{fgets} l\u00ea um cadeia de caracteres em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|char *fgets(char *cadeia, int tam, FILE *arq);|, onde \\lstinline{tam} define o tamanho da cadeia que ser\u00e1 lida: tam-1 ou fim de linha, o que ocorrer primeiro. A fun\u00e7\u00e3o \\lstinline{fprintf} permite escrever em um arquivo da mesma forma que escrevemos na tela com o \\lstinline{printf}. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fprintf(FILE *arq, char *formato, ...);| A fun\u00e7\u00e3o \\lstinline{fscanf} l\u00ea informa\u00e7\u00f5es de um arquivo da mesma forma que lemos do teclado com o \\lstinline{scanf}. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fscanf(FILE *arq, char *formato, ...);| \\subsubsection{Exemplos} \\begin{lstlisting} include include int main(){ FILE *arq; char nome1[20], nome2[20], linha[20]; arq = fopen(\"teste.txt\", \"w\"); printf(\"entre nome1: \"); scanf(\"%s\", nome1); printf(\"entre nome2: \"); scanf(\"%s\", nome2); fputs(nome1, arq); fputs(\"\\n\", arq); fputs(nome2, arq); fclose(arq); arq = fopen(\"teste.txt\", \"r\"); printf(\"lendo do arquivo:\\n\"); fgets(linha, 20, arq); printf(\"\\tnome1: %s\", linha); fgets(linha, 20, arq); printf(\"\\tnome2: %s\\n\", linha); return 0; } \\end{lstlisting} \\begin{lstlisting} include include int main(){ FILE *arq; char nome1[20], nome2[20], linha[20]; arq = fopen(\"teste.txt\", \"w\"); printf(\"entre nome1: \"); scanf(\"%s\", nome1); printf(\"entre nome2: \"); scanf(\"%s\", nome2); fprintf(arq, \"%s\\n%s\", nome1, nome2); fclose(arq); arq = fopen(\"teste.txt\", \"r\"); printf(\"lendo do arquivo:\\n\"); fscanf(arq, \"%s\", nome1); fscanf(arq, \"%s\", nome2); printf(\"nome1: %s\\nnome2: %s\\n\", nome1, nome2); return 0; } \\end{lstlisting} \\part{Avan\u00e7ado: Estruturas de dados} \\chapter{Aloca\u00e7\u00e3o Din\u00e2mica} Aloca\u00e7\u00e3o de arranjos multi-dimensionais (caso n\u00e3o cont\u00edguo) \\chapter{BigNum} Lembrar limites de vari\u00e1veis n\u00famericas. Implementando fun\u00e7\u00f5es para manipula\u00e7\u00e3o de n\u00fameros gigantescos. \\chapter{Listas} \\chapter{Filas} \\chapter{Pilhas} \\chapter{\u00c1rvores}","title":"O computador \u00e9 uma m\u00e1quina burra"},{"location":"intro/#o-computador-e-uma-maquina-burra","text":"Computadores s\u00e3o m\u00e1quinas \"burras\" que n\u00e3o fazem nada al\u00e9m de seguir instru\u00e7\u00f5es. Sendo assim, eles precisam de instru\u00e7\u00f5es precisas e detalhadas sobre o que fazer. Agora que est\u00e1 ciente deste fato, voc\u00ea est\u00e1 pronto para entender que quando o programa n\u00e3o fizer o que voc\u00ea quer, \u00e9 por que voc\u00ea lhe deu instru\u00e7\u00f5es erradas. Para que n\u00e3o cometamos erros (ou pelo menos para minimiz\u00e1-los), ao montar a sequ\u00eancia de instru\u00e7\u00f5es que resolvem determinado problema precisamos, antes de qualquer outra coisa, entender o problema e sermos capazes de resolv\u00ea-lo ``na m\u00e3o''. Uma vez que tenhamos uma solu\u00e7\u00e3o teremos o que chamamos de um \\emph{algoritmo}\\footnote{\\url{ http://www.merriam-webster.com/dictionary/algorithm }}.","title":"O computador \u00e9 uma m\u00e1quina burra"},{"location":"intro/#algoritmo","text":"Um algoritmo nada mais \u00e9 que um conjunto de instru\u00e7\u00f5es para se resolver um problema. Por exemplo, para se destrancar uma porta temos o seguinte algoritmo: \\[\\begin{itemize} \\item Coloque a chave na fechadura \\item Gire a chave \\end{itemize}\\] \u00c9 claro que este algoritmo est\u00e1 em um n\u00edvel de abstra\u00e7\u00e3o muito alto e que poderia ser muito mais detalhado. Por exemplo, n\u00e3o h\u00e1 por qu\u00ea destrancar a porta se ela j\u00e1 estiver destrancada e n\u00e3o h\u00e1 como destranc\u00e1-la se n\u00e3o estiver de posse da chave. Quanto mais detalhada sua sequ\u00eancia de passos, mais pr\u00f3ximo de algo intelig\u00edvel ao computador ela ser\u00e1. Para que isto ocorra, isto \u00e9, para que o computador entenda suas intru\u00e7\u00f5es, al\u00e9m de detalhadas, eles precisam ser escritas em uma linguagem de programa\u00e7\u00e3o.","title":"Algoritmo"},{"location":"intro/#linguagem-de-programacao","text":"De acordo com fontes altamente confi\u00e1veis\\footnote{\\url{ http://en.wikipedia.org/wiki/Programming _language}} \\begin{quote} %\\emph{A programming language is an artificial language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs that control the behavior of a machine and/or to express algorithms precisely.} Uma linguagem de programa\u00e7\u00e3o \u00e9 uma linguagem artificial projetada para comunicar instru\u00e7\u00f5es a uma m\u00e1quina, particularmente computadores. Linguagens de programa\u00e7\u00e3o podem ser usadas para criar programas que controlam o comportamento da m\u00e1quina e expressar algoritmos de forma precisa (n\u00e3o amb\u00edgua). \\end{quote} De forma simplificada, uma liguagem de programa\u00e7\u00e3o \u00e9 um conjunto de palavras e regras sobre como us\u00e1-las na descri\u00e7\u00e3o de algoritmos interpret\u00e1veis por um computador. Existem diversas \\footnote{Uma listagem n\u00e3o completa mas ainda assim impressionante pode ser encontrada em \\url{ http://en.wikipedia.org/wiki/Categorical_list_of_programming_languages }} linguagens de programa\u00e7\u00e3o, tendo cada uma seus pontos fortes e fracos; neste curso, usaremos as linguagens C e C++.","title":"{Linguagem de Programa\u00e7\u00e3o}"},{"location":"intro/#a-linguagem-c","text":"A primeira encarna\u00e7\u00e3o da linguagem de programa\u00e7\u00e3o \\href{ http://en.wikipedia.org/wiki/C_(programming_language)}{C } foi desenvolvida no fim da d\u00e9cada de 60, tendo sido extendida, melhorada e padronizada v\u00e1rias vezes depois. A linguagem C++, que extende a linguagem C com diversas funcionalidades como orienta\u00e7\u00e3o a objetos, come\u00e7ou a ser desenvolvida na d\u00e9cada de 70 e, como a linguagem C, tamb\u00e9m passou por v\u00e1rias reformas. Como resultado, hoje temos uma linguagem C++ padronizada que pode ser usada, mesmo que com certa dificuldade, para se programar em v\u00e1rios sistemas operacionais de forma port\u00e1vel. Al\u00e9m disso, a linguagem C++ \u00e9 um super conjunto da linguagem C. Ou seja, todo e qualquer programa em C tamb\u00e9m \u00e9 um programa em C++, mesmo que o oposto n\u00e3o seja verdade. Como j\u00e1 mencionado, neste curso usaremos primariamente a linguagem C. Contudo, uma vez que o objetivo deste curso \u00e9 introduzir o uso do racioc\u00edcio computacional e n\u00e3o aprofundar no uso de determinada linguagem, estudaremos somente os aspectos mais b\u00e1sicos da linguagem C. Al\u00e9m disso, usaremos partes da linguagem C++ para simplificar o desenvolvimento dos nossos programas. Assim, nos referiremos \u00e0 linguagem usada como C(++), pois nem \u00e9 toda a C, e nem \u00e9 somente C, mas n\u00e3o chega a ser C++. Mas chega de ladainha; vamos ao nosso primeiro programa em linguagem C(++)!","title":"{A linguagem C(++)}"},{"location":"intro/#meu-primeiro-programa","text":"O algoritmo em linguagem C(++) \\footnote{Usaremos tamb\u00e9m os termos programa'' e c\u00f3digo'' para nos referirmos a tais algoritmos.}, abaixo, descreve para o computador os passos necess\u00e1rios para se escrever a mensagem Ol\u00e1 Mundo!'' na tela do computador. N\u00e3o se preocupe com os detalhes de como isso \u00e9 feito agora, mas foque-se nos seguintes aspectos: \\begin{itemize} \\item existem v\u00e1rias formas de se dizer Ol\u00e1 Mundo!'', por exemplo se pode saltar antes de faz\u00ea-lo, agaixar, ou fechar os olhos. Todas estas formas s\u00e3o corretas, embora algumas possam lhe causar certo constrangimento quando em p\u00fablico. \\item um c\u00f3digo de computador deve ser entendido, al\u00e9m de pelos computadores, tamb\u00e9m por humanos. Sendo assim, \u00e9 imprescind\u00edvel que voc\u00ea mantenha o c\u00f3digo organizado. \\item usar acentos em um programa \u00e9 fonte de dores de cabe\u00e7a; melhor simplesmente ignor\u00e1-los em nosso curso. \\end{itemize} \\begin{lstlisting}[caption=Ola Mundo!, label=cod:ola]","title":"{Meu Primeiro Programa}"},{"location":"intro/#include","text":"using namespace std; int main() { cout << \"Ola Mundo!\" << endl; return 0; } \\end{lstlisting} Analisando o C\u00f3digo~\\ref{cod:ola}, podemos facilmente identificar a linha que cont\u00e9m a frase Ola Mundo!''. Esta linha \u00e9 a que efetivamente \\emph{escreve} na tela do computador. Altere esta linha para que contenha, por exemplo, seu nome em vez da palavra \\emph{Mundo}. Digamos que seu nome seja \\emph{Feissibukson}. Este programa agora escreve na tela do computador os dizeres Ola Feissibukson!''. Para entendermos o que as demais linhas fazem, precisamos passar para o nosso pr\u00f3ximo problema/programa.","title":"include "},{"location":"intro/#area-de-um-retangulo","text":"A \u00e1rea de um ret\u00e2ngulo pode ser facilmente calculada caso voc\u00ea saiba o comprimento de sua base e de sua altura. Matematicamente, seja \\(b\\) o comprimento da base e \\(a\\) a altura. A fun\u00e7\u00e3o \\(f\\) equivalente \u00e0 \u00e1rea do ret\u00e2ngulo pode ser definda como: \\(f(a,b) = a*b\\) . Isto \u00e9, a fun\u00e7\u00e3o \\(f\\) tem dois par\u00e2metros (a altura \\(a\\) e base \\(b\\) do ret\u00e2ngulo) e calcula a \u00e1rea como sendo a multiplica\u00e7\u00e3o de \\(a\\) e \\(b\\) . Em linguagem C(++) a fun\u00e7\u00e3o \\(f\\) pode-se escrever esta fun\u00e7\u00e3o como mostrado no C\u00f3digo~\\ref{cod:area}, que analisaremos em seguida. \\[\\begin{lstlisting}[caption=\u00c1rea de um ret\u00e2ngulo, label=cod:area] int f(int a, int b) { return a * b; } \\end{lstlisting}\\] A linha 1 do c\u00f3digo define a fun\u00e7\u00e3o \\verb|f| como uma fun\u00e7\u00e3o que aceita dois par\u00e2metros \\lstinline!a! e \\lstinline!b!. Al\u00e9m disso, esta fun\u00e7\u00e3o tamb\u00e9m define que cada um destes par\u00e2metros \u00e9 um n\u00famero inteiro ao preceder cada par\u00e2metro pela palavra \\lstinline!int!. Finalmente, esta linha tamb\u00e9m define que o resultado da fun\u00e7\u00e3o ser\u00e1 um n\u00famero inteiro ao preceder o nome da fun\u00e7\u00e3o (\\lstinline!f!) pela palavra \\lstinline!int!. Isto quer dizer que voc\u00ea n\u00e3o pode usar esta fun\u00e7\u00e3o para calcular a \u00e1rea de ret\u00e2ngulos cujos lados n\u00e3o sejam inteiros. Mas n\u00e3o se preocupe, corrigiremos esta defici\u00eancia daqui a pouco. As linhas 2 e 4 definem o \\emph{corpo da fun\u00e7\u00e3o}, isto \u00e9, quais outras linhas s\u00e3o partes da fun\u00e7\u00e3o \\lstinline!f!. Toda fun\u00e7\u00e3o na linguagem C precisa ter definido seu come\u00e7o e fim usando \\lstinline!{! e \\lstinline!}!, respectivamente. A linha 3 do c\u00f3digo \u00e9 onde o c\u00e1lculo da \u00e1rea \u00e9 efetivamente executado: \\lstinline!a*b!. Al\u00e9m disso, esta linha define tamb\u00e9m qual \u00e9 o resultado da fun\u00e7\u00e3o ao preceder o resultado da multiplica\u00e7\u00e3o por \\lstinline!return!. Como a multiplica\u00e7\u00e3o de dois n\u00fameros inteiros s\u00f3 pode resultar em um n\u00famero inteiro, o resultado da fun\u00e7\u00e3o tamb\u00e9m \u00e9 inteiro, est\u00e1 justificado o tipo da fun\u00e7\u00e3o ser \\lstinline|int|.","title":"{\u00c1rea de um Ret\u00e2ngulo}"},{"location":"intro/#tipos-primitivos-da-linguagem-c","text":"O C\u00f3digo~\\ref{cod:area}, como mencionado, tem a limita\u00e7\u00e3o de s\u00f3 calcular a \u00e1rea de ret\u00e2ngulos cujos lados tenham tamanhos inteiros. Para corrigir esta defici\u00eancia, vamos alter\u00e1-lo para que aceite n\u00fameros reais. Em computa\u00e7\u00e3o, n\u00fameros reais s\u00e3o tamb\u00e9m chamados de n\u00fameros com \\emph{pontos flutuantes} e, em linguagem C, simplesmente de \\lstinline!float!. Sendo assim, podemos corrigir o programa simplesmente substituindo as ocorr\u00eancias da palavra \\lstinline!int! por \\lstinline!float!, resultando no C\u00f3digo~\\ref{cod:area1} \\[\\begin{lstlisting}[caption=\u00c1rea de ret\u00e2ngulo com dimens\u00f5es reais., label=cod:area1] float f(float a, float b) { return a * b; } \\end{lstlisting}\\] Pronto, a fun\u00e7\u00e3o agora \\emph{recebe} dois par\u00e2metros do tipo \\verb|float| e \\emph{retorna} um resultado tamb\u00e9m deste tipo. Juntamente com outros tipos que ser\u00e3o vistos adiante no curso, \\verb|int| e \\verb|float| s\u00e3o chamados de tipos de dados primitivos da linguagem. Isto sugere, obviamente, que h\u00e1 tamb\u00e9m tipos n\u00e3o primitivos, e nada poderia ser mais verdade. Estes tipos, contudo, s\u00f3 ser\u00e3o vistos bem mais adiante no curso, no Cap\u00edtulo~?\\todo{Adicionar refer\u00eancia}.","title":"{Tipos Primitivos da Linguagem C}"},{"location":"intro/#organizacao-do-codigo","text":"\u00c9 poss\u00edvel facilmente perceber um padr\u00e3o nos exemplos de c\u00f3digo apresentados at\u00e9 agora: \\begin{itemize} \\item A linha definindo a fun\u00e7\u00e3o \u00e9 seguida por uma linha contendo apenas um \\verb|{| que \u00e9 alinhado com o in\u00edcio da linha acima. \\item A \u00faltima linha da fun\u00e7\u00e3o cont\u00e9m apenas um \\verb|}|, alinhado com o \\verb|{| do in\u00edcio da fun\u00e7\u00e3o. \\item Todas as linhas entre o \\verb|{| inicial e o \\verb|}| final est\u00e3o alinhas e mais avan\u00e7adas em rela\u00e7\u00e3o \u00e0s chaves. \\end{itemize} Esta organiza\u00e7\u00e3o do c\u00f3digo serve para facilitar a leitura do c\u00f3digo, uma vez que torna extremamente \u00f3bvio onde a fun\u00e7\u00e3o come\u00e7a e termina. Esta t\u00e9cnica \u00e9 chamada \\emph{indenta\u00e7\u00e3o}. Algo que faltou nestes exemplos e que tamb\u00e9m serve ao prop\u00f3sito de facilitar o entendimento do c\u00f3digo s\u00e3o os chamados coment\u00e1rios. O exemplo no C\u00f3digo~\\ref{cod:comment} mostra como a fun\u00e7\u00e3o \\verb|f| poderia ser comentada. \\[\\begin{lstlisting}[caption={\u00c1rea do ret\u00e2ngulo, com coment\u00e1rios.}, label=cod:comment] /* * A funcao a seguir calcula a area de um retangulo de base * b e altura a. Os parametros e resultado da funcao sao do * tipo float. */ float f(float a, float b) { //Calcula e retorna a area do retangulo. return a * b; } \\end{lstlisting}\\] Observe que h\u00e1 dois tipos de coment\u00e1rios no c\u00f3digo. O primeiro come\u00e7a com \\verb|*| e termina com \\verb|*| e o segundo come\u00e7a com \\verb|\\| e termina no final da linha. Todos os coment\u00e1rios servem somente ao programador e s\u00e3o completamente ignorados pelo computador. Os coment\u00e1rios podem ser poderosos aliados na hora de procurar por erros no seu c\u00f3digo, uma vez que permitem desabilitar trechos do mesmo. Finalmente, \u00e9 muito importante nomear suas fun\u00e7\u00f5es e par\u00e2metros com nomes intuitivos. Seguindo esta orienta\u00e7\u00e3o, escreveremos a \u00faltima vers\u00e3o de nossa fun\u00e7\u00e3o. \\[\\begin{lstlisting}[caption={\u00c1rea do ret\u00e2ngulo, com coment\u00e1rios e nomes intuitivos.}, label=cod:intui] /* * A funcao a seguir calcula a area de um retangulo de base * base e altura altura. Os parametros e resultado da funcao * sao do tipo float. */ float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } \\end{lstlisting}\\]","title":"{Organiza\u00e7\u00e3o do C\u00f3digo}"},{"location":"intro/#saida-de-dados","text":"Em computa\u00e7\u00e3o, diz-se que um programa est\u00e1 executando a sa\u00edda de dados quando envia para ``fora'' do programa tais dados. Exemplos comuns de sa\u00edda de dados s\u00e3o a escrita em arquivo, o envio de mensagens na rede ou, o mais comum, a exibi\u00e7\u00e3o de dados na tela. Em nossos programas, a sa\u00edda de dados efetuada mais comumente ser\u00e1 para a tela do computador. Este tipo de sa\u00edda, por ser t\u00e3o comum, \u00e9 chamada de a sa\u00edda padr\u00e3o do C(++), ou simplesmente \\emph{C out}. Para enviar dados para a sa\u00edda do C(++), usamos a express\u00e3o \\lstinline|cout <<|, seguido do dado a ser impresso na tela. Por exemplo, para imprimir a mensagem ``Ol\u00e1 Jo\u00e3o'', simplesmente adicionamos \\lstinline|cout << \"Ola Joao\"| ao c\u00f3digo. Observe que o simbolos \\lstinline|<<| funciona como uma seta dizendo para onde os dados devem, neste caso, \\lstinline|cout|. \u00c9 poss\u00edvel enviar v\u00e1rios tipos de dados para a sa\u00edda, como veremos no decorrer do curso. No caso da tela, os dados s\u00e3o convertidos para sua forma textual, para que possam ser lidos pelo usu\u00e1rio. O computador realiza a convers\u00e3o de acordo com o tipo original do dado: se o dado j\u00e1 for um texto, ele \u00e9 simplesmente copiado para a tela; se for um n\u00famero, ele \u00e9 convertido para um conjunto de d\u00edgitos que o represente. Por exemplo, o trecho de programa \\begin{lstlisting} cout << \"numero \"; cout << 10; \\end{lstlisting} gera a sa\u00edda \\verb|numero 10| na tela. Observe que a palavra \\lstinline|numero| no programa aparece entre aspas duplas e que o numero 10. Isto ocorre por qu\u00ea \\lstinline|numero| \u00e9 um texto, e \\lstinline|10| \u00e9 um n\u00famero; todos os textos devem ser colocados entre aspas duplas, para que o computador o identifique como tal, mas o mesmo n\u00e3o \u00e9 necess\u00e1rio para n\u00fameros. Veja bem, o n\u00famero \\lstinline|10| \u00e9 bem difernte de \\lstinline|\"10\"| pois, por exemplo, \\lstinline|10| pode ser somado a outro n\u00famero (\\lstinline|10 + 32|), mas \\lstinline|\"10\"| n\u00e3o. Para simplificar a sa\u00edda de dados, em C(++) \u00e9 poss\u00edvel encadear v\u00e1rias sa\u00eddas em uma s\u00f3, assim \\begin{lstlisting} cout << \"numero \" << 10; \\end{lstlisting} com o mesmo efeito do c\u00f3digo anterior. Se houver necessidade de se iniciar nova linha na ``impress\u00e3o'' na tela, basta enviar \\lstinline|endl| (contra\u00e7\u00e3o de \\emph{end line}) para a sa\u00edda. Assim, o c\u00f3digo \\begin{lstlisting} cout << \"numero \" << 10 << endl << \"texto \" << endl; \\end{lstlisting} imprime na tela o texto \\begin{verbatim} numero 10 texto \\end{verbatim} Finalmente, quando uma ``chamada'' a uma fun\u00e7\u00e3o \u00e9 enviada para o \\lstinline|cout|, o que \u00e9 impresso \u00e9 o resultado da fun\u00e7\u00e3o. Assim, \\begin{lstlisting} cout << \"sen(1)\" << endl << sen(1); \\end{lstlisting} imprime na tela o texto \\begin{verbatim} sen(1) 0 \\end{verbatim} Voc\u00ea ver\u00e1 v\u00e1rios exemplos de usos do \\lstinline|cout| na pr\u00f3xima se\u00e7\u00e3o.","title":"{Sa\u00edda de Dados}"},{"location":"intro/#a-funcao-textttmain","text":"Que o computador \u00e9 uma m\u00e1quina burra e executa somente o que voc\u00ea manda voc\u00ea j\u00e1 deve ter entendido, mas como mand\u00e1-lo executar algo? Em linguagem C(++), o computador \\emph{sempre} come\u00e7a a execu\u00e7\u00e3o de um c\u00f3digo pela fun\u00e7\u00e3o \\verb|main|, a fun\u00e7\u00e3o principal. Sendo assim, se voc\u00ea quer dizer ao computador que calcule a \u00e1rea de um ret\u00e2ngulo, ent\u00e3o esta ordem dever partir, de alguma forma, da fun\u00e7\u00e3o \\verb|main|. Para um exemplo,veja o seguinte c\u00f3digo. \\begin{lstlisting}","title":"{A Fun\u00e7\u00e3o \\texttt{main}}"},{"location":"intro/#include_1","text":"using namespace std; /* * A funcao a seguir calcula a area de um retangulo de base * base e altura altura. Os parametros e resultado da funcao * sao do tipo float. */ float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { //Calculemos a area de alguns retangulos. cout << area_retangulo(3.3, 2.0) << endl; cout << area_retangulo(2.0, 2.0) << endl; //Lembre-se, todo numero inteiro tambem e um numero real. cout << area_retangulo(4, 2) << endl; return 0; } \\end{lstlisting} Algumas observa\u00e7\u00f5es importantes sobre a fun\u00e7\u00e3o \\verb|main|: \\begin{enumerate} \\item A fun\u00e7\u00e3o \\verb|main| tem sempre um resultado do tipo inteiro e seu resultado \u00e9 sempre 0 (\\verb|return 0;|)\\footnote{Na verdade, nem nem sempre \u00e9 0, mas por enquanto definiremos sempre assim.} \\item Fun\u00e7\u00e3o \\verb|main| \u00e9 como um \\emph{highlander}: s\u00f3 pode haver uma! Isto \u00e9, cada programa s\u00f3 pode conter a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o com este nome. Ali\u00e1s, a regra vale para toda e qualquer fun\u00e7\u00e3o; se n\u00e3o fosse assim, o computador n\u00e3o saberia a qual fun\u00e7\u00e3o voc\u00ea est\u00e1 se referindo em seu c\u00f3digo. \\item Finalmente, a fun\u00e7\u00e3o \\verb|area_retangulo| aparece antes da fu\u00e7\u00e3o \\verb|main| no programa. Isto deve ser verdade para todas as fun\u00e7\u00f5es do seu programa. Isto ocorre por qu\u00ea, antes de executar a fun\u00e7\u00e3o \\verb|main|, o computador precisa aprender sobre a exist\u00eancia das outras fun\u00e7\u00f5es. \\end{enumerate} O c\u00f3digo como est\u00e1, includindo as duas linhas iniciais que ainda n\u00e3o sabem para que servem, pronto'' para ser executado no seu computador. No pr\u00f3ximo cap\u00edtulo veremos exatamente como fazer isso. At\u00e9 l\u00e1, executemos o c\u00f3digo na m\u00e3o'': \\begin{itemize} \\item O programa come\u00e7a a executar pela fun\u00e7\u00e3o \\lstinline|main|; somente o que est\u00e1 no corpo desta fun\u00e7\u00e3o \u00e9 executado. \\item Na linha 18 n\u00e3o h\u00e1 o que executar, pois \u00e9 s\u00f3 um coment\u00e1rio. \\item Na linha 19, como vimos no C\u00f3digo~\\ref{cod:ola}, est\u00e1 se dizendo para o computador escrever algo na tela. Este algo \u00e9 o resultado da aplica\u00e7\u00e3o da fun\u00e7\u00e3o \\lstinline|area_retangulo| aos par\u00e2metros 3.3 e 2.0.\\footnote{Observe o uso de .'' como separador de casas decimais.}. Para que se conhe\u00e7a este resultado, o programa executa a fun\u00e7\u00e3o \\lstinline|area_retangulo|. \\item A linha 13 calcula a \u00e1rea do ret\u00e2ngulo, que \u00e9 ent\u00e3o retornado para a linha 19. \\item Na linha 19, a \\emph{chamada} da fun\u00e7\u00e3o \u00e9 substitu\u00edda'' pelo resultado, e o n\u00famero 6.6 \u00e9 escrito na tela do computador. Na sequ\u00eancia, \u00e9 escrito tamb\u00e9m \\lstinline|endl|, que faz com que o computador salte para a pr\u00f3xima linha da tela do computador. \\item Na linha 20 o procedimento todo \u00e9 repetido, agora escrevendo o valor 4.0 na tela. \\item Na linha 23 tamb\u00e9m se repete o procedimento, mas agora passando como par\u00e2metro para a fun\u00e7\u00e3o os valores inteiros 4 e 2. Como todo n\u00famero inteiro tamb\u00e9m \u00e9 um n\u00famero real, a fun\u00e7\u00e3o \u00e9 novamente executada e o valor 8.0 \u00e9 impresso na tela. \\end{itemize}","title":"include "},{"location":"intro/#conclusao","text":"Os c\u00f3digos apresentados neste cap\u00edtulo, apesar de simples, ilustraram v\u00e1rios pontos importantes da programa\u00e7\u00e3o de computadores em geral e da linguagem C em espec\u00edfico. Estes pontos podem ser sumarizados assim: \\begin{itemize} \\item Em C(++) pode-se definir fun\u00e7\u00f5es que executem computa\u00e7\u00f5es bem definidas e espec\u00edficas. \\item C(++) tem v\u00e1rios \\emph{tipos} de dados, como \\verb|int| (n\u00fameros inteiros) e \\verb|float| (n\u00fameros reais). \\item \u00c9 importante manter o c\u00f3digo organizado, comentado e indentado. Isso facilita seu entendimento e manuten\u00e7\u00e3o. \\end{itemize}","title":"{Conclus\u00e3o}"},{"location":"intro/#exercicios","text":"\\[\\begin{exercicio} Escreva um fun\u00e7\u00e3o que calcule a \u00e1rea de um c\u00edrculo. Observe que a linguagem C \u00e9 baseada na l\u00edngua inglesa, na qual se separa casas decimais por \\verb|.| e n\u00e3o por \\verb|,|. Logo, $\\Pi$ \u00e9 igual 3.14 e n\u00e3o 3,14. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva uma fun\u00e7\u00e3o que calcule a \u00e1rea de um tri\u00e2ngulo. \\end{exercicio}\\] \\chapter{Compila\u00e7\u00e3o e Execu\u00e7\u00e3o} Para colocarmos nossos algoritmos em execu\u00e7\u00e3o, o primeiro passo \u00e9 escrev\u00ea-los, usando um editor de textos qualquer que salve arquivos em texto puro, como o notepad, vim, gedit, etc. A este arquivo com o \\emph{c\u00f3digo} chamaremos \\emph{c\u00f3digo fonte} ou simplesmente \\emph{fonte}. Uma vez de posse do fonte, \u00e9 preciso submet\u00ea-lo a um processos com v\u00e1rios passos que gera, ao final, um arquivo execut\u00e1vel ou o que chamamos, comumente, de \\emph{programa}. O processo como um todo, descrito na se\u00e7\u00e3o seguinte, \u00e9 conhecido como \\emph{compila\u00e7\u00e3o}, apesar de compila\u00e7\u00e3o ser apenas um dos passos do processo.","title":"{Exerc\u00edcios}"},{"location":"intro/#o-processo-de-compilacao","text":"A sequ\u00eancia de passos que comp\u00f5em a compila\u00e7\u00e3o \u00e9 a seguinte: C\u00f3digo Fonte \\(\\rightarrow\\) Pr\u00e9-processador \\(\\rightarrow\\) Fonte Expandido \\(\\rightarrow\\) Compilador \\(\\rightarrow\\) Arquivo Objeto \\(\\rightarrow\\) Ligador \\(\\rightarrow\\) Execut\u00e1vel De forma simplificada, a pr\u00e9-compila\u00e7\u00e3o \u00e9 um passo que modifica o c\u00f3digo fonte substituindo certas ``palavras chave'' encontradas ao longo do texto por suas defini\u00e7\u00f5es. Por exemplo, pode-se definir que, no programa, toda vez que o pr\u00e9-processador encontrar a palavra PI, ele a substituir\u00e1 por 3.141649. A utilidade da pr\u00e9-compila\u00e7\u00e3o ficar\u00e1 mais clara mais adiante no curso. Uma vez terminada a pr\u00e9-compila\u00e7\u00e3o, acontece a compila\u00e7\u00e3o do seu programa. A compila\u00e7\u00e3o traduz o c\u00f3digo que voc\u00ea escreveu para uma linguagem intelig\u00edvel ao computador, salvando-o em um arquivo chamado arquivo objeto. Por exemplo, a compila\u00e7\u00e3o transformaria o c\u00f3digo ``Ol\u00e1 Mundo!'' escrito acima em algo como % http://farid.hajji.name/blog/2009/12/26/hello-world-in-freebsd-assembler/ \\begin{verbatim} ... CALL write(0x1,0x400623,0xe) GIO fd 1 \"Ol\u00e1 Mundo!\" RET ... \\end{verbatim} Ap\u00f3s a compila\u00e7\u00e3o vem a \\emph{linkedi\u00e7\u00e3o}, o passo que junta o seu arquivo objeto a outros arquivos objetos interessantes, como por exemplo um que contenha c\u00f3digo de fun\u00e7\u00f5es matem\u00e1ticas, manipula\u00e7\u00e3o de arquivos, ou intera\u00e7\u00e3o gr\u00e1fica com o usu\u00e1rio.\\footnote{Embora a explica\u00e7\u00e3o dada aqui n\u00e3o seja estritamente correta, ela \u00e9 pr\u00f3xima o suficiente da realidade para o escopo deste curso.}","title":"{O processo de compila\u00e7\u00e3o}"},{"location":"intro/#a-ide-codeblocks","text":"Embora a edi\u00e7\u00e3o de um programa possa ser feita em praticamente qualquer editor de textos, h\u00e1 certos editores que s\u00e3o mais adequados a esta tarefa. Tais editores fazem, dentre outras, a coloriza\u00e7\u00e3o das palavras de seu c\u00f3digo de forma a ajud\u00e1-lo a detectar erros e tentam alinhar automaticamente as linhas do seu c\u00f3digo. A inten\u00e7\u00e3o destes editores \u00e9 aumenentar sua produtividade como programador. Outros editores v\u00e3o ainda mais longe e lhe permitem fazer todo o processo de compila\u00e7\u00e3o com um simples \\emph{click} do mouse ou apertar de uma tecla. Estes editores mais completos s\u00e3o conhecidos como \\emph{Integrated Development Environment}, ou simplesmente IDE. No decorrer deste curso consideraremos que o aluno estar\u00e1 usando a IDE \\href{ http://www.Code::Blocks.org}{Code::Blocks }, que \u00e9 gratuita e com vers\u00f5es para Windows, Linux e OSX. Entretanto, qualquer outra IDE ou mesmo a compila\u00e7\u00e3o manual podem ser usados em substitui\u00e7\u00e3o ao Code::Blocks.","title":"{A IDE Code::Blocks}"},{"location":"intro/#criando-um-projeto","text":"Para come\u00e7ar a programar no Code::Blocks, precisamos criar um \\emph{projeto}. Este projeto conter\u00e1 seu c\u00f3digo fonte e, no caso de uma programa\u00e7\u00e3o mais avan\u00e7ada, arquivos de imagens, defini\u00e7\u00f5es de personaliza\u00e7\u00e3o do processo de compila\u00e7\u00e3o, etc. Para criar um projeto no Code::Blocks, clique em \\textbf{File} e, em seguida, \\textbf{New}, \\textbf{Project}. Na tela que se apresenta, voc\u00ea deve escolher o tipo de projeto a ser criado. N\u00e3o se perca nos tipos; escolha \\textbf{Console Application} e ent\u00e3o clique em \\textbf{Go}. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-1.PNG} \\end{center}\\] Na tela seguinte voc\u00ea dever\u00e1 escolher a linguagem de programa\u00e7\u00e3o usada; escolha C++ e clique em \\textbf{Next} para passar para a tela onde dever\u00e1 nomear o seu projeto. Em \\textbf{project title} escreva algo como teste1; em \\textbf{folder to create the project in}, clique no botao com \\ldots e escolha uma pasta para salvar o projeto; esta pode ser, por exemplo, a pasta \\textbf{Meus Documentos} ou uma pasta qualquer em um \\emph{pen drive}.\\footnote{O importante aqui \u00e9 salvar o arquivo em um lugar em que voc\u00ea possa voltar mais tarde para reler.}. Clique ent\u00e3o \\textbf{Next} e, na tela seguinte, clique em \\textbf{Finish}. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-2.PNG} \\end{center}\\] Pronto, seu projeto foi criado. Agora abra o arquivo \\textbf{main.cpp}, que est\u00e1 na pasta \\textbf{sources}, dando um clique duplo no nome do arquivo. Observe que o Code::Blocks criou automaticamente um programa b\u00e1sico. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-3.PNG} \\end{center}\\] Finalmente, clique em \\textbf{build} e ent\u00e3o em \\textbf{build and run}. Parab\u00e9ns, voc\u00ea acaba de executar seu primeiro programa.","title":"{Criando um Projeto}"},{"location":"intro/#depuracao","text":"Todo programa de tamanho consider\u00e1vel, e mesmo aqueles de tamanho diminuto, possuir\u00e3o, ao menos em suas vers\u00f5es iniciais, erros. Por raz\u00f5es hist\u00f3ricas, nos referimos a estes erros por \\emph{bugs}\\todo{Refer\u00eancia para o uso de bug}. Uma das formas de achar os bugs do seu programa \u00e9 fazer com que o computador execute seu programa passo a passo, isto \u00e9, linha a linha, e acompanhar esta execu\u00e7\u00e3o verificando se o programa faz o que voc\u00ea espera. Para experimentarmos a depura\u00e7\u00e3o, processo pelo qual removemos bugs, modifique a mensagem \"Hello world!\" do seu programa para \"Ol\u00e1 !\" e execute novamente o programa (\\textbf{build and run}). Se o programa executou normalmente, voc\u00ea est\u00e1 no caminho certo. Agora, copie toda a linha contendo a mensagem e cole-a v\u00e1rias vezes, substituindo o nome em cada linha. Seu programa deve ficar como no C\u00f3digo~\\ref{cod:olas} \\begin{lstlisting}[label=cod:olas, caption={Programa com v\u00e1rios Hello's.}]","title":"{Depura\u00e7\u00e3o}"},{"location":"intro/#include_2","text":"using namespace std; int main() { cout << \"Hello Joao!\" << endl; cout << \"Hello Jose!\" << endl; cout << \"Hello Joaquim!\" << endl; cout << \"Hello Joselino!\" << endl; cout << \"Hello Asdrubal!\" << endl; return 0; } \\end{lstlisting} Mais uma vez, compile e execute seu programa. Se a execu\u00e7\u00e3o foi bem sucedida, voc\u00ea est\u00e1 pronto para a depura\u00e7\u00e3o. Para depurar, clique ao lado direito do n\u00famero 7 (s\u00e9tima linha do programa), at\u00e9 que uma bolinha vermelha apare\u00e7a, como na figura a seguir. A bolinha vermelha \u00e9, na verdade, um sinal de pare, e diz ao computador que deve, ao executar seu programa, parar ali. \\[\\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/2-4.PNG} \\end{center}\\] Se voc\u00ea for adiante e executar o programa como fizemos at\u00e9 agora, ver\u00e1 que o pare n\u00e3o funcionou. Isto \u00e9 por que o sinal \u00e9 ignorado a n\u00e3o ser que voc\u00ea inicie a execu\u00e7\u00e3o em modo de depura\u00e7\u00e3o. Para fazer isso, clique no menu \\textbf{Debug} e ent\u00e3o em \\textbf{Start} ou, alternativamente, pressione a tecla F8. Observe que a execu\u00e7\u00e3o parou onde voc\u00ea esperava. Agora, clique em \\textbf{Debug} e \\textbf{Next Line} ou aperte F7, no teclado, sucessivamente para ver o que acontece. Observe que cada linha \u00e9 executada e ent\u00e3o a execu\u00e7\u00e3o p\u00e1ra novamente.","title":"include "},{"location":"intro/#o-arquivo-executavel","text":"Agora que voc\u00ea j\u00e1 escreveu programas super interessantes, os compilou e executou, imagine como faria para enviar tais programas a um amigo que n\u00e3o tenha qualquer interesse ou aptid\u00e3o em programa\u00e7\u00e3o. A solu\u00e7\u00e3o \u00e9 simples: mandaremos a este amigo o arquivo execut\u00e1vel do programa. Para faz\u00ea-lo, abra a pasta na qual salvou seu projeto Code::Blocks. Nesta pasta voc\u00ea encontrar\u00e1 um arquivo com extens\u00e3o \\verb|.exe|; este \u00e9 o arquivo execut\u00e1vel que deveria enviar para seu amigo. Quando seu amigo executar este programa, ver\u00e1 exatamente a mesma coisa que voc\u00ea viu quando o fez. Al\u00e9m de ser muito \u00fatil, este procedimento \u00e9 tamb\u00e9m uma \u00f3tima forma de se compartilhar v\u00edrus de computador.","title":"{O Arquivo Execut\u00e1vel}"},{"location":"intro/#exercicios_1","text":"\\[\\begin{exercicio} Escreva o programa completo que calcula a \u00e1rea de v\u00e1rios ret\u00e2ngulos do cap\u00edtulo anterior e execute-o. \\end{exercicio}\\] \\[\\begin{exercicio} Altere seu programa para usar, al\u00e9m da fun\u00e7\u00e3o de c\u00e1lculo de \u00e1rea de um quadrado, as fun\u00e7\u00f5es definidas nos exerc\u00edcios do cap\u00edtulo anterior. \\end{exercicio}\\] \\chapter{Vari\u00e1veis, Entrada / Sa\u00edda e Operadores} A todo momento precisamos representar informa\u00e7\u00e3o do mundo a nossa volta em nossos programas. Essas informa\u00e7\u00f5es, tais como nome, n\u00famero de matr\u00edcula, nota final, temperatura, idade e outras tantas s\u00e3o armazenadas em entidades chamadas vari\u00e1veis. Uma vari\u00e1vel nada mais \u00e9 do que um peda\u00e7o de mem\u00f3ria, no qual se pode ler ou escrever alguma informa\u00e7\u00e3o. A estes peda\u00e7os de mem\u00f3ria podemos dar nomes que nos ajude a lembrar o que exatamente est\u00e1 escrito ali. Por exemplo, se uma vari\u00e1vel guarda a idade de algu\u00e9m, um bom nome seria idade'', enquanto que rataplam'' ou ``var13'' provavelmente ser\u00e3o p\u00e9ssimas escolhas. As altera\u00e7\u00f5es em uma vari\u00e1vel resultam da intera\u00e7\u00e3o com o usu\u00e1rio, isto \u00e9, quando o usu\u00e1rio informa valores para as mesmas em uma opera\u00e7\u00e3o de leitura, ou da avalia\u00e7\u00e3o de express\u00f5es l\u00f3gico-aritm\u00e9ticas (o tipo de c\u00e1lculo nos quais o computador \u00e9 especializado). Neste cap\u00edtulo veremos como criar nossas primeiras vari\u00e1veis e como alterar seus valores por meio da leitura direta do teclado e da utiliza\u00e7\u00e3o de operadores.","title":"{Exerc\u00edcios}"},{"location":"intro/#declaracao-de-variaveis","text":"Na linguagem C, toda vari\u00e1vel deve ser declarada (isto \u00e9, criada) no in\u00edcio do corpo da fun\u00e7\u00e3o que a contem. A declara\u00e7\u00e3o de uma vari\u00e1vel tem pelo menos duas partes: \\begin{description} \\item[Nome:] usado para referenciar a vari\u00e1vel quando se precisa ler ou escrever a mesma; \\item[Tipo:] para que o computador saiba como tratar a informa\u00e7\u00e3o, ele precisa saber de que tipo ela \u00e9, ou seja, se \u00e9 um n\u00famero, ou uma palavra, ou uma caractere, etc; e, \\end{description} Algumas regras simples devem ser seguinda na hora de se nomear uma vari\u00e1vel: \\begin{itemize} \\item o nome s\u00f3 pode conter os caracteres [a-z], [A-Z], [0-9] e o ``_''; e, \\item o nome n\u00e3o pode come\u00e7ar com n\u00fameros. \\end{itemize} Quanto aos tipos usaremos, por enquanto, os seguintes: \\begin{description} \\item[int] representando um n\u00famero inteiro, como por exemplo 3, 4 e -78; \\item[float:] representando um n\u00famero real, com casas decimais separadas por \\emph{ponto}, como por exemplo 3.1416 e -1.2; e \\item[char:] representando um caractere (letra, d\u00edgito, sinal de pontua\u00e7\u00e3o) como por exemplo 5, a, Z, ., e -. \\end{description} S\u00e3o exemplos de declara\u00e7\u00f5es de vari\u00e1veis v\u00e1lidas: \\begin{lstlisting} int nota1, nota2; float media; char _caractere; \\end{lstlisting} S\u00e3o exemplos de declara\u00e7\u00f5es inv\u00e1lidas: \\begin{lstlisting} int 1nota, 2nota; float #media; char nome completo; \\end{lstlisting}","title":"{Declara\u00e7\u00e3o de Vari\u00e1veis}"},{"location":"intro/#atribuicao-e-uso","text":"Como j\u00e1 dito, uma vari\u00e1vel \u00e9 um peda\u00e7o da mem\u00f3ria do computador no qual se pode escrever'' e ler'' dados. Em vez de ``escrever'', contudo, no mundo da computa\u00e7\u00e3o usamos a express\u00e3o \\emph{atribuir um valor a uma vari\u00e1vel} para significar a mudan\u00e7a do valor da vari\u00e1vel. Esta opera\u00e7\u00e3o \u00e9 executada pelo operador de atribui\u00e7\u00e3o \\verb|=|. Por exemplo, o seguinte c\u00f3digo declara tr\u00eas vari\u00e1veis num\u00e9ricas, duas inteiras e uma real, e, em seguida, lhes atribui os valores \\verb|0|, \\verb|10| e \\verb|10.0|. \\begin{lstlisting} int inteiro1, inteiro2; float real; inteiro1 = 0; inteiro2 = 10; real = 10.0; \\end{lstlisting} A mem\u00f3ria do computador sempre tem algum dado, tenha ele sido colocado por voc\u00ea ou n\u00e3o, seja ele relevante ou n\u00e3o. Logo, para se usar o conte\u00fado de uma vari\u00e1vel, \u00e9 necess\u00e1rio ter certeza de que a mesma cont\u00e9m um valor que fa\u00e7a sentido. Isto \u00e9, algo que tenha sido atribu\u00eddo pelo seu programa \u00e0quela vari\u00e1vel, via uma opera\u00e7\u00e3o de leitura, via uma computa\u00e7\u00e3o qualquer, ou via uma atribui\u00e7\u00e3o como a do exemplo anterior. Denominamos a primeira atribui\u00e7\u00e3o de um valor a uma vari\u00e1vel de \\emph{inicia\u00e7\u00e3o} (ou \\emph{inicializa\u00e7\u00e3o}). E j\u00e1 que qualquer vari\u00e1vel s\u00f3 deve ser usada se tiver sido iniciada, o C(++) permite que as vari\u00e1veis sejam iniciadas j\u00e1 em sua declara\u00e7\u00e3o. Por exemplo, o c\u00f3digo abaixo faz exatamente o que fazia o exemplo anterior, mas de forma mais compacta. \\[\\begin{lstlisting} int inteiro1 = 0, inteiro2 = 10; float real = 10.0; \\end{lstlisting}\\] Observe que se pode iniciar v\u00e1rias vari\u00e1veis do mesmo tipo, declaradas na mesma linha, com valores distintos. Neste caso, note quebra de linha entre as declara\u00e7\u00f5es de \\verb|inteiro1| e \\verb|inteiro2|; ela \u00e9 somente est\u00e9tica, mas ajuda a separar a declara\u00e7\u00e3o e inicia\u00e7\u00e3o das v\u00e1rias vari\u00e1veis. Agora que voc\u00ea viu como declarar e iniciar uma vari\u00e1vel vem a parte f\u00e1cil: us\u00e1-la. Veja como no seguinte exemplo. \\begin{lstlisting}[label={Programa com exemplo de uso de vari\u00e1veis.}, caption=cod:vars]","title":"{Atribui\u00e7\u00e3o e Uso}"},{"location":"intro/#include_3","text":"using namespace std; float area_circulo(float raio) { float PI = 3.14, area; area = PI * raio * raio; return area; } char proxima_letra(char c1) { char c2; c2 = c1 + 1; return c2; } int main() { int r1; float r2; char _c; _c = 'a'; cout << \"O proximo de \" << _c << \" eh \" << proxima_letra(_c) << endl; r1 = 2; r2 = 9.7; cout << \"r = \" << r1 << \", area = \" << area_circulo(r1) << endl; cout << \"r = \" << r2 << \", area = \" << area_circulo(r2) << endl; r1 = 12; r2 = 0.4; cout << \"r = \" << r1 << \", area = \" << area_circulo(r1) << endl; cout << \"r = \" << r2 << \", area = \" << area_circulo(r2) << endl; return 0; } \\end{lstlisting} \u00c9 simples assim: para se usar uma vari\u00e1vel, basta colocar seu nome na express\u00e3o a ser computada. Na linha 9, por exemplo, atribui-se \u00e0 vari\u00e1vel \\lstinline|area| o valor da multiplica\u00e7\u00e3o do conte\u00fado da vari\u00e1vel \\lstinline|PI| por \\lstinline|raio|, ao quadrado. Na linha 10, o resultado da fun\u00e7\u00e3o \u00e9 o conte\u00fado da vari\u00e1vel \\lstinline|area|.","title":"include "},{"location":"intro/#parametros-sao-variaveis","text":"Nos exemplos de programas dos cap\u00edtulos anteriores, voc\u00ea viu como o conte\u00fado de uma par\u00e2metro \u00e9 definido e usado. Por exemplo, os dois par\u00e2metros da fun\u00e7\u00e3o \\verb|area_retangulo|, reproduzida abaixo, s\u00e3o declarados dizendo-se de que tipo eles s\u00e3o e quais s\u00e3o seus nomes. Em seguida, no corpo da fun\u00e7\u00e3o, os par\u00e2metros s\u00e3o usados no c\u00e1lculo da \u00e1rea simplesmente multiplicando-se ``o nome de um pelo nome do outro''; os valores dos par\u00e2metros s\u00e3o aqueles passados na chamada da fun\u00e7\u00e3o. \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { float area; area = area_retangulo(2.0, 2.0); cout << area; return 0; } \\end{lstlisting} Esta semelhan\u00e7a com a declara\u00e7\u00e3o e uso de vari\u00e1veis n\u00e3o \u00e9 coincidental: par\u00e2metros n\u00e3o s\u00e3o mais do que vari\u00e1veis declaradas e iniciadas de uma forma especial. Isto \u00e9, elas declaradas na defini\u00e7\u00e3o da fun\u00e7\u00e3o e s\u00e3o iniciadas atribuindo-se os valores passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, na mesma \u00f3rdem em que s\u00e3o passados. Isto \u00e9, se a fun\u00e7\u00e3o \u00e9 invocada como \\lstinline|area_retangulo(1,2)|, ent\u00e3o 1 \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel/par\u00e2metro \\lstinline|altura| e 2 \u00e0 \\lstinline|base|. Se a fun\u00e7\u00e3o \u00e9 invocada como \\lstinline|area_retangulo(X,y)|, ent\u00e3o o valor da vari\u00e1vel X, seja l\u00e1 qual for \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel/par\u00e2metro \\lstinline|altura| e de y \u00e0 \\lstinline|base|.","title":"{Par\u00e2metros s\u00e3o Vari\u00e1veis}"},{"location":"intro/#entrada-saida","text":"Al\u00e9m da escrita ou impress\u00e3o de dados na tela, vista no Cap\u00edtulo\\ref{cap:introducao}, uma das tarefas mais comuns em programa\u00e7\u00e3o \u00e9 a leitura de valores informados pelo usu\u00e1rio. A seguir veremos o comando que nos permitem executar tal tarefas.","title":"{Entrada / Sa\u00edda}"},{"location":"intro/#leitura","text":"De forma semelhante ao \\verb|cout|, h\u00e1 um comando para leitura denominado \\verb|cin|. Este comando permite ler valores digitados pelo usu\u00e1rio atualizando a(s) vari\u00e1vel(is) passada(s) para o \\verb|cin| por meio do conector \\verb|>>|. A seguir temos um exemplo de entrada de dados: \\begin{lstlisting} char letra; int idade; cout << \"Informe a letra inicial de seu nome e sua idade: \"; // a seguir eh feita a leitura cin >> letra >> idade; cout << \"A letra eh \" << letra; cout << \" e sua idade eh \" << idade << endl; \\end{lstlisting}","title":"{Leitura}"},{"location":"intro/#impressao","text":"Complementando o que j\u00e1 vimos sobre o \\verb|cout|, vejamos como escrever o conte\u00fado de vari\u00e1veis na tela: \\begin{itemize} \\item Vari\u00e1veis e chamadas de fun\u00e7\u00f5es aparecem diretamente tamb\u00e9m, e seus valores (e resultado) \u00e9 que s\u00e3o colocados na sa\u00edda. \\end{itemize} A seguir, podemos ver alguns exemplos: \\begin{lstlisting} char letra = 'a'; int num = 2; cout << \"letra = \" << letra << endl << \"num = \" << num << endl; \\end{lstlisting} que gera a seguinte sa\u00edda: \\begin{lstlisting} letra = a num = 2 \\end{lstlisting} Agora que voc\u00ea consegue ler do teclado e escrever para a tela, veja como \u00e9 f\u00e1cil fazer um programa que calcule a \u00e1rea de ret\u00e2ngulo cujos lados s\u00e3o digitados pelo usu\u00e1rio. \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { float area, b, a; cout << \"Qual a altura do retangulo?\" << endl; cin >> a; cout << \"Qual a base do retangulo?\" << endl; cin >> b; area = area_retangulo(b, a); cout << area; return 0; } \\end{lstlisting} \\subsubsection{Formata\u00e7\u00e3o de Impress\u00e3o} Em algumas ocasi\u00f5es h\u00e1 necessidade de formatar a sa\u00edda para, por exemplo, garantir que os dados fiquem alinhados, imprimir uma tabela, ou simplesmente por est\u00e9tica. A seguir veremos algumas maneiras de formatar, texto, n\u00fameros inteiros e reais. Para formata\u00e7\u00e3o de texto e n\u00fameros deve-se incluir a biblioteca \\lstinline|iomanip|. A formata\u00e7\u00e3o de texto \u00e9 obtida mediante defini\u00e7\u00e3o da largura do conte\u00fado impresso e do alinhamento. O comando \\lstinline{setw( )}, define a largura do texto impresso para o valor informado como argumento, enquanto os comandos \\lstinline{right} e \\lstinline{left} definem o alinhamento para a direita e esquerda, respectivamente. O efeito do comando \\lstinline|setw| n\u00e3o \u00e9 permamente. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o destes comandos: \\begin{lstlisting}","title":"{Impress\u00e3o}"},{"location":"intro/#include_4","text":"","title":"include "},{"location":"intro/#include_5","text":"using namespace std; float volume_cubo(float aresta) { return aresta*aresta*aresta; } int main() { float a, v; cout << \"Entre valor da aresta do cubo:\" << endl; cin >> a; v = volume_cubo(a); cout << setw(30) << left << \"O volume do cubo eh: \" << v << endl; cout << setfill('-'); cout << setw(30) << left << \"O volume do cubo eh: \" << v << endl; cout << setw(30) << \"O volume do cubo eh: \" << setw(20) << v << endl; cout << setw(30) << \"O volume do cubo eh: \" << setw(20) << right << v << endl; cout << setw(30) << left << \"O volume do cubo eh: \" << v << endl; return 0; } \\end{lstlisting} A execu\u00e7\u00e3o deste c\u00f3digo produz a seguinte sa\u00edda: \\begin{verbatim} Entre valor da aresta do cubo: 2.5 O volume do cubo eh: 15.625 O volume do cubo eh: ---------15.625 O volume do cubo eh: ---------15.625-------------- O volume do cubo eh: -----------------------15.625 O volume do cubo eh: ---------15.625 \\end{verbatim} O comando \\lstinline|setfill| permite definir o caractere que ser\u00e1 usado para preencher os espa\u00e7os restantes, de acordo com a largura definida com \\lstinline|setw| Para formata\u00e7\u00e3o de n\u00fameros reais (\\lstinline{float} e \\lstinline{double}), o exemplo a seguir mostra alguns comandos para formata\u00e7\u00e3o: \\begin{lstlisting}","title":"include "},{"location":"intro/#include_6","text":"","title":"include "},{"location":"intro/#include_7","text":"using namespace std; float volume_cubo(float aresta) { return aresta*aresta*aresta; } int main() { float a, v; cout << \"Entre valor da aresta do cubo:\" << endl; cin >> a; v = volume_cubo(a); cout << \"O volume do cubo eh: \" << v << endl; cout << fixed << setprecision(2); cout << \"O volume do cubo eh: \" << v << endl; cout << fixed << setprecision(4); cout << \"O volume do cubo eh: \" << v << endl; return 0; } \\end{lstlisting} O comando \\lstinline{fixed} determina que o n\u00famero de casas depois decimais ser\u00e1 fixo, enquanto o comando \\lstinline{setprecision} define quantas casas decimais ser\u00e3o impressas. Desta maneira, para o exemplo anterior, teremos a seguinte sa\u00edda: \\[\\begin{verbatim} Entre valor da aresta do cubo: 4 O volume do cubo eh: 64 O volume do cubo eh: 64.00 O volume do cubo eh: 64.0000 \\end{verbatim}\\]","title":"include "},{"location":"intro/#operadores","text":"Os operadores s\u00e3o os mecanismos por meio dos quais os computadores realizam os c\u00e1lculos aritm\u00e9ticos e l\u00f3gicos, atualizando valores das vari\u00e1veis e executando as tarefas a que se destinam. Os operadores matem\u00e1ticos s\u00e3o os mais utilizados na maioria dos programas que ser\u00e3o desenvolvidos. Os principais operadores aritm\u00e9ticos s\u00e3o: \\(+, -, *, /\\) e o \\%, indicando, respectivamente, as opera\u00e7\u00f5es de soma, subtra\u00e7\u00e3o, multiplica\u00e7\u00e3o, divis\u00e3o e resto da divis\u00e3o. Considere o exemplo a seguir: \\begin{lstlisting}","title":"{Operadores}"},{"location":"intro/#include_8","text":"using namespace std; int main() { int n, dobro_de_n; cout << \"Entre um inteiro: \"; cin >> n; dobro_de_n = 2*n; cout << \"O dobro de \" << n << \" eh \" << dobro_de_n << endl; return 0; } \\end{lstlisting}","title":"include"},{"location":"intro/#exercicios_2","text":"\\begin{exercicio} Escreva uma fun\u00e7\u00e3o em C que, dado uma temperatura em graus C\u00e9lsius (do tipo float), retorne a temperatura equivalente em Farenheit. Escreva tamb\u00e9m a fun\u00e7\u00e3o \\verb|main| que leia a temperatura em C\u00e9lsius do teclado, invoque a fun\u00e7\u00e3o de convers\u00e3o, e imprima o resultado. Dado: \\(F = \\frac{9C}{5} + 32\\) \\end{exercicio} %\\todo{Esta se\u00e7\u00e3o deve ser movida para mais adiante, para quando formos falar em n\u00fameros bin\u00e1rios, e incrementada.} \\chapter{Vari\u00e1veis (II)}","title":"{Exerc\u00edcios}"},{"location":"intro/#escopo-de-variaveis","text":"No cap\u00edtulo anterior estudamos como declarar e utilizar vari\u00e1veis em nossos programas. Fizemos, por exemplo, um programa como o seguinte, que pede ao usu\u00e1rio que entre com as medidas da base e altura de um ret\u00e2ngulo e ent\u00e3o imprime na tela do computador a \u00e1rea deste ret\u00e2ngulo. \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. return altura * base; } int main() { float area, b, a; cout << \"Qual a altura do retangulo?\" << endl; cin >> a; cout << \"Qual a base do retangulo?\" << endl; cin >> b; area = area_retangulo(b, a); cout << \"A area do retangulo de base \" << b << \" e altura \" << a << \" eh \" << area << endl; return 0; } \\end{lstlisting} O que aconteceria se em vez de chamarmos as vari\u00e1veis na fun\u00e7\u00e3o \\verb|main| de \\verb|a| e \\verb|b| as tiv\u00e9ssemos chamado de \\verb|base| e \\verb|altura|? Veja que estes s\u00e3o exatamente os nomes dos par\u00e2metros da fun\u00e7\u00e3o \\verb|area_retangulo|. Melhor ainda, e se a fun\u00e7\u00e3o tivesse alterado os valores dos par\u00e2metros? Para descobrir as respostas a estas perguntas, fa\u00e7a o seguinte experimento: \\begin{itemize} \\item digite o programa tal qual acima em seu computador e \\emph{execute-o}. \\item modifique somente a fun\u00e7\u00e3o \\verb|main| do seu programa para que fique assim \\begin{lstlisting} int main() { float area, base, altura; cout << \"Qual a altura do retangulo?\" << endl; cin >> altura; cout << \"Qual a base do retangulo?\" << endl; cin >> base; area = area_retangulo(base, altura); cout << \"A area do retangulo de base \" << base << \" e altura \" << altura << \" eh \" << area << endl; return 0; } \\end{lstlisting} e execute-o. \\item Note quais as diferen\u00e7as na execu\u00e7\u00e3o. \\item Finalmente, altere a fun\u00e7\u00e3o \\verb|area_retangulo| para que fique assim \\begin{lstlisting} float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. altura *= base; return altura; } \\end{lstlisting} e execute novamente o programa. \\item Note se houve alguma altera\u00e7\u00e3o do valor da vari\u00e1vel \\verb|altura|. \\end{itemize} Como se p\u00f4de notar, estas mudan\u00e7as n\u00e3o afetaram a execu\u00e7\u00e3o do programa. Isto acontece por qu\u00ea as vari\u00e1veis tem escopos bem definidos em C. A vari\u00e1vel \\verb|altura| da fun\u00e7\u00e3o \\verb|main| n\u00e3o \u00e9 a mesma vari\u00e1vel/par\u00e2metro \\verb|altura| da fun\u00e7\u00e3o \\verb|area_retangulo|; cada uma s\u00f3 existe dentro do corpo da fun\u00e7\u00e3o em que foi declarada. Quando a fun\u00e7\u00e3o \\verb|area_retangulo| \u00e9 invocada passando-se como par\u00e2metro a vari\u00e1vel \\verb|altura| da fun\u00e7\u00e3o \\verb|main|, o valor desta vari\u00e1vel \u00e9 \\emph{copiado} para o par\u00e2metro \\verb|altura| da fun\u00e7\u00e3o invocada. Sendo assim, quaisquer altera\u00e7\u00f5es ao valor do par\u00e2metro dentro da fun\u00e7\u00e3o afetam apenas a c\u00f3pia, n\u00e3o o valor da vari\u00e1vel de onde foi copiado. A vari\u00e1veis definidas at\u00e9 agora possuem o que chamamos \\emph{escopo local}. Isto \u00e9, elas s\u00e3o visiveis somente localmente \u00e0 fun\u00e7\u00e3o em que foram definidas. Outro tipo de escopo presente poss\u00edvel em C \u00e9 o \\emph{escopo global}. Uma vari\u00e1vel tem escopo global se for definida fora de qualquer fun\u00e7\u00e3o. Uma vari\u00e1el com escopo global poder\u00e1 ser acessada de (quase) qualquer parte do seu c\u00f3digo. Para um exemplo de vari\u00e1vel de escopo global, veja o c\u00f3digo a seguir. \\begin{lstlisting} float PI = 3.1416; float resposta = 0; float area_retangulo(float altura, float base) { //Calcula e retorna a area do retangulo. resposta = base * altura; return resposta; } float area_circulo(float raio) { //Calcula e retorna a area do circulo. resposta = PI * raio * raio; return resposta; } int main() { float area, base, altura, raio; cout << \"Qual a altura do retangulo?\" << endl; cin >> altura; cout << \"Qual a base do retangulo?\" << endl; cin >> base; area = area_retangulo(base, altura); cout << \"A area do retangulo de base \" << base << \" e altura \" << altura << \" eh \" << area << endl; cout << \"Resposta da chamada de funcao \" << resposta << endl; cout << \"Qual o raio do circulo?\" << endl; cin >> raio; area = area_circlo(raio); cout << \"A area do circulo de raio \" << raio << \" e PI arredondado para \" << PI <<\" eh \" << area << endl; cout << \"Resposta da chamada de funcao \" << resposta << endl; return 0; } \\end{lstlisting} Observe a vari\u00e1vel \\verb|PI|. Esta vari\u00e1vel foi declarada fora de qualquer fun\u00e7\u00e3o e, sendo assim, \u00e9 vis\u00edvel em qualquer delas, como demonstrado pelo seu uso na fun\u00e7\u00e3o \\verb|main| e \\verb|area_circulo|. Observe tamb\u00e9m que a mesma vari\u00e1vel \\verb|area| foi utilizada mais de uma vez. Isto \u00e9 comum em programa\u00e7\u00e3o pois, com a quantidade limitada de recursos, pode n\u00e3o fazer sentido criar uma vari\u00e1vel para cada novo uso. Observe que a vari\u00e1vel \\verb|resposta| foi alterada dentro das duas fun\u00e7\u00f5es de c\u00e1lculo de \u00e1rea e que estas mudan\u00e7as foram vis\u00edveis \u00e0 fun\u00e7\u00e3o \\verb|main|. Verifique de forma experimental (copiando e executando) que o programa acima funciona como esperado.","title":"{Escopo de Vari\u00e1veis}"},{"location":"intro/#faixas-de-valores","text":"Voc\u00ea j\u00e1 aprendeu que vari\u00e1veis s\u00e3o espa\u00e7os (c\u00e9lulas) da mem\u00f3ria do computador para o qual damos nomes. Estes espa\u00e7os, por serem limitados, podem armazenar uma quantidade limitada de valores. Pense, por exemplo, em quais os n\u00fameros, positivos e negativos, se pode representar com tr\u00eas d\u00edgitos: \\(-99, -98, \\ldots, 0, 1, 2, \\ldots, 998,999\\) . Tentemos descobrir qual a faixa de valores que ``cabem'' em uma vari\u00e1vel \\verb|int|. Escreva um programa que declare uma vari\u00e1vel do tipo \\verb|int|, inicie esta vari\u00e1vel com um n\u00famero (digamos, 10000), e imprima este n\u00famero na tela do computador. Veja que o n\u00famero \u00e9 impresso na tela como deveria: \\verb|10000|. Agora altere seu programa para que imprima 20000 e execute-o. Refa\u00e7a este passo (adicionando 10000 a cada passo) at\u00e9 que a impress\u00e3o fuja do que voc\u00ea esperava. Neste ponto, trabalhe com incrementos menores at\u00e9 determinar qual o maior n\u00famero que \u00e9 impresso como esperado. Fepita o processo para identificar qual o menor n\u00famero que cabe em um \\verb|int|. Quais s\u00e3o estes valores? Finalmente, tente identificar a faixa de valores que cabem em um \\verb|float|. Dica: os incrementos iniciais deveriam ser na faixa de milh\u00f5es e n\u00e3o dezenas de milhares.","title":"{Faixas de Valores}"},{"location":"intro/#exercicios_3","text":"\\todo{Colocar}","title":"{Exerc\u00edcios}"},{"location":"intro/#laboratorio","text":"\\todo{Colocar} \\chapter{Sele\u00e7\u00e3o Simples} Nossos programas at\u00e9 agora foram extremamente simples, contendo apenas algumas pequenas fun\u00e7\u00f5es al\u00e9m da \\verb|main|. Isto acontece em parte por qu\u00ea nossos programas s\u00e3o apenas sequ\u00eancias diretas de comandos, sem execu\u00e7\u00e3o condicional. Isto \u00e9, at\u00e9 agora n\u00e3o aprendemos a dizer para o computador ``Se for assim, ent\u00e3o fa\u00e7a assado! Sen\u00e3o, fa\u00e7a cozido!''. Esta defici\u00eancia ser\u00e1 corrigida neste cap\u00edtulo. Como exemplo de programa\u00e7\u00e3o mais interessante, implementemos uma fun\u00e7\u00e3o que calcule as raizes de uma equa\u00e7\u00e3o de segundo grau. Para faz\u00ea-lo, relembremos a f\u00f3rmula de Bhaskara: \\(x = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}\\) , sendo \\(\\Delta = b^2 -4ac\\) . Comecemos ent\u00e3o definindo uma fun\u00e7\u00e3o para o c\u00e1lculo do \\(\\Delta\\) . \\[\\begin{lstlisting} float delta(float a, float b, float c) { return b*b - 4*a*c; } \\end{lstlisting}\\] Para testar o c\u00e1lculo do \\(\\Delta\\) precisamos da fun\u00e7\u00e3o \\verb|main|, juntamente com o restante do esqueleto de programa aprendido at\u00e9 agora. \\begin{lstlisting}","title":"{Laborat\u00f3rio}"},{"location":"intro/#include_9","text":"using namespace std; float delta(float a, float b, float c) { return b*b - 4*a*c; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; return 0; } \\end{lstlisting} Agora, para c\u00e1lculo das ra\u00edzes! Comecemos por alterar o programa para imprimir \\emph{o n\u00famero} de ra\u00edzes da equa\u00e7\u00e3o. O c\u00e1lculo do n\u00famero de ra\u00edzes ser\u00e1 feito na fun\u00e7\u00e3o \\verb|raizes|. A equa\u00e7\u00e3o tem ou 0 ra\u00edzes reais (se o \\(\\Delta < 0\\) ), ou duas ra\u00edzes iguais (se \\(\\Delta = 0\\) ), ou duas raizes distintas (se \\(\\Delta > 0\\) ). \\begin{lstlisting}","title":"include "},{"location":"intro/#include_10","text":"using namespace std; float delta(float a, float b, float c) { return b*b - 4*a*c; } int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; se d menor que 0 { qtd = 0; } senao e se d igual a 0 { qtd = 1; } senao { qtd = 2; } return qtd; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; cout << \"A equacao tem \" << raizes(a,b,c) << \" raizes.\"; return 0; } \\end{lstlisting} Acontece que o computador n\u00e3o entende nem o \\verb|se| e nem o \\verb|menor que|. Mas ent\u00e3o como faremos as verifica\u00e7\u00f5es necess\u00e1rias para determinar a quantidade raizes? A resposta tem duas partes.","title":"include "},{"location":"intro/#operadores-relacionais","text":"As linguagens de programa\u00e7\u00e3o prov\u00eaem sempre formas de se comparar dados. Em C(++) os operadores relacionais, usados para comparar, s\u00e3o os seguintes: \\[\\begin{tabular}{c l} \\verb|==| & igual a\\\\ \\verb|!=| & diferente de\\\\ \\verb|>| & maior que\\\\ \\verb|<| & menor que\\\\ \\verb|>=| & maior ou igual a\\\\ \\verb|<=| & menor ou igual a\\\\ \\end{tabular}\\] Observe que o primeiro operador tem \\emph{dois} sinais de igual. Isto \u00e9 para diferenciar este operador do operador de atribui\u00e7\u00e3o \\verb|=|, visto anteriormente. O segundo operador tem um sinal de exclama\u00e7\u00e3o (\\verb|!|) que, em linguagem C, significa \\emph{nega\u00e7\u00e3o}. Logo, \\verb|!=| significa n\u00e3o igual ou, simplesmente, diferente. Os demais operadores devem ter significados \u00f3bvios. Usando estes operadores, podemos re-escrever a fun\u00e7\u00e3o raizes do nosso programa assim: \\begin{lstlisting} int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; se d < 0 { qtd = 0; } senao e se d == 0 { qtd = 1; } senao { qtd = 2; } return qtd; } \\end{lstlisting} Melhorou, mas ainda n\u00e3o pode ser executado pelo computador. Vamos ent\u00e3o ao \\emph{se}.","title":"{Operadores Relacionais}"},{"location":"intro/#textttif-else","text":"Em C, testes simples (tudo o que voc\u00ea realmente precisa) podem ser feitos com a estrutura \\verb|if|, que tem uma das seguintes sintaxes: \\begin{itemize} \\item \\verb|if(| express\u00e3o l\u00f3gica \\verb|)| bloco de comandos 1 \\item \\verb|if(| express\u00e3o l\u00f3gica \\verb|)| bloco de comandos 1 \\verb|else| bloco de comandos 2 \\end{itemize} Uma \\emph{express\u00e3o l\u00f3gica} \u00e9 uma express\u00e3o cuja avalia\u00e7\u00e3o resulte em \\emph{verdadeiro} ou \\emph{falso} como, por exemplo, as express\u00f5es que usam os operadores relacionais apenas apresentados. Um \\emph{bloco de comandos} \u00e9 ou uma instru\u00e7\u00e3o ou um conjunto de instru\u00e7\u00f5es dentro de \\verb|{| \\verb|}|. Quando a express\u00e3o l\u00f3gica \u00e9 avaliada, se seu resultado for \\emph{verdadeiro}, ent\u00e3o o bloco de comandos 1 ser\u00e1 executado. Se o resultado for \\emph{falso}, o bloco de comandos 1 n\u00e3o ser\u00e1 executado e o bloco 2, se existir, ser\u00e1 executado em seu lugar. Observe que o segundo bloco pode ser, por sua vez, outro \\verb|if|. Por exemplo, nosso programa pode ser reescrito assim: \\begin{lstlisting}","title":"{\\texttt{if-else}}"},{"location":"intro/#include_11","text":"using namespace std; float delta(float a, float b, float c) { return b*b - 4*a*c; } int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; if(d < 0) { qtd = 0; } else if(d == 0) { qtd = 1; } else { qtd = 2; } return qtd; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; cout << \"A equacao tem \" << raizes(a,b,c) << \" raizes.\"; return 0; } \\end{lstlisting} O \u00faltimo passo no desenvolvimento do nosso programa \u00e9 imprimir na tela as raizes da equa\u00e7\u00e3o, o que faremos em uma nova fun\u00e7\u00e3o: \\verb|imprime_raizes|. \\begin{lstlisting}","title":"include "},{"location":"intro/#include_12","text":"","title":"include "},{"location":"intro/#include_13","text":"using namespace std; float delta(float a, float b, float c) { return pow(b,2) - 4*a*c; } int raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; if(d < 0) { qtd = 0; } else if(d == 0) { qtd = 1; } else { qtd = 2; } return qtd; } int imprime_raizes(float a, float b, float c) { float d = delta(a,b,c); int qtd; if(d < 0) { cout << \"A equacao tem zero raizes reais.\" << endl; } else if(d == 0) { cout << \"A equacao tem duas raizes iguais a \" << -b/(2*a); } else { cout << \"A equacao tem duas raizes iguais distintas \" << endl << \"x' = \" << (-b + sqrt(d))/(2*a) << endl << \"x'' = \" << (-b - sqrt(d))/(2*a) << endl; } return qtd; } int main() { float a, b, c; cout << \"Equacao do segundo grau: axx + bx + c = 0\" << endl; cout << \"Digite o valor de a: \"; cin >> a; cout << \"Digite o valor de b: \"; cin >> b; cout << \"Digite o valor de c: \"; cin >> c; cout << \"Delta: \" << delta(a,b,c) << endl; cout << \"A equacao tem \" << raizes(a,b,c) << \" raizes.\" << endl; imprime_raizes(a,b,c); return 0; } \\end{lstlisting} Note que a nova fun\u00e7\u00e3o usa a fun\u00e7\u00e3o \\verb|sqrt| para calcular a ra\u00edz de \\(\\Delta\\) . Esta fun\u00e7\u00e3o \u00e9 uma das muitas dispon\u00edveis na linguagem C. Para usar esta fun\u00e7\u00e3o \u00e9 preciso dizer ao computador sua inten\u00e7\u00e3o. No nosso programa, isto \u00e9 feito na linha 2, isto \u00e9,\\ \\verb|#include |\\ em que dizemos ao computador que queremos usar as fun\u00e7\u00f5es da biblioteca matem\u00e1tica da linguagem. Aproveitando a inclus\u00e3o desta biblioteca tamb\u00e9m alteramos a linha 8 para usar a fun\u00e7\u00e3o \\verb|pow| para o c\u00e1lculo do \\(b^2\\) . V\u00e1rias outras fun\u00e7\u00f5es est\u00e3o dispon\u00edveis e podem ser consultadas em \\url{ http://www.cplusplus.com/reference/clibrary/cmath/ }. \\todo{A se\u00e7\u00e3o seguinte deveria virar um cap\u00edtulo e a parte if else vistos at\u00e9 agora se juntar ao pr\u00f3ximo cap\u00edtulo}","title":"include "},{"location":"intro/#funcoes-e-procedimentos","text":"A fun\u00e7\u00e3o \\verb|imprime_raizes|, definida na se\u00e7\u00e3o anterior, tem por objetivo imprimir na tela as raizes da equa\u00e7\u00e3o de segundo grau, se existirem. Esta fun\u00e7\u00e3o n\u00e3o tem, pela nossa defini\u00e7\u00e3o, o objetivo de calcular a quantidade de ra\u00edzes (que era o objetivo da fun\u00e7\u00e3o \\verb|raizes|). Em \\verb|imprime_raizes| n\u00e3o faz sentido, ent\u00e3o, a fun\u00e7\u00e3o ter um \\emph{resultado}. Fun\u00e7\u00f5es sem resultado s\u00e3o denominadas \\emph{procedimentos} e, em C, s\u00e3o declaradas como qualquer outra fun\u00e7\u00e3o, apenas com uma particularidade: o tipo do resultado \u00e9 \\verb|void|. Antes de vermos alguns exemplos, precisamos ver a sintaxe de fun\u00e7\u00f5es em geral, que estivemos usando nas se\u00e7\u00f5es e cap\u00edtulos anteriores mas n\u00e3o hav\u00edamos definido formalmente. tipo_resultado \\ identificador_fun\u00e7\u00e3o(tipo_par\u00e2metro 1 identificador_do_par\u00e2metro 1, \\ldots) bloco_de_comandos \\[\\begin{itemize} \\item tipo\\_resultado -- o tipo do valor que a fun\u00e7\u00e3o est\u00e1 calculando. \\item identificador\\_fun\u00e7\u00e3o -- o nome usado para invocar a fun\u00e7\u00e3o. \\item tipo\\_par\u00e2metro 1 -- tipo do primeiro par\u00e2metro da fun\u00e7\u00e3o. \\item identificador\\_par\u00e2metro 1 -- identificador do primeiro par\u00e2metro da fun\u00e7\u00e3o. \\item \\dots -- tipo e identificador dos demais par\u00e2metros. \\item bloco\\_de\\_comandos -- instru\u00e7\u00f5es que comp\u00f5em o corpo da fun\u00e7\u00e3o. \\end{itemize}\\] Como mencionado, procedimentos s\u00e3o fun\u00e7\u00f5es sem um resultado e, em C, s\u00e3o declarados como tendo resultado do tipo \\verb|void|. Em fun\u00e7\u00f5es normais, o resultado \u00e9 dado pela instru\u00e7\u00e3o \\verb|return|; em procedimentos, que n\u00e3o tem resultado, \\verb|return| n\u00e3o \u00e9 utilizado. Al\u00e9m disso, o resultado de procedimentos n\u00e3o podem ser usados em atribui\u00e7\u00f5es. Al\u00e9m de fun\u00e7\u00f5es sem resultado, C permite a defini\u00e7\u00e3o de fun\u00e7\u00f5es sem par\u00e2metros. Um exemplo deste tipo de fun\u00e7\u00e3o seria uma que lesse algum dado do usu\u00e1rio. \\begin{lstlisting} int ler_idade() { int id; cout << \"Qual sua idade? \" < > id; return id; } \\end{lstlisting} Finalmente, \u00e9 importante relembrar que as fun\u00e7\u00f5es precisam ser definidas \\emph{antes} de serem usadas. Sendo assim, voc\u00ea deve incluir a defini\u00e7\u00e3o das fun\u00e7\u00f5es antes da defini\u00e7\u00e3o da fun\u00e7\u00e3o \\verb|main| em seu c\u00f3digo. \\footnote{\u00c9 poss\u00edvel escrever o c\u00f3digo de suas fun\u00e7\u00f5es ap\u00f3s a fun\u00e7\u00e3o \\texttt{main} ou mesmo em outros arquivos. Fazer isso, contudo, requer conhecer um pouco mais do funcionamento dos compiladores do que o escopo deste livro.}. Ainda, relembrando a primeira aula, sobre a fun\u00e7\u00e3o \\verb|main|: \\begin{enumerate} \\item A fun\u00e7\u00e3o \\verb|main| tem um resultado do tipo inteiro e seu resultado \u00e9 sempre 0 (\\lstinline{return 0;} )\\footnote{Pelo menos nos programas simples que faremos.}. \\item Fun\u00e7\u00e3o \\verb|main| \u00e9 como um \\emph{highlander}: s\u00f3 pode haver uma! Isto \u00e9, cada programa s\u00f3 pode conter a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o com este nome. \\item Finalmente, todas as fun\u00e7\u00f5es devem ser declaradas antes da serem usadas, pois quando o computador tenta execut\u00e1-la, j\u00e1 deve saber de sua exist\u00eancia. \\end{enumerate}","title":"{Fun\u00e7\u00f5es e Procedimentos}"},{"location":"intro/#o-tipo-primitivo-lstinlinebool","text":"Como vimos neste cap\u00edtulo, o \\lstinline|if| avalia uma express\u00e3o l\u00f3gica para decidir-se por executar ou n\u00e3o um bloco de comandos. Express\u00f5es l\u00f3gicas, como tamb\u00e9m j\u00e1 visto, s\u00e3o aquelas que s\u00e3o avaliadas em verdadeiro ou falso. Na linguagem C(++), quaisquer n\u00fameros inteiros podem tamb\u00e9m ser avaliados como verdadeiro ou falso, seguindo a seguinte regra: \\begin{itemize} \\item 0 corresponde a falso. \\item qualquer outro n\u00famero corresponde a verdadeiro. \\end{itemize} Em C++, tamb\u00e9m \u00e9 poss\u00edvel utilizar os valores \\lstinline|true| e \\lstinline|false|, que correspondem, respectivamente, a 1 e 0. Estes dois valores comp\u00f5em o conjuntos dos booleanos, ou melhor, o tipo primitivo \\lstinline|bool|. Isto \u00e9, \\lstinline|true| e \\lstinline|false| est\u00e3o para \\lstinline|bool| assim como -100, 10, 12, \\ldots est\u00e3o para \\lstinline|int|.","title":"{O Tipo Primitivo \\lstinline|bool|}"},{"location":"intro/#exercicios_4","text":"\\begin{exercicio} Muitas pessoas acreditam que um ano \u00e9 bissexto se for m\u00faltiplo de 4. Contudo, a regra \u00e9 um pouco mais complexa do que esta: \\begin{itemize} \\item Um ano \u00e9 bissexto se for m\u00faltiplo de 4 mas n\u00e3o de 100, ou \\item se for m\u00faltiplo de 100, ent\u00e3o for m\u00faltiplo de 400. \\end{itemize} Escreva um programa que leia um ano, chame uma fun\u00e7\u00e3o para calcular se o ano \u00e9 bissexto e imprima sim ou n\u00e3o de acordo. \\begin{lstlisting}","title":"{Exerc\u00edcios}"},{"location":"intro/#include_14","text":"using namespace std; bool bissexto(int ano) { if(ano % 4 == 0) { if(ano % 100 == 0) { if (ano % 400 == 0) { return true; } else { return false; } } else { return true; } } else { return false; } } int main() { int ano; cout << \"Digite o ano que deseja verificar se e bissexto: \"; cin >> ano; cout << \"O ano \" << ano; if(bissexto(ano)) cout << \" e bissexto\" << endl; else cout << \" nao e bissexto\" << endl; return 0; } \\end{lstlisting} \\end{exercicio} \\begin{exercicio} Este exerc\u00edcio \u00e9 dividido em v\u00e1rias partes: \\begin{enumerate} \\item Escreva uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais e retorne a m\u00e9dia dos tr\u00eas n\u00fameros. \\item Escreva uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais e retorne o menor dentre eles. \\item Escreva uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais e retorne o maior dentre eles. \\item Escreva a fun\u00e7\u00e3o \\verb|main| de forma a ler tr\u00eas n\u00fameros reais, calcular a m\u00e9dia dos mesmos e, caso a m\u00e9dia seja menor que 0, imprima o menor dentre os tr\u00eas, ou, caso a m\u00e9dia seja maior ou igual a zero, imprima o maior dentre os tr\u00eas. Sua fun\u00e7\u00e3o \\verb|main| deve usar as fun\u00e7\u00f5es escritas nos itens anteriores para c\u00e1lculo da m\u00e9dia e impress\u00e3o dos n\u00fameros. \\end{enumerate} \\end{exercicio} \\[\\begin{exercicio} Escreva um programa que contenha \\begin{enumerate} \\item Uma fun\u00e7\u00e3o \\verb|celsius_fahrenheit| que receba uma temperatura em graus celsius e converta para fahrenheit. \\item Uma fun\u00e7\u00e3o \\verb|fahrenheit_celsius| que receba uma temperatura em fahrenheit e converta para graus celsius. \\item Fun\u00e7\u00e3o \\verb|main| que leia uma temperatura do teclado, pergunte ao usu\u00e1rio se a temperatura \u00e9 em celsius ou fahrenheit, e imprima a temperatura convertida para a outra medida. \\end{enumerate} \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o denominada \\emph{ehPar} que receba um n\u00famero inteiro como argumento e retorne verdadeiro se este n\u00famero for par ou falso, caso contr\u00e1rio. A fun\u00e7\u00e3o \\verb|main| deve ler o n\u00famero e imprimir o valor retornado pela fun\u00e7\u00e3o auxiliar. \\end{exercicio}\\] \\[\\begin{exercicio} Elabore um programa com as seguinte descri\u00e7\u00e3o: \\begin{itemize} \\item Uma fun\u00e7\u00e3o que retorna verdadeiro se tr\u00eas n\u00fameros reais recebidos como argumentos formam um tri\u00e2ngulo ou falso, caso contr\u00e1rio. \\item Uma fun\u00e7\u00e3o que recebe tr\u00eas n\u00fameros reais como argumento representado os lados de um tri\u00e2ngulo e retorna 0 caso os n\u00fameros formem um tri\u00e2ngulo equil\u00e1tero, 1 caso formem um tri\u00e2ngulo is\u00f3sceles, ou 2 caso sejam os lados de um tri\u00e2ngulo escaleno. \\item Por fim, a fun\u00e7\u00e3o \\verb|main| deve ler os 3 n\u00fameros que representam os lados, e caso formem um tri\u00e2ngulo, imprimir se o tri\u00e2ngulo formado \u00e9 equilatero, is\u00f3sceles ou escaleno. \\end{itemize} \\end{exercicio}\\]","title":"include "},{"location":"intro/#laboratorio_1","text":"Refa\u00e7a no computador os exerc\u00edcios propostos acima. \\chapter{Sele\u00e7\u00e3o Simples (II)} Uma vez apresentado a estrutura condicional \\emph{if-else}, veremos agora como realizar testes mais complexos utilizando operadores l\u00f3gicos.","title":"{Laborat\u00f3rio}"},{"location":"intro/#lstinlineif-else-e-operadores-logicos","text":"At\u00e9 o ponto atual fizemos apenas testes simples dentro da condi\u00e7\u00e3o dos nossos \\lstinline!if!, por exemplo: \\begin{lstlisting} ... /* * esta funcao retorna verdadeiro se a pessoa de sexo * (1=Masculino, 2=Feminino) e idade passados como argumentos * for maior que idade ou falso, caso contrario */ bool ehMaior(int sexo, int idade) { if(sexo == 1) // masculino { if(idade >= 18) { return true; } else { return false; } } else if(sexo == 2) // feminino { if(idade >= 21) { return true; else { return false; } } else // sexo informado errado { return false; } } \\end{lstlisting} Observe que na fun\u00e7\u00e3o \\verb|ehMaior| temos \\lstinline{if} \\emph{aninhados}, ou seja, \\lstinline{if} dentro de \\lstinline{if}. Isto porque um pessoa deve ser do sexo masculino \\emph{E} possuir idade maior ou igual a 18 anos para ser considerada maior de idade. \\emph{OU} ainda, ela pode ser do sexo feminino \\emph{E} possuir idade igual ou maior a 21 anos. Quando esta situa\u00e7\u00e3o ocorre, as condi\u00e7\u00f5es podem ser combinadas em um \u00fanico \\lstinline!if! utilizando-se operadores l\u00f3gicos. Os operadores l\u00f3gicos que usaremos s\u00e3o o E, o OU e a N\u00c3O (nega\u00e7\u00e3o). Na linguagem C, eles s\u00e3o representados pelos s\u00edmbolos a seguir: \\begin {table}[!ht] \\begin{center} \\caption{Operadores l\u00f3gicos e seus s\u00edmbolos na linguagem C.} \\begin{tabular}{|c|c|c|}\\hline Operador L\u00f3gico & S\u00edmbolo & S\u00edmbolo novo\\footnote{Dispon\u00edvel somente em compiladores C++ ISO98} \\ \\hline \\hline E & \\&\\& & and\\ OU & || & or\\ N\u00c3O & ! & not\\ \\hline \\end{tabular} \\end{center} \\end{table} Os operadores l\u00f3gicos podem ser resumidos nas tabelas a seguir: \\begin {table}[!ht] \\begin{center} \\caption{N\u00c3O l\u00f3gico.} { \\begin{tabular}{|c|c|} \\hline \\textbf{A} & \\textbf{!A} \\ \\hline \\hline V & F \\ \\hline F & V \\ \\hline\\hline \\end{tabular} } \\end{center} \\end{table} \\begin {table}[!ht] \\begin{center} \\caption{E l\u00f3gico.} { \\begin{tabular}{|c|c|c|} \\hline \\textbf{A} & \\textbf{B} & \\textbf{A \\&\\& B} \\ \\hline \\hline V & V & V \\ \\hline V & F & F \\ \\hline F & V & F \\ \\hline F & F & F \\ \\hline\\hline \\end{tabular} } \\end{center} \\end{table} \\begin {table}[!ht] \\begin{center} \\caption{OU l\u00f3gico.} { \\begin{tabular}{|c|c|c|} \\hline \\textbf{A} & \\textbf{B} & \\textbf{A || B} \\ \\hline \\hline V & V & V \\ \\hline V & F & V \\ \\hline F & V & V \\ \\hline F & F & F \\ \\hline\\hline \\end{tabular} } \\end{center} \\end{table} Voltando ao nosso exemplo, a fun\u00e7\u00e3o anterior pode ser reescrita da seguinte forma: \\[\\begin{lstlisting} ... /* * esta funcao retorna verdadeiro se a pessoa de sexo * (1=Masculino, 2=Feminino) e idade passados como argumentos * for maior de idade ou falso, caso contrario */ bool ehMaior(int sexo, int idade) { if((sexo == 1 && idade >=18) || (sexo == 2 && not(idade < 21)) { return true; } else // sexo errado ou idade errada { return false; } } \\end{lstlisting}\\] Perceba que em apenas um \\lstinline!if! colocamos a condi\u00e7\u00e3o completa, ou seja, ``se sexo igual a 1 E idade maior ou igual a 18 OU sexo igual a 2 e idade N\u00c3O menor do que 21 ent\u00e3o \u00e9 maior de idade''.","title":"{\\lstinline|if-else| e Operadores L\u00f3gicos}"},{"location":"intro/#prioridade-dos-operadores","text":"Quando mais de um operador l\u00f3gico aparece em uma express\u00e3o, a preced\u00eancia pode ser expressa da seguinte maneira: primeiro o N\u00c3O, depois o E, por \u00faltimo o OU. Quando houver par\u00eanteses, primeiro avalia-se o que estiver dentro dos mesmos. Em diversas express\u00f5es e testes, diversos operadores dos v\u00e1rios tipos podem aparecer. A avalia\u00e7\u00e3o dessa express\u00e3o deve obedecer \u00e0 seguinte ordem de prioridade em rela\u00e7\u00e3o aos operadores: \\begin{enumerate} \\item Par\u00eanteses, incremento e decremento (\\lstinline|++|, \\lstinline|--|) \\item \\lstinline|not| (!) \\item Multiplica\u00e7\u00e3o, divis\u00e3o e m\u00f3dulo (o que aparecer primeiro); \\item Soma e subtra\u00e7\u00e3o; \\item Operadores relacionais (<, <=, >, >=) \\item Operadores relacionais (==, !=) % \\item OU-Exclusivo (\\lstinline|^| ) \\item \\lstinline|and| (\\&\\&) \\item \\lstinline|or| (||) \\item Atribui\u00e7\u00e3o (=, +=, -=, *=, /=, \\%=) \\end{enumerate} Embora os operadores l\u00f3gicos fa\u00e7am sentido somente para operandos \\lstinline!bool!, \u00e9 importante relembrar que, para o computador, verdadeiro e falso s\u00e3o apenas formas de interpretar n\u00fameros na mem\u00f3ria. Na linguagem C, qualquer n\u00famero diferente de 0 \u00e9 tratado como \\lstinline!true! e 0 \u00e9 tratado como \\lstinline!false!. Sendo assim, \u00e9 poss\u00edvel aplicar operadores l\u00f3gicos tamb\u00e9m \u00e0 n\u00fameros. Contudo, sempre que requisitado a representar o valor \\lstinline!true! como n\u00famero, o computador usar\u00e1 o valor 1, o que faz com que nem todas as computa\u00e7\u00f5es tenham resultados \u00f3bvios. Por exemplo, o c\u00f3digo \\lstinline!cout<<(2||0);! imprime, na tela, o valor 1. Isto por qu\u00ea 2 \u00e9 tratado como verdadeiro e 0 como falso, e o resultado de verdadeiro OU falso \u00e9 verdadeiro, que \u00e9 ent\u00e3o convertido para 1. Da mesma forma, \\lstinline|!!3| \u00e9 1, pois \\lstinline|!3| \u00e9 falso e sua nega\u00e7\u00e3o \u00e9 verdadeiro, que \u00e9 1.","title":"{Prioridade dos Operadores}"},{"location":"intro/#exercicios_5","text":"\\[\\begin{exercicio} Avalie o resultado de cada express\u00e3o a seguir (verdadeiro ou falso): \\begin{itemize} \\item \\lstinline|2 < 5 && 15/3 == 5| \\item \\lstinline|pow(3,2) - 5 > 0 && 5/2 == 3 - 4| \\item \\lstinline?F || 20 == 18/3 != 21/3 / 2? \\item \\lstinline?!V || 3*3/3 < 15 - 35%7? \\item \\lstinline?!(5 != 10/2) || V && 2 - 5 > 5 - 2 || V? \\item \\lstinline?pow(2,4) != 4 + 2 || 2 + 3 * 5/3%5 < 0? \\item \\lstinline|!1+1| %1 \\item \\lstinline|!2+1| %1 \\item \\lstinline|!0+1| %2 \\end{itemize} \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a um programa que: \\begin{enumerate} \\item contenha uma fun\u00e7\u00e3o que retorna verdadeiro se um n\u00famero for divis\u00edvel por 3 ou 5, mas n\u00e3o simultaneamente pelos dois, e; \\item na fun\u00e7\u00e3o principal sejam lidos dois n\u00fameros inteiros, que dever\u00e3o ser passados para a fun\u00e7\u00e3o criada, tendo seu resultado impresso. \\end{enumerate} \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o que receba 3 n\u00fameros reais (\\lstinline|float|) correspondentes aos lados de um tri\u00e2ngulo e retorne \\lstinline|true| caso esse tri\u00e2ngulo seja ret\u00e2ngulo ou \\lstinline|false| caso n\u00e3o o seja. A fun\u00e7\u00e3o principal deve ler os valores dos lados do tri\u00e2ngulo, verificar se realmente formam um tri\u00e2ngulo e imprimir \"sim\" se \u00e9 ou \"n\u00e3o\", caso n\u00e3o seja tri\u00e2ngulo ret\u00e2ngulo; se n\u00e3o formar um tri\u00e2ngulo, imprimir \"n\u00e3o forma\". \\end{exercicio}\\]","title":"{Exerc\u00edcios}"},{"location":"intro/#laboratorio_2","text":"\\begin{lab} Escreva um programa que implemente uma calculadora com as quatro opera\u00e7\u00f5es +,-,* e /. Sua calculadora deve ler um n\u00famero real X, seguido de um inteiro representando um dos operadores definidos (1 para -, 2 para +, 3 para * e 4 para /), seguido de outro n\u00famero real Y. Finalmente, seu programa deve escrever o resultado da opera\u00e7\u00e3o desejada. \\end{lab} \\todo{Revisado at\u00e9 aqui} \\chapter{Switch} Em diversas situa\u00e7\u00f5es em programa\u00e7\u00e3o, \u00e9 necess\u00e1rio testar se uma determinada vari\u00e1vel tem um dentre diversos poss\u00edveis valores. Nesta situa\u00e7\u00e3o, embora seja poss\u00edvel usar v\u00e1rios \\lstinline|if|, outra solu\u00e7\u00e3o nos \u00e9 dada em linguagem C: o uso de \\lstinline|switch|.","title":"{Laborat\u00f3rio}"},{"location":"intro/#lstinlineswitch-case-default","text":"Considere o problema de transformar o m\u00eas de uma representa\u00e7\u00e3o num\u00e9rica de uma data em sua representa\u00e7\u00e3o textual. Isto \u00e9, transformar, por exemplo, 25/12/2012 em 25 de Dezembro de 2012. Uma poss\u00edvel solu\u00e7\u00e3o para este problema, em C(++), \u00e9 o seguinte. \\begin{lstlisting}","title":"{\\lstinline|switch-case-default|}"},{"location":"intro/#include_15","text":"using namespace std; int main() { int dia, mes, ano; cout << \"Dia? \" <<endl; cin >> dia; cout << \"Mes? \" <<endl; cin >> mes; cout << \"Ano? \" <<endl; cin >> ano; cout << dia << \" de \"; if(mes == 1) cout << \"Janeiro\"; else if(mes == 2) cout << \"Fevereiro\"; else if(mes == 3) cout << \"Marco\"; else if(mes == 4) cout << \"Abril\"; else if(mes == 5) cout << \"Maio\"; else if(mes == 6) cout << \"Junho\"; else if(mes == 7) cout << \"Julho\"; else if(mes == 8) cout << \"Agosto\"; else if(mes == 9) cout << \"Setembro\"; else if(mes == 10) cout << \"Outubro\"; else if(mes == 11) cout << \"Novembro\"; else if(mes == 12) cout << \"Dezembro\"; else cout << \"Hein?-zembro\"; cout << \" de \" << ano << endl; return 0; } \\end{lstlisting} Em vez de usar v\u00e1rios \\lstinline|if| e \\lstinline|else-if|, uma solu\u00e7\u00e3o melhor seria usar \\lstinline|switch|, criado exatamente para tratar estas situa\u00e7\u00f5es. A sintaxe do uso do \\lstinline|switch| \u00e9 a seguinte.\\ \\lstinline|switch| (identificador)\\ {\\ \\lstinline|case| valor1: bloco_comandos1\\ \\lstinline|case| valor2: bloco_comandos2\\ \\ldots\\ \\lstinline|case| valorN: bloco_comandosN\\ \\lstinline|default|: bloco_comandos_default\\ } \\[\\begin{itemize} \\item identificador: Identificador da vari\u00e1vel a ser testada \\item valor1: primeiro caso a ser testado \\item bloco\\_comandos1: bloco de comandos a ser executado caso a vari\u00e1vel tenha valor igual a valor1 \\item valor2: segundo caso a ser testado \\item bloco\\_comandos2: bloco de comandos a ser executado caso a vari\u00e1vel tenha valor igual a valor2 \\item \\ldots outros casos a serem testados \\item valor n: \u00faltimo caso a ser testado \\item bloco\\_comandosN: bloco de comandos a ser executado caso a vari\u00e1vel tenha valor igual a valorN \\item default: um valor especial, que sempre ``casa'' com o valor da vari\u00e1vel \\item bloco\\_comandos\\_default: bloco de comandos a ser executado caso a vari\u00e1vel ``case'' com default. \\end{itemize}\\] Usando \\lstinline|switch-case-default|, o exemplo acima pode ser reescrito assim. \\begin{lstlisting}","title":"include "},{"location":"intro/#include_16","text":"using namespace std; int main() { int dia, mes, ano; cout << \"Dia? \" <<endl; cin >> dia; cout << \"Mes? \" <<endl; cin >> mes; cout << \"Ano? \" <<endl; cin >> ano; cout << dia << \" de \"; switch(mes) { case 1: cout << \"Janeiro\"; case 2: cout << \"Fevereiro\"; case 3: cout << \"Marco\"; case 4: cout << \"Abril\"; case 5: cout << \"Maio\"; case 6: cout << \"Junho\"; case 7: ... case 11: cout << \"Novembro\"; case 12: cout << \"Dezembro\"; default: cout << \"Hein?-zembro\"; } cout << \" de \" << ano << endl; return 0; } \\end{lstlisting} Execute este c\u00f3digo e digite, por exemplo, a data 1/1/2012 para ver que ele funciona ``quase'' corretamente. O problema, voc\u00ea deve ter observado, \u00e9 que al\u00e9m de imprimir o nome do m\u00eas correto, o programa imprime tamb\u00e9m o nome de todos os meses subsequentes e o valor \\lstinline|default|. Isso ocorre por que, na verdade, o \\lstinline|switch| come\u00e7a a executar o bloco correspondente ao \\lstinline|case| com o valor da vari\u00e1vel mas, a partir da\u00ed, executa todos os blocos a n\u00e3o ser que seja instru\u00eddo a fazer diferente, o que \u00e9 feito via a instru\u00e7\u00e3o \\lstinline|break|.","title":"include "},{"location":"intro/#lstinlinebreak","text":"A instru\u00e7\u00e3o \\lstinline|break| diz ao computador que pare de executar o \\lstinline|switch| no ponto em que \u00e9 invocada.\\footnote{Mais tarde veremos outros blocos no qual o \\lstinline|break| pode ser utilizado.} Sendo assim, podemos reescrever o programa mais uma vez para obter exatamente o comportamento da vers\u00e3o usando \\lstinline|if|. \\begin{lstlisting}","title":"{\\lstinline|break|}"},{"location":"intro/#include_17","text":"using namespace std; int main() { int dia, mes, ano; cout << \"Dia? \" <<endl; cin >> dia; cout << \"Mes? \" <<endl; cin >> mes; cout << \"Ano? \" <<endl; cin >> ano; cout << dia << \" de \"; switch(mes) { case 1: cout << \"Janeiro\"; break; case 2: cout << \"Fevereiro\"; break; case 3: cout << \"Marco\"; break; case 4: cout << \"Abril\"; break; case 5: cout << \"Maio\"; break; case 6: cout << \"Junho\"; break; case 7: cout << \"Julho\"; break; case 8: cout << \"Agosto\"; break; case 9: cout << \"Setembro\"; break; case 10: cout << \"Outubro\"; break; case 11: cout << \"Novembro\"; break; case 12: cout << \"Dezembro\"; break; default: cout << \"Hein?-zembro\"; break; } cout << \" de \" << ano << endl; return 0; } \\end{lstlisting}","title":"include "},{"location":"intro/#exercicios_6","text":"\\begin{exercicio} \\label{exe:switch:1} Implemente uma fun\u00e7\u00e3o chamada \\lstinline|menu| que imprima o seguinte menu na tela: \\begin{enumerate} \\item Soma \\item M\u00e9dia \\item Menor \\item Maior \\end{enumerate} Leia e que retorne o n\u00famero da op\u00e7\u00e3o escolhida. Implemente a fun\u00e7\u00e3o \\lstinline|main| de forma a ler tr\u00eas n\u00fameros e, ent\u00e3o, invocar a fun\u00e7\u00e3o definida acima para decidir o que fazer. O resultado da fun\u00e7\u00e3o deve ser armazenando em uma vari\u00e1vel e seu conte\u00fado testado com \\lstinline|switch|. Cada op\u00e7\u00e3o deve invocar a fun\u00e7\u00e3o respectiva, que calcular\u00e1 e retornar\u00e1 o que se pede. A fun\u00e7\u00e3o \\lstinline|main| imprimir\u00e1 ent\u00e3o o resultado. \\begin{lstlisting}","title":"{Exerc\u00edcios}"},{"location":"intro/#include_18","text":"","title":"include "},{"location":"intro/#include_19","text":"","title":"include "},{"location":"intro/#include_20","text":"using namespace std; int menu() { int opcao; cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; return opcao; } int menor(int x, int y, int z) { if(x <= y && x <= z) return x; if(y <= x && y <= z) return y; return z; } int maior(int x, int y, int z) { if(x >= y && x >= z) return x; else if(y >= x && y<= z) return y; else return z; } int soma(int x, int y, int z) { return x+y+z; } float media(int x, int y, int z) { float somatorio = soma(x,y,z); return somatorio / 3.0; } int main() { int a, b, c; int opcao; cout << \"digite tres numero inteiros\" <<endl; cin >> a >> b >> c; opcao = menu(); switch(opcao) { case 1: cout << \"A soma dos tres numeros eh \" << soma(a,b,c); break; case 2: cout << \"A media dos tres numeros eh \" << media(a,b,c); break; case 3: cout << \"O menor dentre os tres numeros eh \" << menor(a,b,c); break; case 4: cout << \"O maior dentre os tres numeros eh \" << maior(a,b,c); break; default: cout << \"Opcao invalida. Execute o programa novamente e leia direito as opcoes.\"; } return 0; } \\end{lstlisting} \\end{exercicio} \\[\\begin{exercicio} Escreva um programa com uma fun\u00e7\u00e3o que receba um inteiro entre 1 e 7, inclusive, e escreva o dia correspondente da semana (1 para domingo e 7 para s\u00e1bado). \\end{exercicio}\\] \\begin{exercicio} \\label{exe:switch:3} Escreva um programa com uma fun\u00e7\u00e3o que receba um inteiro de 1 a 12 e retorne a quantidade de dias no m\u00eas correspondente (assuma que o ano n\u00e3o \u00e9 bisexto). Para este exerc\u00edcio, a solu\u00e7\u00e3o mais simples envolve n\u00e3o colocar \\lstinline|break| em alguns dos \\lstinline|case|. \\end{exercicio}","title":"include "},{"location":"intro/#laboratorio_3","text":"Implemente os exerc\u00edcios de \\ref{exe:switch:1} a \\ref{exe:switch:3}. \\chapter{Repeti\u00e7\u00e3o (I)} Em certas situa\u00e7\u00f5es \u00e9 necess\u00e1ria a repeti\u00e7\u00e3o de um conjunto de comandos. Em situa\u00e7\u00f5es como esta, temos duas op\u00e7\u00f5es: ou copiamos e colamos todo o trecho que desejamos repetir, fazendo os ajustes necess\u00e1rios; ou utilizamos uma sa\u00edda mais inteligente por meio de comandos especiais que permitem automatizar a repeti\u00e7\u00e3o. Neste cap\u00edtulo veremos o comando de repeti\u00e7\u00e3o \\lstinline|while| e alguns exemplos de seu uso.","title":"{Laborat\u00f3rio}"},{"location":"intro/#motivacao","text":"Suponha de voc\u00ea deseja fazer um programa para ler duas notas, calcular e imprimir a m\u00e9dia de dez alunos da disciplina. A maneira menos pr\u00e1tica de fazer isso seria: \\[\\begin{lstlisting} ... float nota1, nota2, media; cout << \"Entre nota 1 e nota 2 do aluno 1: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 2: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 3: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 4: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 5: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 6: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 7: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 8: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 9: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; cout << \"Entre nota 1 e nota 2 do aluno 10: \" << endl; cin >> nota1 >> nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; ... \\end{lstlisting}\\] Este c\u00f3digo tem v\u00e1rios problemas. Primeiro, ele \u00e9 mais propenso a erros; se, por exemplo, voc\u00ea resolve renomear a vari\u00e1vel \\lstinline|nota2| para \\lstinline|notab|, voc\u00ea ter\u00e1 que faz\u00ea-lo em diversos pontos do programa, aumentando a possibilidade de esquecer algum. Em segundo lugar, o c\u00f3digo exigiu grande retrabalho, isto \u00e9, a repeti\u00e7\u00e3o de uma mesma tarefa por parte do programador. Finalmente, se voc\u00ea precisar aumentar a quantidade de repeti\u00e7\u00f5es para, digamos, 100 alunos, ter\u00e1 que estender o c\u00f3digo por p\u00e1ginas e p\u00e1ginas. Para evitar tais problemas, para estas situa\u00e7\u00f5es a linguagem C(++) fornece estruturas de repeti\u00e7\u00f5es, as quais permitem repetir um determinado conjunto de comandos.","title":"{Motiva\u00e7\u00e3o}"},{"location":"intro/#o-comando-lstinlinewhile","text":"Um destes comandos \u00e9 o comando \\lstinline|while| (enquanto, em portugu\u00eas). Sua forma geral \u00e9 muito simples: \\[\\begin{lstlisting} while (<condicao>) { // bloco de comandos a ser repetido } \\end{lstlisting}\\] O bloco de comandos entre as chaves ser\u00e1 repetido \\textbf{enquanto a condi\u00e7\u00e3o dentro dos par\u00eanteses for verdadeira}. Utilizando o \\lstinline|while|, o exemplo anterior pode ser reescrito de maneira bem mais pr\u00e1tica: \\begin{lstlisting} ... float nota1, nota2, media; int i = 1; // valor inicial do identificador do aluno while (i <= 10) { cout << \"Entre nota 1 e nota 2 do aluno: \" << endl; cin << nota1 << nota2; media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; i = i +1; // aumentamos o valor de i no final de cada calculo da media } ... \\end{lstlisting} Observe as seguintes modifica\u00e7\u00f5es: \\begin{itemize} \\item Uma nova vari\u00e1vel, \\lstinline|i|, foi criada para contabilizar o n\u00famero de alunos. \\item Esta vari\u00e1vel \u00e9 inicializada com o valor 1, representando o primeiro aluno. \\item A condi\u00e7\u00e3o dentro do comando de repeti\u00e7\u00e3o ser\u00e1 verdadeira enquanto o valor de \\lstinline|i| for menor ou igual a 10. \\item Por este motivo, devemos incrementar o valor de \\lstinline|i| ao fim de cada ciclo. \\end{itemize} Normalmente, a vari\u00e1vel que conta a quantidade de itera\u00e7\u00f5es executadas, \\lstinline|i| no exemplo dado, \u00e9 chamada de contadora. No exemplo, a vari\u00e1vel contadora foi usada apenas para este fim, contar, e n\u00e3o aparece no bloco de comandos sendo repetido. Isto nem sempre \u00e9 o caso, como veremos em outros exemplos. Antes, por\u00e9m, vejamos uma varia\u00e7\u00e3o do \\lstinline|while|.","title":"{O comando \\lstinline|while|}"},{"location":"intro/#o-comando-lstinlinedo-while","text":"Se por acaso a condi\u00e7\u00e3o verificada no \\lstinline|while| for inicialmente falsa, o bloco n\u00e3o ser\u00e1 repetido nem mesmo uma vez. Para situa\u00e7\u00f5es em que \u00e9 preciso executar o bloco pelo menos uma vez, uma varia\u00e7\u00e3o do comando \\lstinline|while| \u00e9 fornecida pela linguagem C. Trata-se do comando \\lstinline|do-while| (fa\u00e7a-enquanto ou repita-enquanto, em portugu\u00eas). Sua forma geral \u00e9 dada por: \\begin{lstlisting} do { \\ bloco de comandos \\ a ser repetido } while ( ); \\end{lstlisting} O mesmo exemplo anterior pode ser reescrito utilizando este comando: \\[\\begin{lstlisting} do { cout << \"Entre nota 1 e nota 2 do aluno : \" << endl; cin >> nota1 >> nota2; i = 1+1; // aumentamos o valor de i no final de cada calculo da media media = (nota1 + nota2) / 2; cout << \"A media das notas eh \" << media << endl; } while (i <= 10); \\end{lstlisting}\\] Em compara\u00e7\u00e3o ao comando \\lstinline|while|, a \u00fanica diferen\u00e7a existente \u00e9 o fato do teste da condi\u00e7\u00e3o ser feito ap\u00f3s a execu\u00e7\u00e3o do bloco de comandos que se deseja repetir. Uma implica\u00e7\u00e3o disto \u00e9 que, em casos em que a condi\u00e7\u00e3o \u00e9 falsa logo no primeiro teste, o bloco de comandos \u00e9 executado com \\lstinline|do-while|, mas n\u00e3o \u00e9 executado com \\lstinline|while|. Isto aconteceria para a vari\u00e1vel \\lstinline|i| com valor inicial de 11, por exemplo.","title":"{O comando \\lstinline|do-while|}"},{"location":"intro/#mais-exemplos","text":"Considere que deseja-se somar todos os n\u00fameros pares entre 1 e 999. Ou fazemos uma soma com todos os valores em uma linha enorme, ou utlizamos o que apresendemos sobre comandos de repeti\u00e7\u00e3o. Utilizando o \\lstinline|while|, ter\u00edamos: \\[\\begin{lstlisting} ... int n = 2, // primeiro par maior do que 1 soma = 0; // soma inicialmente zerada while (n < 999) { soma = soma + n; n = n + 2; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] Observe que a cada itera\u00e7\u00e3o o valor de soma \u00e9 acrescido do pr\u00f3ximo n\u00famero par, o qual \u00e9 obtido somando-se 2 ao valor de \\lstinline|n|. Imagine que se deseja obter o maior entre 10 n\u00fameros inteiros lidos. Utilizando o \\lstinline|do-while|, uma poss\u00edvel solu\u00e7\u00e3o seria: \\[\\begin{lstlisting} ... int i = 0, // contador da qtde de numeros lidos maior, n; do { cout << \"Entre um numero: \"; cin >> n; if (i == 0) // se for o primeiro numero lido { // ele sera o menor maior = n; } else // a partir do segundo { if(n > maior) // atualizo o maior { maior = n; } } i = i + 1; } while (i < 10); ... \\end{lstlisting}\\] Neste exemplo temos uma situa\u00e7\u00e3o especial em que, no primeiro caso (\\lstinline|i = 0|), o maior valor \u00e9 o \u00fanico valor lido. A partir do segundo n\u00famero, se o n\u00famero lido for maior do que o valor armazenado na vari\u00e1vel \\lstinline|maior|, esta ser\u00e1 atualizada. Em outro exemplo, imagine que queira ler n\u00fameros at\u00e9 que leia um n\u00famero maior que 100. Neste caso, o seguinte programa resolveria nosso problema. \\[\\begin{lstlisting} ... int num; do { cout << \"Entre um numero: \"; cin >> num; } while (! num > 100); ... \\end{lstlisting}\\] Neste exemplo utilizamos \\lstinline|do-while| pois \u00e9 necess\u00e1rio ler pelo menos um n\u00famero. Reescreva o c\u00f3digo utilizando \\lstinline|while| e veja como fica, necessariamente, mais complexo.","title":"{Mais exemplos}"},{"location":"intro/#operadores-de-incremento-e-outras-construcoes-especiais","text":"Nos exemplos apresentados, a vari\u00e1vel contadora foi manipulada em todas as repeti\u00e7\u00f5es de uma forma bem comum, sendo incrementada de 1 em 1 ou de 2 em 2. Repeti\u00e7\u00f5es tem esta caracter\u00edstica, embora as opera\u00e7\u00f5es aplicadas aos contadores n\u00e3o sejam sempre simples incrementos e decrementos. Com a finalidade de agilizar o desenvolvimento e simplificar algumas opera\u00e7\u00f5es aritm\u00e9ticas mais comuns, a linguagem C(++) permite algumas constru\u00e7\u00f5es especiais envolvendo operadores. Considere o seguinte trecho de c\u00f3digo: \\begin{lstlisting} int a, b; ... a = a + b; b = b * 2; a = a / 7; \\end{lstlisting} Observe que nas tr\u00eas atribui\u00e7\u00f5es (indicadas pelo sinal de igualdade), as vari\u00e1veis que s\u00e3o atualizadas tamb\u00e9m aparecem como primeiro elemento da opera\u00e7\u00e3o aritm\u00e9tica \u00e0 esquerda. Nestas situa\u00e7\u00f5es, podemos reescrever as atribui\u00e7\u00f5es assim: \\begin{lstlisting} int a, b; ... a += b; b *= 2; a /= 7; \\end{lstlisting} As opera\u00e7\u00f5es de incremento (aumento de uma unidade) e o decremento (diminui\u00e7\u00e3o de uma unidade) de uma vari\u00e1vel s\u00e3o muito comuns em programa\u00e7\u00e3o. Sendo assim, a linguagem C define dois operadores para as mesmas: \\verb|++| e \\verb|--|, respectivamente. Veja o exemplo. \\[\\begin{lstlisting} int a = 0; a = a + 1; cout << \"a = \" << a << endl; a += 1; cout << \"a = \" << a << endl; a++; cout << \"a = \" << a << endl; a--; cout << \"a = \" << a << endl; \\end{lstlisting}\\] O trecho acima deve imprimir os valores de \\lstinline|a|, ou seja, 1, 2, 3 e 2. \\newpage","title":"{Operadores de incremento e outras constru\u00e7\u00f5es especiais}"},{"location":"intro/#exercicios_7","text":"\\[\\begin{exercicio} Diga o que ser\u00e1 escrito na tela durante a execu\u00e7\u00e3o do seguinte trecho de c\u00f3digo: \\begin{lstlisting} int a, b = 0, c = 0; a = ++b + ++c; cout << a << \", \" << b << \", \" << c << endl; a = b++ + c++; cout << a << \", \" << b << \", \" << c << endl; a = ++b + c++; cout << a << \", \" << b << \", \" << c << endl; a = b-- + --c; cout << a << \", \" << b << \", \" << c << endl; \\end{lstlisting} \\end{exercicio}\\] \\todo{Incluir exerc\u00edcios mais simples como os da lista 1 do Prof. Anilton.} Fa\u00e7a os exerc\u00edcios a seguir \u00e0 m\u00e3o. \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o que recebe um n\u00famero inteiro positivo e retorna o fatorial deste n\u00famero. A fun\u00e7\u00e3o principal deve ler o n\u00famero do qual se deseja calcular o fatorial e imprimir o resultado. \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a uma fun\u00e7\u00e3o que recebe um n\u00famero inteiro positivo e retorna \\lstinline|true| se o n\u00famero for primo ou \\lstinline|false|, caso contr\u00e1rio. A fun\u00e7\u00e3o principal (\\lstinline|main|) deve ler o n\u00famero e imprimir o resultado. \\end{exercicio}\\] \\[\\begin{exercicio} Modifique o programa anterior para imprimir todos os n\u00fameros primos abaixo de dois milh\u00f5es. \\end{exercicio}\\] \\[\\begin{exercicio} Fa\u00e7a um programa que leia um n\u00famero inteiro positivo e imprima esse n\u00famero de tr\u00e1s pra frente. A impress\u00e3o deve ser feita pela fun\u00e7\u00e3o auxiliar \\texttt{inverteNumero}. \\end{exercicio}\\] \\newpage","title":"{Exerc\u00edcios}"},{"location":"intro/#laboratorio_4","text":"\\[\\begin{lab} Implemente os exerc\u00edcios acima no Code::Blocks. \\end{lab}\\] \\[\\begin{lab} Escreva uma fun\u00e7\u00e3o que receba dois par\u00e2metros inteiros, $x$ e $y$, $x < y$ e que imprima $y$ pontos na tela e que a cada $x$ pontos, imprima um acento circunflexo. \\end{lab}\\] \\begin{lab} \\label{exer:floyd} O exerc\u00edcio \\ref{exer:menu} pedia que voc\u00ea escrevesse uma fun\u00e7\u00e3o que gerasse um menu na tela. A fun\u00e7\u00e3o que voc\u00ea escreveu tinha um problema: ela aceitava qualquer valor, mesmo algum n\u00e3o correspondendo a nenhuma op\u00e7\u00e3o do menu. Usando \\lstinline|do-while|, altere sua fun\u00e7\u00e3o para que continue exibindo o menu e lendo uma op\u00e7\u00e3o at\u00e9 que uma op\u00e7\u00e3o v\u00e1lida seja digitada pelo usu\u00e1rio. \\end{lab} \\begin{lab} Implemente uma fun\u00e7\u00e3o chamada \\lstinline|pot| que receba um n\u00famero real e um inteiro, respectivamente \\lstinline|base| e \\lstinline|expoente|, como par\u00e2metros e que calcule \\small{ \\(\\texttt{base}^\\texttt{expoente}\\) }. A fun\u00e7\u00e3o \\lstinline|pot|, que voc\u00ea implementar\u00e1, deve usar multiplica\u00e7\u00f5es sucessivas para calcular seu resultado (isto \u00e9, \u00e9 proibido o uso da fun\u00e7\u00e3o \\lstinline|pow|). \\end{lab} \\begin{lab} Execute o seguinte programa em seu computador e observe o que acontece. \\[\\begin{lstlisting} ... int num = 10; do { cout << num; num *= 2; } while (1); ... \\end{lstlisting}\\] \u00c0 prop\u00f3sito, para terminar um programa basta digitar a combina\u00e7\u00e3o de teclas \\texttt{ctrl+c}. \\end{lab} \\[\\begin{lab} Escreva um programa que leia um numero inteiro positivo \\texttt{n} e em seguida imprima \\texttt{n} linhas do chamado Tri\u00e2ngulo de Floyd:\\\\ \\begin{verbatim} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \\end{verbatim} \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que gera um n\u00famero inteiro aleat\u00f3rio de 1 a 1000 em uma fun\u00e7\u00e3o denominada \\lstinline|geraNumero|. Na fun\u00e7\u00e3o principal, o usu\u00e1rio deve tentar acertar qual o n\u00famero foi gerado. A cada tentativa o programa dever\u00e1 informar se o chute \u00e9 menor ou maior que o n\u00famero gerado. O programa acaba quando o usu\u00e1rio acerta o n\u00famero gerado. O programa deve informar em quantas tentativas o n\u00famero foi descoberto. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que receba como entrada o valor do saque realizado pelo cliente de um banco e retorne quantas notas de cada valor ser\u00e3o necess\u00e1rias para atender ao saque com a menor quantidade de notas poss\u00edvel. Ser\u00e3o utilizadas notas de 100, 50, 20, 10, 5, 2 e 1 reais. O c\u00e1lculo e impress\u00e3o do resultado deve ser efetuado por uma fun\u00e7\u00e3o auxiliar denominada \\texttt{imprimeNotas}. \\end{lab}\\] \\chapter{Repeti\u00e7\u00e3o (II)} Voc\u00ea deve ter percebido que no uso de \\lstinline|do-while| e \\lstinline|while| quase sempre seguimos os mesmos passos: \\begin{itemize} \\item declarar uma vari\u00e1vel que sirva de controle para a itera\u00e7\u00e3o; \\item iniciar a vari\u00e1vel de controle (e possivelmente outras); \\item verificar a condi\u00e7\u00e3o para itera\u00e7\u00e3o \\item executar itera\u00e7\u00e3o \\item executar incremento/decremento (mudan\u00e7a da vari\u00e1vel de controle) \\end{itemize} A linguagem C tem um comando itera\u00e7\u00e3o que agrega todos estes passos, chamado \\lstinline|for|.","title":"{Laborat\u00f3rio}"},{"location":"intro/#lstinlinefor","text":"Sua forma geral do comando \\lstinline|for| \u00e9 a seguinte: \\begin{lstlisting} for(DI; C; I) { \\bloco de comandos a ser repetido } \\end{lstlisting} O comando \\lstinline|for| tem tr\u00eas partes em sua declara\u00e7\u00e3o, al\u00e9m dos comandos a serem repetidos. \\begin{itemize} \\item DI -- em DI vari\u00e1veis podem ser \\textbf{D}eclaradas e \\textbf{I}niciadas. Vari\u00e1veis j\u00e1 existentes tamb\u00e9m podem ter seus valores ajustados em DI; \\item C -- C define a \\textbf{C}ondi\u00e7\u00e3o necess\u00e1ria \u00e0 execu\u00e7\u00e3o do bloco de comandos. \\emph{Enquanto} a condi\u00e7\u00e3o for verdadeira, o bloco ser\u00e1 executado. \\item I -- comandos de modifica\u00e7\u00e3o de vari\u00e1veis, como \\textbf{I}ncremento e decremento, s\u00e3o colocados diretamente na declara\u00e7\u00e3o do \\lstinline|for|. O comando \u00e9 executado ao final de cada itera\u00e7\u00e3o. \\end{itemize} A execu\u00e7\u00e3o do \\lstinline|for| segue os seguintes passos: \\begin{enumerate} \\item Inicia\u00e7\u00e3o (execu\u00e7\u00e3o de DI) \\item Avalia\u00e7\u00e3o (teste da condi\u00e7\u00e3o em C) \\item Execu\u00e7\u00e3o do bloco de comandos \\item Incremento \\item De volta ao passo 2 \\end{enumerate} Considere o exemplo do cap\u00edtulo anterior em que deseja-se somar todos os n\u00fameros pares entre 1 e 999. O c\u00f3digo pode ser escrito, como vimos, usando \\lstinline|while|. \\[\\begin{lstlisting} ... int n = 2, // primeiro par maior do que 1 soma = 0; // soma inicialmente zerada while (n < 999) { soma = soma + n; n += 2; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] O c\u00f3digo equivalente, usando \\lstinline|for| \u00e9 essencialmente o mesmo. \\[\\begin{lstlisting} ... int n, // primeiro par maior do que 1 soma = 0; // soma inicialmente zerada for (n = 2; n < 999; n += 2) { soma = soma + n; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] O c\u00f3digo, contudo, pode ser simplificado colocando-se a declara\u00e7\u00e3o da vari\u00e1vel de controle no pr\u00f3prio \\lstinline|for|. \\[\\begin{lstlisting} ... int soma = 0; // soma inicialmente zerada for (int n = 2; n < 999; n += 2) { soma = soma + n; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\] \u00c9 poss\u00edvel declarar e iniciar mais de uma vari\u00e1vel no DI, mas n\u00e3o \u00e9 poss\u00edvel definir novas vari\u00e1veis e iniciar outras j\u00e1 definidas. No exemplo abaixo, errado, a vari\u00e1vel soma sendo iniciada no \\lstinline|for| \u00e9 diferente da vari\u00e1vel definida antes do comando, apesar do nome ser igual. \\[\\begin{lstlisting} ... int soma = 0; // soma inicialmente zerada for (int n = 2, soma = 0; n < 999; n += 2) { soma = soma + n; } cout << \"O valor da soma eh \" << soma << endl; ... \\end{lstlisting}\\]","title":"{\\lstinline|for|}"},{"location":"intro/#mais-exemplos_1","text":"Tamb\u00e9m do cap\u00edtulo anterior, imagine o exemplo em que se deseja obter o maior entre 10 n\u00fameros inteiros lidos. Utilizando o \\lstinline|for|, uma poss\u00edvel solu\u00e7\u00e3o seria: \\begin{lstlisting} ... int i, // contador da qtde de numeros lidos maior, n; cout << \"Entre um numero: \"; cin >> n; maior = n; for(i = 0; i < 9; i++) { cout << \"Entre um numero: \"; cin >> n; if(n > maior) // atualizo o maior { maior = n; } } ... \\end{lstlisting} Observe que a primeira leitura aconteceu fora do \\lstinline|for|.","title":"{Mais Exemplos}"},{"location":"intro/#declaracoes-especiais","text":"Em certas situa\u00e7\u00f5es pode ser desej\u00e1vel omitir partes da declara\u00e7\u00e3o do \\lstinline|for|. Por exemplo, se as vari\u00e1veis de controle j\u00e1 tiverem sido iniciadas ou, simplesmente, se n\u00e3o existirem, ou se n\u00e3o houver incremento a ser feito, ent\u00e3o estas partes da declara\u00e7\u00e3o podem ser deixadas em branco. Por exemplo, \\begin{lstlisting} int menu() { int opcao = 0; for( ; opcao < 1 || opcao > 4 ; ) { cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; } return opcao; } \\end{lstlisting} Observe que embora neste exemplo tanto DI quanto I est\u00e3o vazias, isso n\u00e3o \u00e9 necess\u00e1rio. Isto \u00e9, qualquer das partes da declara\u00e7\u00e3o podem estar vazias independentemente, inclusive a segunda parte.","title":"{Declara\u00e7\u00f5es especiais}"},{"location":"intro/#alterando-a-repeticao-com-o-lstinlinebreak-e-lstinlinecontinue","text":"Caso a segunda parte do comando esteja vazia, a repeti\u00e7\u00e3o ser\u00e1 executada \\emph{ad infinitum} ou at\u00e9 que seja interrompida. A interrup\u00e7\u00e3o de uma itera\u00e7\u00e3o pode ser feita usando-se o comando \\lstinline{break}. Veja o exemplo anterior reescrito para usar tal comando. \\begin{lstlisting} int menu() { int opcao; for(;;) { cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; if(opcao > 0 && opcao < 5) break; else cout << \"Opcao invalida\" << endl << endl; } return opcao; } \\end{lstlisting} Outra forma de se alterar o fluxo \u00e9 via o comando \\lstinline{continue}, que faz com que a o restante do bloco de comandos seja ignorado e, conseq\u00fcentemente, incremento e condi\u00e7\u00e3o sejam reavaliados. Por exemplo, reescrevendo o c\u00f3digo acima para o usar o \\lstinline{continue}. \\begin{lstlisting} int menu() { int opcao; for(;;) { cout << \"1 Soma\" << endl << \"2 Media\" << endl << \"3 Menor\" << endl << \"4 Maior\" << endl; cout << \"Qual sua opcao? \"; cin >> opcao; if(opcao < 1 || opcao > 4) continue; cout << \"A opcao escolhida foi \" << opcao; break; } return opcao; } \\end{lstlisting}","title":"{Alterando a repeti\u00e7\u00e3o com o \\lstinline!break! e \\lstinline!continue!}"},{"location":"intro/#exercicios_8","text":"\\[\\begin{exercicio} Refa\u00e7a os exec\u00edcios do cap\u00edtulo anterior usando \\lstinline|for|. \\end{exercicio}\\]","title":"{Exerc\u00edcios}"},{"location":"intro/#laboratorio_5","text":"\\[\\begin{lab} Refa\u00e7a o laborat\u00f3rio do cap\u00edtulo anterior usando \\lstinline|for|. \\end{lab}\\] \\begin{lab} Escreva uma fun\u00e7\u00e3o que receba dois par\u00e2metros inteiros, X e Y, e imprima X linhas na tela, cada uma com Y ``.''. Por exemplo, se sua fun\u00e7\u00e3o for invocada com X igual 3 e Y igual 2, o resultado deveria ser o seguinte \\begin{verbatim} .. .. .. \\end{verbatim} \\end{lab} \\[\\begin{lab} Escreva uma fun\u00e7\u00e3o que receba dois par\u00e2metros inteiros, X e Y, e imprima de forma decrescente os n\u00fameros de X*Y at\u00e9 1, em X linhas de Y n\u00fameros. Por exemplo, se sua fun\u00e7\u00e3o for invocada com X igual 4 e Y igual 3, o resultado deveria ser o seguinte \\begin{verbatim} 12 11 10 9 8 7 6 5 4 3 2 1 \\end{verbatim} \\end{lab}\\] \\chapter{Arranjos Unidimensionais} Tente resolver o seguinte problema: \\begin{enumerate} \\item ler um conjunto de 6 n\u00fameros inteiros \\item calcular sua m\u00e9dia \\item imprimir todos os n\u00fameros maiores que a m\u00e9dia na tela do computador \\end{enumerate} F\u00e1cil, certo? Basta declarar 6 vari\u00e1veis do tipo \\lstinline|int|, ler seus valores, somar seus valores e dividir por 6, calculando a m\u00e9dia. Finalmente, basta escolher aquelas vari\u00e1veis com n\u00fameros maiores que a m\u00e9dia e imprim\u00ed-las. Mas e se alter\u00e1ssemos o problema para que, em vez de 6, precisasse ler 10 n\u00fameros, ou 100? Ainda assim se poderia usar o mesmo algoritmo, com 10 ou 100 vari\u00e1veis em vez de 6. Mas ter muitas vari\u00e1veis distintas com a mesma finalidade n\u00e3o \u00e9 vi\u00e1vel por duas raz\u00f5es: \\begin{itemize} \\item dif\u00edcil de manter: se voc\u00ea precisar renomear uma vari\u00e1vel, ter\u00e1 que faz\u00ea-lo em todas as vari\u00e1veis;\\ se precisar aumentar ou diminuir o n\u00famero de vari\u00e1veis, ter\u00e1 que apagar/copiar e renomear. \\item evita reuso de c\u00f3digo: se uma mesma opera\u00e7\u00e3o precisa ser aplicada a cada vari\u00e1vel, o mesmo c\u00f3digo deve ser reescrito para cada vari\u00e1vel, dificultado o reuso de c\u00f3digo. \\end{itemize} A solu\u00e7\u00e3o para esta situa\u00e7\u00e3o \u00e9 o uso de vetores (ou vari\u00e1veis indexadas, ou arranjo, ou \\emph{array}).","title":"{Laborat\u00f3rio}"},{"location":"intro/#vetores","text":"Continuando com nossa analogia da mem\u00f3ria do computador como uma planilha eletr\u00f4nica, um vetor \u00e9 uma vari\u00e1vel que nomeia diversas c\u00e9lulas cont\u00edguas da mem\u00f3ria do computador. Isto \u00e9, de certa forma, enquanto uma vari\u00e1vel \\lstinline|int| corresponde a uma \u00e1rea da mem\u00f3ria que cabe 1 inteiro, um vetor de 10 \\lstinline|int| \u00e9 uma vari\u00e1vel que cabe 10 inteiros. A sintaxe para a declara\u00e7\u00e3o est\u00e1tica de vetores \u00e9 bem simples (em cap\u00edtulos futuros veremos como declarar vetores din\u00e2micos, isto \u00e9, que podem variar seus tamanhos). \\[\\begin{verbatim} tipo identificador[tamanho]; \\end{verbatim}\\] Onde \\begin{itemize} \\item tipo -- \u00e9 o tipo do dado a ser armazenado em cada posi\u00e7\u00e3o do vetor; \\item identificador -- \u00e9 o nome do vetor; \\item tamanho -- \u00e9 a quantidade de c\u00e9lulas no vetor; \\end{itemize} O acesso a uma c\u00e9lula, para leitura ou atribui\u00e7\u00e3o, \u00e9 feito usando-se o identificador seguido pela posi\u00e7\u00e3o a ser acessada, entre colchetes (\\lstinline{[]}). Por exemplo, \\lstinline{x[3] = 0} atribui o valor 0 \u00e0 posi\u00e7\u00e3o de \u00edndice 3 do vetor \\lstinline|x|. Algo importante a ser observado aqui \u00e9 que a primeira posi\u00e7\u00e3o de um vetor de tamanho \\(n\\) tem \u00edndice 0 e a \u00faltima tem \u00edndice \\(n-1\\) . O exemplo a seguir resolve o problema apresentado na se\u00e7\u00e3o anterior usando vetores. \\begin{lstlisting}","title":"{Vetores}"},{"location":"intro/#include_21","text":"using namespace std;","title":"include"},{"location":"intro/#define-tamanho-10","text":"int main() { int num[TAMANHO]; int soma = 0; int media; for(int i = 0; i < TAMANHO; i++) { cout << \"Digite o \" << i << \"-esimo valor: \"; cin >> num[i]; soma += num[i]; } media = soma/TAMANHO; cout << \"Os valores acima da media \" << media << \" sao\" << endl; for(int i = 0; i < TAMANHO; i++) { if(num[i] > media) cout << num[i] << endl; } return 0; } \\end{lstlisting} Observe a defini\u00e7\u00e3o e o uso da palavra \\lstinline{TAMANHO} no programa. Uma vez definido que \\lstinline{TAMANHO} tem o valor 10, o computador substituir\u00e1 toda ocorr\u00eancia desta palavra no programa pelo valor correspondente, \\emph{antes} da compila\u00e7\u00e3o. Uma varia\u00e7\u00e3o interessante do problema calcula a m\u00e9dia apenas de n\u00fameros positivos e a entrada de um n\u00famero negativo serve para finalizar o fim da entrada. O c\u00f3digo seguinte resolve o problema. \\begin{lstlisting}","title":"define TAMANHO 10"},{"location":"intro/#include_22","text":"using namespace std;","title":"include"},{"location":"intro/#define-tamanho-100","text":"int main() { int num[TAMANHO]; int soma = 0; int media; int contador = 0; for(int i = 0; i < TAMANHO; i++) { cout << \"Digite o \" << i << \"-esimo valor: \"; cin >> num[i]; if(num[i] >= 0) { soma += num[i]; contador++; } else { break; } } media = soma/contador; cout << \"Os valores acima da media \" << media << \" sao\" << endl; for(int i = 0; i < contador; i++) { if(num[i] > media) cout << num[i] << endl; } return 0; } \\end{lstlisting} Observe como a vari\u00e1vel \\lstinline|contador| \u00e9 usada para contar a quantidade de n\u00fameros v\u00e1lidos lidos e como ela \u00e9 usada como limitante da varredura do vetor no segundo \\lstinline|for|. Observe tamb\u00e9m como o \\lstinline|break| \u00e9 utilizado para interromper o \\lstinline|for|.","title":"define TAMANHO 100"},{"location":"intro/#exercicios_9","text":"\\[\\begin{exercicio} Escreva um programa que leia 10 n\u00fameros e imprima o menor e o maior entre eles (n\u00e3o \u00e9 necess\u00e1rio usar vetores aqui). \\end{exercicio}\\] \\[\\begin{exercicio} Escreva um programa que leia 10 n\u00fameros e calcule e imprima a m\u00e9dia e desvio padr\u00e3o dos mesmos. Lembre-se que o desvio padr\u00e3o \u00e9 definido como a raiz quadrada dos quadrados das diferen\u00e7as dos valores para a m\u00e9dia dos valores. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva um programa que leia 11 n\u00fameros reais e imprima os valores dos 10 primeiros multiplicados pelo 11-\u00e9simo. Por exemplo, se os valores digitados foram 1, 2, 3 ,4 ,5 ,6, 7, 8, 9, 10 e 1.1, ent\u00e3o seu programa deve imprimir 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 e 11.0. \\end{exercicio}\\]","title":"{Exerc\u00edcios}"},{"location":"intro/#laboratorio_6","text":"\\[\\begin{lab} Escreva um programa que leia um n\u00famero inteiro \\lstinline|n| e ent\u00e3o leia \\lstinline|n| n\u00fameros reais. Em seguida, seu programa deve imprimir a m\u00e9dia e desvio padr\u00e3o dos n\u00fameros lidos. Seu programa deve \\textbf{ignorar} n\u00fameros negativos. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia \\lstinline|n| n\u00fameros reais e imprima seus valores na tela. Em seguida, leia mais um n\u00famero real \\lstinline|x| e imprima o valor dos \\lstinline|n| n\u00fameros multiplicados \\lstinline|x|. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia \\lstinline|n| booleanos e imprima seus valores na tela. Em seguida, imprima todos os booleanos invertidos, na linha seguinte. \\end{lab}\\] \\chapter{Caracteres, Vetores de Caracteres e Strings}","title":"{Laborat\u00f3rio}"},{"location":"intro/#representacao-de-caracteres","text":"Al\u00e9m dos tipos de dados num\u00e9ricos com os quais temos trabalhado at\u00e9 agora, outro tipo de dado \u00e9 muito importante no desenvolvimento de programas de computador, o tipo caractere. Estes tipos s\u00e3o a base para representa\u00e7\u00e3o de informa\u00e7\u00e3o textual como, por exemplo, a frase \"eu amo programar em C\"? Vari\u00e1veis com caracteres, em C(++), s\u00e3o declarados com sendo do tipo \\lstinline|char|, e sua leitura e escrita ocorre como para qualquer outro tipo de dados. Por exemplo, \\begin{lstlisting}","title":"{Representa\u00e7\u00e3o de caracteres}"},{"location":"intro/#include_23","text":"using namespace std; int main() { char letra; cout << \"digite uma letra qualquer seguida de enter \"; cin >> letra; cout << \"voce digitou \"<< letra << endl; return 0; } \\end{lstlisting} Se voc\u00ea pretende atribuir um caracter diretamente a uma vari\u00e1vel, \u00e9 importante se atentar \u00e0 seguinte nota\u00e7\u00e3o: caracteres s\u00e3o sempre escritos entre aspas simples. Por exemplo, \\lstinline|'a'|, \\lstinline|'3'| ou \\lstinline|'.'|. Raramente voc\u00ea trabalhar\u00e1 com caracteres um a um, normalmente usando vetores para armazenar palavras e frases.","title":"include"},{"location":"intro/#vetores-de-caracteres","text":"Vetores podem conter dados de quaisquer tipos. Isto \u00e9, voc\u00ea pode declarar vetores de n\u00fameros reais ou inteiros, booleanos, e at\u00e9 tipos definidos por voc\u00ea, uma vez que aprenda como definir novos tipos. Um outro tipo interessante \u00e9 o caractere, ou simplesmente \\lstinline|char|. Por exemplo, vamos definir um programa que leia um vetor de 10 caracteres e depois os escreva de volta \u00e0 tela. \\begin{lstlisting}","title":"{Vetores de Caracteres}"},{"location":"intro/#include_24","text":"using namespace std;","title":"include"},{"location":"intro/#define-tamanho-10_1","text":"int main() { char nome[TAMANHO]; cout << \"Digite \" << TAMANHO << \" caracteres: \"; for(int i = 0; i < TAMANHO; i++) { cin >> nome[i]; } cout << \"Os caracteres digitados foram: \"; for(int i = 0; i < TAMANHO; i++) { cout << nome[i]; } cout << endl; return 0; } \\end{lstlisting} Agora, s\u00f3 para tornar as coisas mais interessantes, alteremos o programa para que leia \\emph{at\u00e9} 100 caracteres, mas que pare de l\u00ea-los t\u00e3o logo um ``.'' seja digitado. Para representar um caractere em C(++), use aspas simples, isto \u00e9, \\lstinline|'.'|. \\begin{lstlisting}","title":"define TAMANHO 10"},{"location":"intro/#include_25","text":"using namespace std;","title":"include"},{"location":"intro/#define-tamanho-100_1","text":"int main() { char nome[TAMANHO]; int i = 0; cout << \"Digite ate \" << TAMANHO << \" caracteres. Para terminar antes, digite '.' \"; do { cin >> nome[i]; i++; }while( i < TAMANHO && nome[i-1] != '.'); cout << \"Os caracteres digitados foram: \" for(int i = 0; i < TAMANHO && nome[i] != '.'; i++) { cout << nome[i]; } cout << endl; return 0; } \\end{lstlisting} Caracteres s\u00e3o, na verdade, n\u00fameros disfar\u00e7ados e seguem uma codifica\u00e7\u00e3o espec\u00edfica. Uma pessoa pode decidir que o 'a' ser\u00e1 o 1, o 'b' ser\u00e1 o 2 e assim por diante. Mas como outra pessoa que receber a informa\u00e7\u00e3o saber\u00e1 disso? Para evitar este problema a representa\u00e7\u00e3o de caracteres como n\u00fameros foi padronizada. Os principais padr\u00f5es existentes s\u00e3o: ASCII, EBCDIC e Unicode.","title":"define TAMANHO 100"},{"location":"intro/#ascii","text":"ASCII, ou \\emph{American Standard Code for Information Interchange}, \u00e9 o padr\u00e3o mais utilizado, presente em todos os nossos computadores pessoais. Trata-se de uma codifica\u00e7\u00e3o de caracteres de oito bits baseada no alfabeto ingl\u00eas. A codifica\u00e7\u00e3o define 256 caracteres ( \\(2^8\\) ). Desses, 33 n\u00e3o s\u00e3o imprim\u00edveis, como caracteres de controle atualmente n\u00e3o utiliz\u00e1veis para edi\u00e7\u00e3o de texto, por\u00e9m amplamente utilizados em dispositivos de comunica\u00e7\u00e3o, que afetam o processamento do texto. Exceto pelo caractere de espa\u00e7o, o restante \u00e9 composto por caracteres imprim\u00edveis. A Figura~\\ref{fig:ascii} exibe a tabela ASCII. \\[\\begin{figure}[!ht] \\centering \\subfigure{ \\includegraphics[width=0.3\\textwidth]{imagens/ascii-1.png} } \\subfigure{ \\includegraphics[width=0.3\\textwidth]{imagens/ascii-2.png} } \\subfigure{ \\includegraphics[width=0.3\\textwidth]{imagens/ascii-3.png} } \\caption{Tabela ASCII} \\label{fig:ascii} \\end{figure}\\] A linguagem C prov\u00ea um atalho para que voc\u00ea n\u00e3o tenha que recorrer \u00e0 tabela ASCII sempre que precisar do valor de um caractere: para obter o valor de um caractere qualquer, basta coloc\u00e1-lo entre aspas simples. Isto \u00e9, para verificar se um caracter \\lstinline{c} \u00e9 uma letra mai\u00fascula, por exemplo, basta efetuar o teste \\lstinline{if(c >= 'A' && c <= 'Z')}.","title":"*{ASCII}"},{"location":"intro/#outras-representacoes","text":"As representa\u00e7\u00f5es EBCDIC (\\textit{Extended Binary Coded Decimal Interchange Code}) e Unicode tamb\u00e9m mapeiam os caracteres em n\u00fameros de 8 e 16 bits, respectivamente. EBCDIC \u00e9 utilizado principalmente em \\textit{mainframes} IBM. O padr\u00e3o Unicode foi criado para acomodar alfabetos com mais de 256 caracteres.","title":"*{Outras representa\u00e7\u00f5es}"},{"location":"intro/#exercicios_10","text":"\\[\\begin{exercicio} Escreva um programa que leia 10 caracteres e os imprima na ordem inversa \u00e0quela em que foram digitados. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva um programa que leia 10 caracteres e os imprima na ordem inversa \u00e0quela em que foram digitados, trocando mai\u00fasculas por min\u00fasculas e vice-versa. \\end{exercicio}\\] \\[\\begin{exercicio} Escreva seu nome na codifica\u00e7\u00e3o ASCII. \\end{exercicio}\\]","title":"{Exerc\u00edcios}"},{"location":"intro/#laboratorio_7","text":"\\[\\begin{lab} Escreva um programa que leia 100 caracteres ou at\u00e9 que \\lstinline|'#'| seja digitado e os imprima na ordem inversa \u00e0quela em que foram digitados. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia e imprima \\textit{strings} at\u00e9 que o usu\u00e1rio digite a palavra 'fim'. Considere que cada \\textit{string} n\u00e3o possui espa\u00e7os. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia e imprima \\textit{strings} at\u00e9 que o usu\u00e1rio digite a palavra 'fim'. As \\textit{strings} podem conter espa\u00e7os. \\end{lab}\\] \\begin{lab} Acompanhe as atividades a seguir: Execute o seguinte programa e observe o que ser\u00e1 impresso. Atente para as atribui\u00e7\u00f5es! \\begin{lstlisting}","title":"{Laborat\u00f3rio}"},{"location":"intro/#include_26","text":"using namespace std; int main() { int a; char c; for(a = 65; a < 91; a++) { c = a; cout << c << endl; } return 0; } \\end{lstlisting} Voc\u00ea deve ter observado que os n\u00fameros n\u00e3o foram impressos, e sim as letras de 'A' a 'Z'. Olhe a tabela na Figura \\ref{fig:ascii} e descubra o porqu\u00ea. \\end{lab} \\[\\begin{lab} Modifique o programa a seguir para imprimir as letras de 'a' a 'z', ou seja, as letras min\u00fasculas do alfabeto ingl\u00eas. \\end{lab}\\] \\[\\begin{lab} Agora fa\u00e7a um programa que leia caracteres informados pelo usu\u00e1rio enquanto ele n\u00e3o pressionar a tecla ESC. Para cada caractere informado pelo usu\u00e1rio, escreva o n\u00famero correspondente na tabela ASCII. \\end{lab}\\] \\[\\begin{lab} Modifique o programa anterior para que solicite que o usu\u00e1rio entre com letras min\u00fasculas de 'a' a 'z' e imprima na tela, para cada letra, a mai\u00fascula correspondente. \\end{lab}\\]","title":"include"},{"location":"intro/#vetores-de-caracteres-como-textitstrings","text":"Um vetor de caracteres \u00e9 essencialmente uma palavra ou uma frase. Assim, durante a leitura de um vetor de caracteres dificilmente sabe-se quantos caracteres ser\u00e3o digitados pelo usu\u00e1rio, por exemplo, quando deseja-se ler o nome de um indiv\u00edduo. Por este motivo, a maioria das linguagem de programa\u00e7\u00e3o fornece m\u00e9todos especiais de leitura, impress\u00e3o e manipula\u00e7\u00e3o desses vetores de caracteres, ou como chamaremos agora, \\textit{strings}. Na linguagem C++, os comandos \\lstinline|cout| e \\lstinline|cin| permitem imprimir e ler \\textit{strings} de maneira direta: \\begin{lstlisting}","title":"{Vetores de Caracteres como \\textit{Strings}}"},{"location":"intro/#include_27","text":"using namespace std;","title":"include"},{"location":"intro/#define-tamanho-100_2","text":"int main() { char nome[TAMANHO]; cout << \"Digite ate \" << TAMANHO << \" caracteres. Para terminar pressione ENTER:\"; cin >> nome; cout << \"Os caracteres digitados foram: \" << nome << endl; return 0; } \\end{lstlisting} Entretanto, o comando \\lstinline|cin|, n\u00e3o permite, da forma como vimos at\u00e9 agora, a leitura de uma \\textit{string} que contenha espa\u00e7os (uma frase, por exemplo). Para que isso seja poss\u00edvel precisamos utilizar a fun\u00e7\u00e3o \\lstinline|cin.getline()|. Esta fun\u00e7\u00e3o necessita de dois argumentos: o vetor de caracteres representando a \\textit{string} e o tamanho m\u00e1ximo de caracteres que ser\u00e1 lido. A leitura \u00e9 realizada at\u00e9 que seja atingido ou n\u00famero m\u00e1ximo de caracteres ou o usu\u00e1rio pressione a tecla ENTER. A seguir uma modifica\u00e7\u00e3o do exemplo anterior: \\begin{lstlisting}","title":"define TAMANHO 100"},{"location":"intro/#include_28","text":"using namespace std;","title":"include"},{"location":"intro/#define-tamanho-100_3","text":"int main() { char nome[TAMANHO]; cout << \"Digite seu nome completo. Para terminar pressione ENTER:\"; cin.getline(nome, TAMANHO); cout << \"Seu nome eh: \" << nome << endl; return 0; } \\end{lstlisting} Por \u00faltimo, \u00e9 importante entender que para marcar no vetor de caracteres at\u00e9 onde foi feita a leitura a linguagem C adiciona o caractere especial \\lstinline{'\\0'} ap\u00f3s o \u00faltimo caractere digitado pelo usu\u00e1rio. Desta forma, quando se deseja percorrer uma string, diferentemente de um vetor n\u00famero, define-se como condi\u00e7\u00e3o de parada a posi\u00e7\u00e3o em que se encontra o \\lstinline{'\\0'} e n\u00e3o o fim do vetor.","title":"define TAMANHO 100"},{"location":"intro/#laboratorio_8","text":"\\[\\begin{lab} Fa\u00e7a um programa que leia uma string e calcule e imprima o tamanho desta string em uma fun\u00e7\u00e3o auxiliar. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia uma string e verifique se a string lida \u00e9 uma pal\u00edndrome. A verifica\u00e7\u00e3o deve ser feita em uma fun\u00e7\u00e3o auxiliar, que deve retornar \\lstinline{true} em caso afirmativo ou \\lstinline{false} caso contr\u00e1rio. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia uma string e a imprima de tr\u00e1s para frente, trocando as vogais pelo caractere '*'. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia duas strings e concatene a segunda na primeira, separadas por um espa\u00e7o em branco. A concatena\u00e7\u00e3o deve ser feita em uma fun\u00e7\u00e3o auxiliar. \\end{lab}\\]","title":"{Laborat\u00f3rio}"},{"location":"intro/#funcoes-para-manipulacao-textitstrings","text":"Quando trabalhamos com \\textit{strings} \u00e9 muito comum a realiza\u00e7\u00e3o de algumas tarefas como descobrir o tamanho da palavra digitada pelo usu\u00e1rio, comparar duas palavras para saber a ordem, ou ainda, concatenar duas palavras em uma \u00fanica. Para isso, a biblioteca \\texttt{string.h} fornece algumas fun\u00e7\u00f5es prontas, como pode ser visto na tabela \\ref{tab:string_func} \\begin{table}[!ht] \\centering \\begin{tabular}{l|l} Fun\u00e7\u00e3o & Descri\u00e7\u00e3o \\\\hline strlen & retorna o tamanho (em caracteres) da palavra passada como argumento.\\ strcpy & copia o conte\u00fado da segunda \\textit{string} para a primeira.\\ strcat & concatena o texto da segunda \\textit{string} na primeira.\\ strcmp & compara duas \\textit{strings} (vide exemplo a seguir).\\ stricmp & compara duas \\textit{strings} sem diferenciar mai\u00fasculas e min\u00fasculas.\\ atoi & converte uma \\textit{string} para o inteiro correspondente.\\ atof & converte uma \\textit{string} para o n\u00famero real correspondente.\\\\hline \\end{tabular} \\caption{Algumas fun\u00e7\u00f5es para trabalhar com \\textit{strings}.} \\label{tab:string_func} \\end{table} O exemplo a seguir mostra a utiliza\u00e7\u00e3o destas fun\u00e7\u00f5es: \\begin{lstlisting} #include #include using namespace std; int main() { char str1[50], str2[50]; int i; float f; cout << ``Entre primeiro nome:''; cin >> str1; cout << ``Entre ultimo nome:''; cin >> str2; strcat(str1, `` ''); //junto espaco com str1 strcat(str1, str2); cout << ``Seu nome completo eh '' << str1 << endl; cout << ``Ele possui '' << strlen(str1) << `` caracteres.'' << endl; cout << ``Entre outro nome:''. cin >> str2; //comparacao de strings if(strcmp(str1, str2) == 0) { cout << ``os dois nomes sao iguais.'' << endl; } else if(strcmp(str1, str2) < 0) { cout << str1 << `` vem antes de'' << str2 << endl; } else { cout << str2 << `` vem antes de '' << str1 << endl; } return 0; } \\end{lstlisting} No uso destas fun\u00e7\u00f5es, \u00e9 importante manter-se em mente que o espa\u00e7o adequado deve ser alocado para a string resultante das opera\u00e7\u00f5es. Por exemplo, ao se concatenar duas strings de no m\u00e1ximo 100 caracteres, o resultado ter\u00e1, no m\u00e1ximo, 200 caracteres.","title":"{Fun\u00e7\u00f5es para manipula\u00e7\u00e3o \\textit{Strings}}"},{"location":"intro/#funcoes-com-vetores-como-parametros","text":"As fun\u00e7\u00f5es descritas acima recebem strings como par\u00e2metros. Agora, veremos como definir suas fun\u00e7\u00f5es pr\u00f3prias fun\u00e7\u00f5es que recebem n\u00e3o somente strings, mas vetores de outros tipos de dados. A declara\u00e7\u00e3o de uma vari\u00e1vel do tipo vetor segue, como j\u00e1 visto, a seguinte forma. \\[\\begin{verbatim} tipo identificador[tamanho]; \\end{verbatim}\\] A declara\u00e7\u00e3o de par\u00e2metros segue uma sintaxe parecida, no qual o tamanho do vetor n\u00e3o aparece \\begin{verbatim} tipo identificador[] \\end{verbatim} Isto ocorre por que, para que a fun\u00e7\u00e3o seja gen\u00e9rica e opere em qualquer vetor passado, o par\u00e2metro n\u00e3o pode ser especificado em c\u00f3digo. Assim, a declara\u00e7\u00e3o de uma fun\u00e7\u00e3o que recebe um vetor como par\u00e2metro segue a seguinte receita: \\[\\begin{verbatim} tipo identificadorDaFuncao(tipo identificador1[], int tamanho1, ...) { Corpo da Funcao } \\end{verbatim}\\] Por exemplo, veja como definir uma fun\u00e7\u00e3o que transforme todos os caracteres de uma string para letras ma\u00edusculas. \\begin{lstlisting} #include #include using namespace std; void maiusculas(char str[], int tam) { for(int i = 0; i < tam && i < strlen(str); i++) if(str[i] >= 'a' && str[i] <= 'z') str[i] = str[i] - 'a' + 'A'; } int main() { char str[50]; cout << ``Digite seu primeiro nome:''; cin >> str; maiusculas(str, 50) cout << str << endl; return 0; } \\end{lstlisting} Observe que a fun\u00e7\u00e3o \\textbf{altera} a string passada como par\u00e2metro, um comportamento diferente do que aconteceu quando uma vari\u00e1vel que n\u00e3o \u00e9 um vetor \u00e9 passada. Este comportamento ser\u00e1 estudado mais a fundo em cap\u00edtulos posteriores. Da mesma forma que uma string, um vetor de outro tipo de dados pode ser passado como par\u00e2metro. A fun\u00e7\u00e3o a seguir, por exemplo, calcula qual o maior inteiro em um vetor de inteiros. \\begin{lstlisting} #include using namespace std; int maior(int v[], int tam) { int maior = -1; for(int i = 0; i < tam ; i++) if(v[i] > maior) maior = v[i]; return maior; } \\end{lstlisting}","title":"{Fun\u00e7\u00f5es com vetores como par\u00e2metros}"},{"location":"intro/#laboratorio_9","text":"\\begin{lab} Fa\u00e7a um programa que dado uma string, retorne 1 se ela for pal\u00edndromo e 0 se ela n\u00e3o for pal\u00edndromo. Lembrando que um pal\u00edndromo \u00e9 uma palavra que tenha a propriedade de poder ser lida tanto da direita para a esquerda como da esquerda para a direita. Deve-se obrigatoriamente utilizar uma \\texttt{string} auxiliar e a fun\u00e7\u00e3o \\texttt{strcmp} para fazer a resolu\u00e7\u00e3o. Ex: SUBI NO ONIBUS\\ ARARA \\ANOTARAM A DATA DA MARATONA \\end{lab} \\[\\begin{lab} Fa\u00e7a um programa que troque todas as ocorr\u00eancias de uma letra L1 pela letra L2 em uma \\textit{string}. A \\textit{string} e as letras L1 e L2 devem ser fornecidas pelo usu\u00e1rio. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que leia 3 \\textit{strings} e as imprima em ordem alfab\u00e9tica. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa com uma fun\u00e7\u00e3o que receba um vetor de inteiros e um inteiro X, e que retorne como resultado o maior inteiro do vetor que \u00e9 menor que o inteiro X. \\end{lab}\\] \\[\\begin{lab} Usando a resposta do problema anterior, fa\u00e7a um programa com uma fun\u00e7\u00e3o que receba dois vetores de inteiros, e que fa\u00e7a com que o segundo torne-se uma c\u00f3pia do primeiro, ordenado de forma decrescente. \\end{lab}\\] \\chapter{Bits, bytes e bases num\u00e9ricas} At\u00e9 agora temos trabalhado essencialmente com os tipos num\u00e9ricos, inteiros e reais, e booleanos. Para que possamos usar outros tipos, \u00e9 essencial que antes entendamos como os dados s\u00e3o representados na mem\u00f3ria do computador.","title":"{Laborat\u00f3rio}"},{"location":"intro/#bit-byte","text":"Como dito anteriormente, a mem\u00f3ria do computador pode ser entendida como uma grande planilha eletr\u00f4nica, podendo cada c\u00e9lula ser endere\u00e7ada (atribu\u00edda, lida, nomeada) individualmente. Na mem\u00f3ria do computador n\u00e3o existem n\u00fameros ou caracteres, mas v\u00e1rias ``lamp\u00e2das'' que podem estar ligadas ou desligadas. N\u00f3s humanos atribu\u00edmos significado a tais estados como sendo 0's e 1's. Cada posi\u00e7\u00e3o da mem\u00f3ria, que pode armazenar 0 ou 1, \u00e9 denominado um \\emph{bit}. Por serem m\u00ednimos, normalmente trabalhamos com conjuntos de 8 bits por vez, o que denominamos \\emph{bytes}.","title":"{Bit \\&amp; Byte}"},{"location":"intro/#base-binaria","text":"Os bits de um byte podem assumir todas as combina\u00e7\u00f5es de ligado e desligado (0 e 1). Dado um contexto, cada combina\u00e7\u00e3o corresponde a um certo valor. Por exemplo, se estiver usando um byte para representar n\u00fameros inteiros, ent\u00e3o provavelmente a correspond\u00eancia na Tabela~\\ref{tab:bindec} se aplica. \\[\\begin{table} \\caption{Exemplos de valores em bin\u00e1rio e decimal correspondente.} \\centering \\begin{tabular}{c|r} \\hline bits & N\u00famero\\\\ \\hline 00000000 & 0\\\\ 00000001 & 1\\\\ 00000010 & 2\\\\ 00000011 & 3\\\\ 00000100 & 4\\\\ 00000101 & 5\\\\ 00000110 & 6\\\\ 00000111 & 7\\\\ 00001000 & 8\\\\ 00001001 & 9\\\\ 00001010 & 10\\\\ \\ldots\\\\ 11111101 & 253\\\\ 11111110 & 254\\\\ 11111111 & 255\\\\ 00000000 & 0\\\\ \\ldots\\\\ \\end{tabular} \\label{tab:bindec} \\end{table}\\] Talvez isso seja novidade para voc\u00ea, mas voc\u00ea representa n\u00fameros na base decimal usando 10 d\u00edgitos (de 0 a 9). Contudo, outras bases existem. Como os bits s\u00f3 possuem dois estados, \u00e9 natural na computa\u00e7\u00e3o usar a base bin\u00e1ria, que usa 2 d\u00edgitos (0 e 1). Os valores \u00e0 esquerda na tabela podem ser entendidos como n\u00fameros nesta base.\\footnote{sempre que n\u00e3o for colocada a base, considera-se a base 10, mais natural aos seres de vida baseada em carbono do nosso planeta, A.K.A., voc\u00ea.} Para conseguir converter n\u00fameros de uma base para a outra, basta entender o que exatamente significa a representa\u00e7\u00e3o de um n\u00famero em uma base gen\u00e9rica X. Nesta base, \\(ABCD_X\\) significa \\(A*X^3 + B*X^2 + C*X^1 + D*X^0\\) . O n\u00famero \\(1234_{10}\\) , por exemplo, significa \\(1*X^3 + 2*X^2 + 3*X^1 + 4*X^0 = 1*1000 + 2 * 100 + 3*10 + 4*1\\) que \u00e9 igual a, t\u00e1 d\u00e1, \\(1234_{10}\\) . Para um exemplo mais interessante, o n\u00famero \\(10101010_2 = 1*2^7 + 0*2^6 + 1*2^5 + 0*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 128+0+32+8+2 = 170\\) . Observe que, pela tabela, o maior n\u00famero que se pode representar com 8 bits \u00e9 \\(11111111_2 = 255_{10}\\) . Via de regra, com X bits pode se representar \\(2^X\\) na base bin\u00e1ria, de 0 a \\(2^X-1\\) .","title":"{Base Bin\u00e1ria}"},{"location":"intro/#base-hexadecimal","text":"Embora se possa usar qualquer base num\u00e9rica, as que fazem mais sentido no mundo computacional s\u00e3o as bin\u00e1ria e hexadecimal. A base hexadecimal usa 16 d\u00edgitos em cada posi\u00e7\u00e3o representando valores de 0 a 15. Para isto, usa os valores de 0 a 9 iguais aos da base decimal e tamb\u00e9m as letras de A a F representado os valores de 10 a 15. Por exemplo, o n\u00famero 1A2F \\(_{16}\\) equivale a \\(1*16^3 + 10*16^2 + 2*16^1 + 15*16^0 = 4096 + 2560 + 32 + 15 = 6703\\) .","title":"{Base Hexadecimal}"},{"location":"intro/#conversao-entre-bases-numericas","text":"Enquanto n\u00f3s trabalhamos com base decimal, o computador armazena informa\u00e7\u00e3o e realiza opera\u00e7\u00f5es na base bin\u00e1ria. Por isso, a todo momento ocorre a convers\u00e3o entre um decimal que informamos como entrada em um programa, por exemplo, para a base bin\u00e1ria (para efetuar o c\u00e1lculo), bem como da base bin\u00e1ria (resultado do c\u00e1lculo) para a base decimal exibida na tela.","title":"{Convers\u00e3o entre bases num\u00e9ricas}"},{"location":"intro/#conversao-de-binario-para-decimal","text":"A convers\u00e3o de bin\u00e1rio (e qualquer outra base) para decimal pode ser feita facilmente usando a nota\u00e7\u00e3o da base gen\u00e9rica apresentada acima. Isto \u00e9, para realizar a convers\u00e3o basta multiplicar o valor de cada posi\u00e7\u00e3o pelo seu peso (base elevada \u00e0 posi\u00e7\u00e3o). Por exemplo, o n\u00famero \\(1111011_2\\) equivale a \\(1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 64 + 32 + 16 + 8 + 0 + 2 + 1 = 123_{10}\\) .","title":"*{Convers\u00e3o de Bin\u00e1rio para Decimal}"},{"location":"intro/#conversao-de-decimal-para-binario","text":"A convers\u00e3o de decimal para bin\u00e1rio \u00e9 feita realizando-se divis\u00f5es sucessivas pela base de interesse (2, no nosso caso) at\u00e9 que o resultado seja zero. Os restos das divis\u00f5es, na ordem inversa, correspondem ao n\u00famero convertido. Por exemplo, considere a convers\u00e3o do n\u00famero 169 para a base bin\u00e1ria. O processo de convers\u00e3o \u00e9 o seguinte:\\ \\(169 / 2 = 84, Resto = 1\\) \\ \\(84 / 2 = 42, Resto = 0\\) \\ \\(42 / 2 = 21, Resto = 0\\) \\ \\(21 / 2 = 10, Resto = 1\\) \\ \\(10 / 2 = 5, Resto = 0\\) \\ \\(5 / 2 = 2, Resto = 1\\) \\ \\(2 / 2 = 1, Resto = 0\\) \\ \\(1 / 2 = 0, Resto = 1\\) \\ O n\u00famero bin\u00e1rio equivalente \u00e9, portanto, \\(10101001_2\\) .","title":"*{Convers\u00e3o de Decimal para Bin\u00e1rio}"},{"location":"intro/#conversao-entre-binario-e-hexadecimal","text":"Sabendo-se que com 4 bits \u00e9 poss\u00edvel representar at\u00e9 16 n\u00fameros (de 0 a 15) e que a base hexadecimal tem exatamente 16 d\u00edgitos, conclu\u00edmos que \u00e9 poss\u00edvel representar cada d\u00edgito hexadecimal com 4 d\u00edgitos bin\u00e1rios. Sendo assim, a convers\u00e3o bin\u00e1rio/hexadecimal pode ser feita facilmente substituindo conjuntos de 4 bits bin\u00e1rios por um d\u00edgito hexadecimal e vice-versa. Por exemplo, para convertermos \\(11101010_2\\) convertemos \\(1110_2\\) para E \\(_{16}\\) e \\(1010_2\\) para A \\(_{16}\\) , obtendo o n\u00famero EA \\(_{16}\\) . Na dire\u00e7\u00e3o inversa, para convertermos o n\u00famero 7B \\(_{16}\\) para bin\u00e1rio convertemos 7 \\(_{16}\\) para \\(0111_2\\) e B \\(_{16}\\) para \\(1011_2\\) , obtendo o n\u00famero \\(01111011_2\\) . \\[\\begin{table} \\caption{Exemplos de valores em bin\u00e1rio, decimal e hexadecimal correspondentes.} \\centering \\begin{tabular}{c|r|r} \\hline Bin\u00e1rio & Decimal & Hexadecimal\\\\ \\hline 00000000 & 0 & 0\\\\ 00000001 & 1 & 1\\\\ 00000010 & 2 & 2\\\\ 00000011 & 3 & 3\\\\ 00000100 & 4 & 4\\\\ 00000101 & 5 & 5\\\\ 00000110 & 6 & 6\\\\ 00000111 & 7 & 7\\\\ 00001000 & 8 & 8\\\\ 00001001 & 9 & 9\\\\ 00001010 & 10 & A\\\\ 00001011 & 11 & B\\\\ 00001100 & 12 & C\\\\ 00001101 & 13 & D\\\\ 00001110 & 14 & E\\\\ 00001111 & 15 & F\\\\ 00010000 & 16 & 10\\\\ \\ldots\\\\ 11111101 & 253 & FD\\\\ 11111110 & 254 & FE\\\\ 11111111 & 255 & FF\\\\ 00000000 & 0 & 0\\\\ \\ldots\\\\ \\end{tabular} \\label{tab:bindechex} \\end{table}\\]","title":"*{Convers\u00e3o entre Bin\u00e1rio e Hexadecimal}"},{"location":"intro/#tipos-numericos-inteiros","text":"Na linguagem C, os principais tipos, a quantidade de bits utilizada para sua representa\u00e7\u00e3o e o intervalo de valores aceitos s\u00e3o resumidos na tabela a seguir: \\footnote{A quantidade de bits pode variar de acordo com o compilador e a arquitetura do sistema} \\[\\begin{table}[h!] \\caption{Intervalo de representa\u00e7\u00e3o dos tipos num\u00e9ricos inteiros.} \\centering \\begin{tabular}{l|c|c} \\hline Tipo & Quantidade de Bits & Intervalo\\\\ \\hline char & 8 & -128 a 127\\\\ unsigned char & 8 & 0 a 255\\\\ int & 16 & -32.768 a 32.767\\\\ unsigned int & 16 & 0 a 65.535\\\\ long & 32 & -2.147.483.648 a 2.147.483.647\\\\ unsignet long & 32 & 0 a 4.294.967.295\\\\ \\end{tabular} \\end{table}\\] Observe que o tipo caractere tamb\u00e9m \u00e9 armazenado internamente como um n\u00famero inteiro de 8 bits. Com 8 bits podemos representar \\(2^8\\) n\u00fameros. Se considerarmos n\u00fameros sem sinal (\\textit{unsigned}) teremos de 0 a 255; se considerarmos n\u00fameros com sinal, teremos metade para positivos e metade para negativos, ou seja, de -128 a 127. O mesmo racioc\u00ednio se aplica para os outros tipos de dados da tabela. A partir desta tabela podemos observar a import\u00e2ncia da escolha adequada do tipo correto de acordo com sua aplica\u00e7\u00e3o. Se utilizarmos um inteiro para somarmos 20.000 e 50.000, por exemplo, o resultado ser\u00e1 inesperado, uma vez que o maior valor que um inteiro aceita \u00e9 32.767. Quando isto ocorre, dizemos que houve um \\textit{overflow}.","title":"{Tipos Num\u00e9ricos Inteiros}"},{"location":"intro/#numeros-binarios-negativos","text":"Os exemplos que vimos at\u00e9 agora de convers\u00e3o n\u00e3o contemplam n\u00fameros negativos. Na base decimal, o sinal de menos (-) antes do valor do n\u00famero tem a finalidade de representar n\u00fameros negativos. Como a mem\u00f3ria do computador armazena apenas 0's e 1's, uma poss\u00edvel estrat\u00e9gia \u00e9 ``desperdi\u00e7ar'' um dos bits do n\u00famero para o sinal. Adota-se, por padr\u00e3o, o zero para representar um n\u00famero positivo e o um para negativo. O bit do sinal \u00e9 armazenado na posi\u00e7\u00e3o mais \u00e0 esquerda. Para representar o valor de um n\u00famero negativo h\u00e1 duas principais abordagens: \\textbf{sinal-magnitude} e \\textbf{complemento de 2}. Na representa\u00e7\u00e3o \\textbf{sinal-magnitude}, o n\u00famero negativo tem seu valor absoluto (magnitude) representado da mesma forma que um n\u00famero positivo e o bit mais significativo, que representa o sinal, ser\u00e1 igual a um. A tabela a seguir mostra alguns exemplos de n\u00fameros na base decimal e na representa\u00e7\u00e3o sinal-magnitude. \\[\\begin{table}[!ht] \\caption{Exemplos de valores na representa\u00e7\u00e3o sinal-magnitude.} \\centering \\begin{tabular}{c|c} \\hline Decimal & Bin\u00e1rio Sinal-Magnitude\\\\ \\hline +20 & \\textbf{0}0010100\\\\ -20 & \\textbf{1}0010100\\\\ +115 & \\textbf{0}1110011\\\\ -115 & \\textbf{1}1110011\\\\ \\end{tabular} \\end{table}\\] Com 8 bits, temos, ent\u00e3o n\u00fameros de \\(11111111_2\\) a \\(01111111_2\\) (-127 a +127). Um problema que aparece com esta representa\u00e7\u00e3o \u00e9 o zero. Qual a representa\u00e7\u00e3o correta, \\(00000000\\) ou \\(10000000\\) ? E por que precisar\u00edamos de duas representa\u00e7\u00f5es? A representa\u00e7\u00e3o \\textbf{complemento de 2} utiliza uma maneira um pouco diferente de representar n\u00fameros negativos. Para express\u00e1-los devemos inverter cada bit do n\u00famero positivo e somar 1 ao resultado. Por exemplo, o n\u00famero -15 \u00e9 representado em complemento de 2 com 5 bits como 10001, ou seja, calcula-se o valor de +15 = \\(01111_2\\) , e, em seguida invertemos e somamos 1: \\(10000_2 + 1_2 = 10001_2\\) . Se a representa\u00e7\u00e3o usar 8 bits, ent\u00e3o \\(15_{10} = 00001111_{2}\\) e \\(-15_{10} = 11110001_{2}\\) .","title":"{N\u00fameros Bin\u00e1rios Negativos}"},{"location":"intro/#aritmetica-inteira-binaria","text":"Aritm\u00e9tica bin\u00e1ria \u00e9 t\u00e3o simples como \\(1 + 1 = 10\\) . S\u00e9rio, \u00e9 assim que se faz: \\(0 + 0 = 0, 0+1 = 1+0 = 1, 1 + 1 = 10_2\\) . Logo, em sistemas computacionais as somas e subtra\u00e7\u00f5es geralmente s\u00e3o realizadas aos pares, da mesma forma que na base bin\u00e1ria.","title":"{Aritm\u00e9tica Inteira Bin\u00e1ria}"},{"location":"intro/#numeros-positivos","text":"A \\textbf{adi\u00e7\u00e3o} de n\u00fameros positivos \u00e9 muito simples. Para faz\u00ea-la, basta somar os valores na mesma posi\u00e7\u00e3o, do menos significativo para o mais significativo. O ``vai-um'' funciona da mesma forma como fazemos na base decimal. Por exemplo, para somarmos 5 e 9, fazemos: \\begin{verbatim} 1 0101 + 1001 1110 \\end{verbatim} Como a quantidade de bits para determinado tipo de dados \u00e9 limitado, durante uma soma pode ocorrer de o resultado ultrapassar o maior valor permitido para aquela quantidade de bits, quando isto ocorre, temos um \\emph{overflow} (derramamento). Considere a soma de 7 e 9, ambos com 4 bits. \\begin{verbatim} 1 111 0111 + 1001 1 0000 \u2190 overflow! \\end{verbatim} Houve um ``vai-um'' al\u00e9m do bit mais significativo, caracterizando um \\textit{overflow}. Neste caso, o resultado da opera\u00e7\u00e3o est\u00e1 errado.","title":"{N\u00fameros positivos}"},{"location":"intro/#numeros-em-complemento-de-2","text":"Como vimos anteriormente, o computador usa duas principais representa\u00e7\u00f5es para n\u00fameros negativos. A representa\u00e7\u00e3o complemento de 2 \u00e9 a mais utilizada porque permite que a soma de n\u00fameros negativos seja feita da mesma maneira que a soma de n\u00fameros positivos. Por exemplo considere as soma de -2 + 5 e -1+(-1), em complemento de 2: \\begin{verbatim} 1 1 (-2) 1110 + (+5) 0101 ---- 1 0011 \u2190 N\u00e3o \u00e9 overflow! Esse \"vai-um\" deve ser desprezado! 1 111 (-1) 1111 + (-1) 1111 ---- 1 1110 \u2190 N\u00e3o \u00e9 overflow! Esse \"vai-um\" deve ser desprezado! \\end{verbatim} Observe que nestes exemplos tivemos um vai-um'' al\u00e9m do bit mais significativo. Em soma de n\u00fameros em complemento de 2 isto n\u00e3o \u00e9 suficiente para caracterizar um \\textit{overflow}. Um \\emph{overflow} apenas ocorrer\u00e1 quando, ao somarmos dois n\u00fameros de mesmo sinal, obtivermos um n\u00famero de sinal diferente. Desta maneira, no exemplo apresentado, este vai-um'' a mais deve simplesmente ser ignorado. J\u00e1 os exemplos a seguir mostram opera\u00e7\u00f5es problem\u00e1ticas. \\begin{verbatim} 111 (+7) 0111 + (+7) 0111 ---- 1110 \u2190 O resultado come\u00e7a com 1, logo \u00e9 negativo. Absurdo! 1 (-3) 1101 + (-6) 1010 ---- 1 0111 \u2190 O resultado come\u00e7a com 0, logo \u00e9 positivo. Absurdo! \\end{verbatim}","title":"{N\u00fameros em Complemento de 2}"},{"location":"intro/#e-a-subtracao","text":"Na verdade, a maioria dos computadores n\u00e3o sabe fazer subtra\u00e7\u00e3o. O que eles fazem \u00e9 utilizar um truque para transformar uma subtra\u00e7\u00e3o em uma soma. Por exemplo, a opera\u00e7\u00e3o \\(7 - 5\\) pode ser reescrita como \\(7 + (-5)\\) , ou seja, para realizar a subtra\u00e7\u00e3o basta inverter o segundo n\u00famero (em complemento de 2) e som\u00e1-lo ao primeiro da maneira usual.","title":"{E a subtra\u00e7\u00e3o?}"},{"location":"intro/#tipos-numericos-reais","text":"Para representarmos n\u00fameros reais no computador, definimos que uma quantidade de bits do n\u00famero ser\u00e1 usada para representar a mantissa e o restante o expoente do n\u00famero. Por exemplo, se dispusermos de 8 bits, podemos definir que os quatro primeiros bits ser\u00e3o a mantissa e os quatro \u00faltimos ser\u00e3o o expoente, em nota\u00e7\u00e3o cient\u00edfica. Assim, \\(10101010_2 = 1,0*10^{11}\\) e \\(10111010_2 = 1,1*10^{11}\\) . Antes que voc\u00ea saia dizendo por a\u00ed que o ideal \u00e9 usar tais n\u00fameros pois podemos representar n\u00fameros t\u00e3o grandes como \\(11111111_2 = 15*10^{15}\\) , que \u00e9 muito mais que os \\(2^{16}-1\\) da nota\u00e7\u00e3o bin\u00e1ria convencional, pense em como representaria o n\u00famero 161 \\(_{10}\\) , j\u00e1 que a maior mantissa represent\u00e1vel \u00e9 1,5. Al\u00e9m disso, como representar 1,1111, j\u00e1 que s\u00f3 dispomos de 4 d\u00edgitos na mantissa? Al\u00e9m disso, se representa\u00e7\u00f5es de n\u00fameros reais pecam em sua precis\u00e3o, tamb\u00e9m pecam na velocidade de processamento. A aritm\u00e9tica de n\u00fameros bin\u00e1rios \u00e9 muito mais simples que a de n\u00fameros reais (ou de ponto flutuante, como costumamos dizer na computa\u00e7\u00e3o). Para manipular n\u00fameros reais, computadores normalmente precisam de componentes dedicados a este fim e que tem alto tempo de execu\u00e7\u00e3o. Para saber mais sobre representa\u00e7\u00f5es de n\u00fameros em pontos flutuantes visite a URL \\url{ http://en.wikipedia.org/wiki/Floating_point }","title":"{Tipos Num\u00e9ricos Reais}"},{"location":"intro/#exercicios-e-laboratorio","text":"","title":"{Exerc\u00edcios e laborat\u00f3rio}"},{"location":"intro/#_1","text":"Quantos n\u00fameros se pode representar, na base bin\u00e1ria, com 1, 8, 16, 32 e 64 bits?","title":"{}"},{"location":"intro/#_2","text":"Escreva os seguintes n\u00fameros nas bases bin\u00e1ria e hexadecimal: \\begin{enumerate} \\item 16 \\item 45 \\item 129 \\item 23 \\item 1290 \\end{enumerate}","title":"{}"},{"location":"intro/#_3","text":"Converta os n\u00fameros a seguir para a base decimal: \\begin{enumerate} \\item \\(16_{16}\\) \\item D5 \\(_{16}\\) \\item \\(1100101101_2\\) \\item 2C04 \\(_{16}\\) \\item \\(11101_2\\) \\end{enumerate}","title":"{}"},{"location":"intro/#_4","text":"Escreva os n\u00fameros a seguir nas representa\u00e7\u00f5es sinal-magnitude e complemento de 2 com 8 bits: \\begin{enumerate} \\item -19 \\item +47 \\item -29 \\item -37 \\item -105 \\end{enumerate}","title":"{}"},{"location":"intro/#_5","text":"Realize as seguintes opera\u00e7\u00f5es aritm\u00e9ticas em complemento de 2 com n\u00fameros de 8 bits: \\begin{enumerate} \\item 16 - 9 \\item -45 - 7 \\item -12 + 12 \\end{enumerate}","title":"{}"},{"location":"intro/#_6","text":"\\[\\begin{lab} Fa\u00e7a um programa para descobrir quantos bits tem uma vari\u00e1vel do tipo \\lstinline{int}? E um \\lstinline{unsigned int}? \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia um n\u00famero de 2 d\u00edgitos na base decimal e imprima o mesmo n\u00famero na base bin\u00e1ria. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia um n\u00famero bin\u00e1rio de at\u00e9 10 bits e imprima o mesmo n\u00famero na base decimal. \\end{lab}\\] %\\chapter{Strings e Fun\u00e7\u00f5es} %Neste cap\u00edtulo veremos algumas fun\u00e7\u00f5es muito usadas na manipula\u00e7\u00e3o de (\\textit{strings}) assim como definir suas pr\u00f3prias fun\u00e7\u00f5es que recebem vetores como %par\u00e2metros. \\chapter{Fun\u00e7\u00f5es \u00dateis I}","title":"{}"},{"location":"intro/#funcoes-matematicas","text":"A biblioteca \\texttt{math.h} fornece algumas fun\u00e7\u00f5es aritm\u00e9ticas muito \u00fateis no desenvolvimento de programas. A Tabela~\\ref{tab:math_func} apresenta algumas destas fun\u00e7\u00f5es. \\[\\begin{table}[!ht] \\centering \\begin{tabular}{l|l} Fun\u00e7\u00e3o & Descri\u00e7\u00e3o/Exemplo \\\\\\hline abs & valor absoluto do argumento. Ex: \\verb|int x = abs(-9);| \\\\ sin & seno do argumento (em radianos). Ex: \\verb|double x = sin(3.14159);|\\\\ cos & cosseno do argumento (em radianos). Ex: \\verb|double x = cos(3.14159);|\\\\ tan & tangente do argumento (em radianos). Ex: \\verb|double x = tan(3.14159);|\\\\ asin& arco cujo seno \u00e9 passado como argumento. Ex: \\verb|double x = asin(1);|\\\\ acos& arco cujo cosseno \u00e9 passado como argumento. Ex: \\verb|double x = acos(1);|\\\\ atan& arco cuja tangente \u00e9 passada como argumento. Ex: \\verb|double x = atan(sqrt(2)/2);|\\\\ floor& piso do valor passado como argumento. Ex: \\verb|double x = floor(3.2); //=3|\\\\ ceil& teto do valor passado como argumento. Ex: \\verb|double x = floor(3.2); //=4|\\\\ round& arredonda o argumento para o inteiro mais pr\u00f3ximo. Ex: \\verb|double x = round(9.9); //=10|\\\\ pow& eleva o primeiro argumento ao expoente no segundo. Ex: \\verb|double x = pow(2,3); //=8|\\\\ sqrt& retorna a raiz quadrada do argumento. Ex: \\verb|double x = sqrt(169); //=13|\\\\ log& retorna logaritmo natural do argumento.\\\\ log10& retorna log. do argumento na base 10.\\\\ log2& retornar log do argumento na base 2\\\\\\hline \\end{tabular} \\caption{Algumas fun\u00e7\u00f5es aritm\u00e9ticas.} \\label{tab:math_func} \\end{table}\\] Al\u00e9m das fun\u00e7\u00f5es em \\lstinline{math.h}, duas outras fun\u00e7\u00f5es, da biblioteca \\lstinline{stdlib.h}, s\u00e3o particularmente interessantes na manipula\u00e7\u00e3o de n\u00fameros. Estas fun\u00e7\u00f5es s\u00e3o apresentadas na Tabela~\\ref{tab:rand_func}. \\[\\begin{table}[!ht] \\centering \\begin{tabular}{l|l} Fun\u00e7\u00e3o & Descri\u00e7\u00e3o/Exemplo \\\\\\hline rand & retorna um n\u00famero aleat\u00f3rio (biblioteca \\texttt{stdlib.h})\\\\ srand& define a semente para a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios por \\texttt{rand} (biblioteca \\texttt{stdlib.h})\\\\\\hline \\end{tabular} \\caption{Fun\u00e7\u00f5es para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios.} \\label{tab:rand_func} \\end{table}\\] A fun\u00e7\u00e3o \\lstinline{rand()} \u00e9 utiliza para gerar n\u00fameros aleat\u00f3rios. Um n\u00famero aleat\u00f3rio \u00e9 gerado internamente pelo computador aplicando-se opera\u00e7\u00f5es aritm\u00e9ticas que o usu\u00e1rio desconhece a partir de um valor inicial chamado de \\emph{semente}. O valor dessa semente \u00e9 definido com a fun\u00e7\u00e3o \\lstinline{srand()}. O exemplo a seguir imprime na tela 30 n\u00fameros ``aleat\u00f3rios''. \\newpage \\begin{lstlisting}","title":"{Fun\u00e7\u00f5es Matem\u00e1ticas}"},{"location":"intro/#include_29","text":"","title":"include"},{"location":"intro/#include_30","text":". . . int main() { for (int i = 0; i < 10; i++) { cout << rand() << endl; } for (int i = 0; i < 10; i++) { cout << rand() << endl; } //Configuracao da semente //com valor que depende da hora atual. //Isto garante maior 'aleatoriedade' srand(time(NULL)); for (int i = 0; i < 10; i++) { cout << rand() << endl; } return 0; } \\end{lstlisting} O codigo a seguir \u00e9 para um jogo de adivinha\u00e7\u00e3o. O programa gera um n\u00famero aleat\u00f3rio entre 1 e 10, e o usu\u00e1rio deve descobrir qual \u00e9 este n\u00famero\\footnote{\\url{ http://www.cplusplus.com/reference/clibrary/cstdlib/rand/ }}. \\begin{lstlisting} /* rand example: guess the number */","title":"include"},{"location":"intro/#include_31","text":"","title":"include "},{"location":"intro/#include_32","text":"","title":"include "},{"location":"intro/#include_33","text":"using namespace std; int main () { int iSecret, iGuess; /* initialize random seed: */ srand ( time(NULL) ); /* generate secret number: */ iSecret = rand() % 10 + 1; do { printf (\"Guess the number (1 to 10): \"); cin >> iGuess; if (iSecret iGuess) puts (\"The secret number is higher\"); } while (iSecret!=iGuess); puts (\"Congratulations!\"); return 0; } \\end{lstlisting}","title":"include "},{"location":"intro/#laboratorio_10","text":"\\[\\begin{lab} Fa\u00e7a um programa que leia os catetos de um tri\u00e2ngulo e imprima o valor de sua hipotenusa. Utiliza as fun\u00e7\u00f5es aritm\u00e9ticas. \\end{lab}\\] \\begin{lab} O valor de \\(\\pi\\) pode ser dado pela s\u00e9rie: \\(\\pi = \\sum_{n=0}^{\\infty} (-1)^n\\frac{4}{2n+1}\\) Fa\u00e7a uma fun\u00e7\u00e3o chamada \\texttt{pi} que recebe o valor de \\texttt{n} e retorna o valor calculado de acordo com a fun\u00e7\u00e3o informada. A fun\u00e7\u00e3o principal deve ler o valor de \\texttt{n}, invocar a fun\u00e7\u00e3o \\texttt{pi} e imprimir o resultado. \\end{lab} \\[\\begin{lab} Fa\u00e7a um programa que leia dois n\u00fameros $x$ e $y$ e calcule $log_y x$. O c\u00e1lculo deve ser feito em uma fun\u00e7\u00e3o auxiliar. \\end{lab}\\] \\begin{lab} Fa\u00e7a uma fun\u00e7\u00e3o que receba como par\u00e2metro o valor de um \u00e2ngulo em graus e o n\u00famero de itera\u00e7\u00f5es (n) e calcule o valor do cosseno hiperb\u00f3lico desse \u00e2ngulo usando sua respectiva s\u00e9rie de Taylor: \\(cosh(x) = \\sum_{n=1}^{\\infty} \\frac{x^{2n}}{(2n)!}\\) , onde x \u00e9 o valor do \u00e2ngulo em \\emph{radianos}. Considerar pi = 3.141593. \\end{lab} \\chapter{Arranjos Multidimensionais} Embora os arranjos unidimensionais sejam \u00fateis em v\u00e1rias situa\u00e7\u00f5es, eles n\u00e3o s\u00e3o suficientes para resolver todos os problemas relacionados a arranjos. Em certas situa\u00e7\u00f5es, v\u00e1rias dimens\u00f5es precisam ser representadas. Um exemplo simples \u00e9 o problema de multiplica\u00e7\u00e3o de matrizes.\\footnote{A bem da verdade, \u00e9 poss\u00edvel representar qualquer matriz finita como um arranjo unidimensional, mas a complexidade \u00e9 muito maior em rela\u00e7\u00e3o ao uso de arranjos multidimensionais.}","title":"{Laborat\u00f3rio}"},{"location":"intro/#declaracao-e-iniciacao","text":"Como j\u00e1 visto, a declara\u00e7\u00e3o de arranjos tem a seguinte sintaxe, \\begin{verbatim} tipo identificador[tamanho]; \\end{verbatim} A declara\u00e7\u00e3o de uma vari\u00e1vel do tipo matriz tem uma forma semelhante, apenas aumentando uma segunda dimens\u00e3o ao arranjo, como a seguir. \\begin{verbatim} tipo identificador[tamanho1][tamanho2]; \\end{verbatim} Assim, uma declara\u00e7\u00e3o como \\begin{lstlisting} int matriz[10][20]; \\end{lstlisting} declara uma matriz de 10 linhas por 10 colunas, cujas c\u00e9lulas s\u00e3o n\u00fameros inteiros. A matriz pode ser iniciada como em arranjos unidimensionais, colocando-se os valores do elemento dentro de chaves ap\u00f3s a declara\u00e7\u00e3o da matriz. Os valores para cada linha devem ficar dentro de chaves pr\u00f3prias e s\u00e3o separados por v\u00edrgula: \\[\\begin{lstlisting} {int matriz[2][3] = {{1, 2, 3}, {4, 5, 6}}; \\end{lstlisting}\\] A matriz criada pode ser visualizada da seguinte maneira: \\begin{center} \\begin{tabular}{|ccc|} 1 & 2 & 3\\ 4 & 5 & 6 \\end{tabular} \\end{center}","title":"{Declara\u00e7\u00e3o e Inicia\u00e7\u00e3o}"},{"location":"intro/#acesso-aos-elementos","text":"O acesso \u00e0s c\u00e9lulas \u00e9 feito tamb\u00e9m como em arranjos unidimensionais, exceto que ambas as coordenadas devem ser especificadas. O exemplo a seguir mostra a cria\u00e7\u00e3o, inicia\u00e7\u00e3o, e impress\u00e3o dos elementos de uma matriz bidimensional. \\begin{lstlisting}","title":"{Acesso aos elementos}"},{"location":"intro/#include_34","text":"","title":"include"},{"location":"intro/#define-m-5","text":"","title":"define M 5"},{"location":"intro/#define-n-10","text":"using namespace std; int main() { int m[M][N]; cout << \"Digite o valor dos elementos de uma matriz \" << M << \" por \" << N; for(int i = 0; i < M; i++) for(int j = 0; j < N; j++) { cout << i << \",\" << j; cin >> m[i][j]; } cout << \"A matriz lida foi a seguinte \"<< endl; for(int i = 0; i < M; i++) { for(int j = 0; j < N; j++) { cout << m[i][j] << \" \"; } cout << endl; } } \\end{lstlisting} Observe que tanto na leitura como impress\u00e3o da matriz, o la\u00e7o mais externo percorre as linhas. Para cada valor da vari\u00e1vel \\lstinline!i!, a vari\u00e1vel \\lstinline|j|, dentro do la\u00e7o interno percorre os valores de 0 a \\(N-1\\) . Desta maneira, a matriz \u00e9 lida e impressa linha a linha. Observe a impress\u00e3o. Para que serve o comando \\lstinline|cout<<endl;|?","title":"define N 10"},{"location":"intro/#mais-dimensoes","text":"Agora voc\u00ea j\u00e1 deve ter deduzido que para adicionar mais dimens\u00f5es aos seus arranjos, basta colocar esta dimens\u00e3o na declara\u00e7\u00e3o dos mesmos. Por exemplo, o seguinte trecho de c\u00f3digo declara um arranjo com tr\u00eas dimens\u00f5es, em que cada c\u00e9lula \u00e9 um inteiro. \\begin{lstlisting} char matriz[100][100][100]; \\end{lstlisting} Outra forma de ver tal arranjo \u00e9 como um livro com v\u00e1rias ``p\u00e1ginas'', em que cada uma \u00e9 uma matriz bidimensional.","title":"{Mais Dimens\u00f5es}"},{"location":"intro/#multiplicacao-de-matrizes","text":"Agora que voc\u00ea viu alguns exemplos de declara\u00e7\u00f5es de arranjos multidimensionais, vejamos alguns usos reais, como a j\u00e1 mencionada multiplica\u00e7\u00e3o de matrizes. Sejam duas matrizes \\(A\\) e \\(B\\) , tal que \\(A\\) tem dimens\u00f5es \\(m \\times n\\) e \\(B, n \\times o\\) ; ent\u00e3o, a matriz \\(AB\\) tem dimens\u00f5es \\(m\\times o\\) , e \\(C_i,j = \\sum_{k = 1}^{m}A_{m,n}B_{n,o}\\) . Observe que na matem\u00e1tica os \u00edndices come\u00e7am, normalmente, em 1. Na computa\u00e7\u00e3o, contudo, os arranjos tem seu menor \u00edndice igual a zero. Logo, o c\u00f3digo para multiplicar as duas matrizes fica assim. \\begin{lstlisting} int main() { int soma = 0, m, n, o; int a[100][100], b[100][100], ab[100][100]; //m,n e 0 precisam ser menores que 100. //ler as dimensoes cout << \"Quais as dimensoes das matrizes?\"; cin >> m >> n >> o; for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) cin >> a[i][j]; for(int j = 0; j < m; j++) for(int k = 0; k < n; k++) cin >> a[j][k]; for(int i = 0 ; i < m ; i++ ) { for(int j = 0 ; j < o ; j++ ) { for(int k = 0 ; k < n ; k++ ) { sum = sum + a[i][k] * b[k][j]; } ab[i][j] = sum; sum = 0; } } } \\end{lstlisting} Observe que fizemos nosso c\u00f3digo de manipula\u00e7\u00e3o da matriz dentro da fun\u00e7\u00e3o \\lstinline!main!. Fizemos isso por que usar matrizes como par\u00e2metro \u00e9 bem mais complicado do que vetores unidimensionais. Contudo, n\u00e3o se aflija, pois veremos isso logo a seguir.","title":"{Multiplica\u00e7\u00e3o de Matrizes}"},{"location":"intro/#passagem-de-matriz-como-parametro-em-funcoes","text":"Vimos que, ao passar vetores para uma fun\u00e7\u00e3o, n\u00e3o era necess\u00e1rio especificar o n\u00famero de elementos no vetor. Em matrizes bidimensionais, n\u00e3o \u00e9 necess\u00e1rio especificar o n\u00famero de linhas na matriz, apenas o n\u00famero de colunas. O programa a seguir usa a fun\u00e7\u00e3o \\lstinline|exibeMatriz| para exibir o conte\u00fado de matrizes bidimensionais: \\begin{lstlisting}","title":"{Passagem de matriz como par\u00e2metro em fun\u00e7\u00f5es}"},{"location":"intro/#include_35","text":"","title":"include "},{"location":"intro/#define-ncol-10","text":"using namespace std; void exibeMatriz(int matriz[][ncol], int linhas) { int i, j; for (i = 0; i < linhas; i++) { for (j = 0; j < 10; j++) { cout << matriz[i][j] << ``\\t''; } cout << endl; } } int main() { int a[1][10] = {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}}; int b[2][10] = {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19,20}}; int c[3][10] = {{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19, 20}, {21, 22, 23, 24, 25, 26, 27, 28, 29, 30}}; exibeMatriz(a, 1); exibeMatriz(b, 2); exibeMatriz(c, 3); return 0; } \\end{lstlisting} Via de regra, n\u00e3o \u00e9 necess\u00e1rio especificar a primeira dimens\u00e3o da matriz. Isto \u00e9, em vetores, voc\u00ea n\u00e3o passava qualquer dimens\u00e3o. Em matrizes bidimensionais, n\u00e3o precisa especificar a quantidade de linhas. Em uma matriz tridimensional, n\u00e3o precisaria especificar a quantidade de ``p\u00e1ginas'', e assim por diante. Lembre-se, semelhante ao que acontece com vetores, matrizes alteradas em fun\u00e7\u00f5es auxiliares implicam em altera\u00e7\u00e3o na matriz original.","title":"define ncol 10"},{"location":"intro/#matrizes-de-caracteres","text":"Da mesma forma que vetores de caracteres podem ser manipuladas de forma especial no C(++), tamb\u00e9m podem as matrizes de caractere. Na verdade, se um vetor de caracteres \u00e9 o que chama-se de uma string, ent\u00e3o uma matriz bidimensional de caracteres \u00e9, na verdade, um vetor de strings. Por exemplo, \\begin{lstlisting} char nomes[10][20]; \\end{lstlisting} pode ser visto como um vetor de 10 strings, cada uma com 20 caracteres, e cada string pode ser manipulada como tal, como no exemplo a seguir. \\begin{lstlisting}","title":"{Matrizes de Caracteres}"},{"location":"intro/#include_36","text":"","title":"include"},{"location":"intro/#define-m-10","text":"","title":"define M 10"},{"location":"intro/#define-n-11","text":"using namespace std; int main() { char m[M][N]; cout << \"Digite \" << M << \" palavras de no maximo \" << N-1 << \" caracteres\" << endl; for(int i = 0; i < M; i++) { cout << i << \": \"; cin >> m[i]; } cout << \"As palavras lidas foram as seguintes \"<< endl; for(int i = 0; i < M; i++) { cout << m[i] << \" (com tamanho = \" << strlen(m[i]) << \")\" << endl; } } \\end{lstlisting}","title":"define N 11"},{"location":"intro/#exercicios_11","text":"\\[\\begin{lab} Escreva um programa com uma fun\u00e7\u00e3o que receba como par\u00e2metro uma matriz bidimensional e suas dimens\u00f5es, e que incremente cada elemento da matriz em 10\\%. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia e \\href{http://pt.wikipedia.org/wiki/Adi\u00e7\u00e3o_de_matrizes}{some} duas matrizes, imprimindo o resultado. Utilize fun\u00e7\u00f5es auxiliares para leitura, impress\u00e3o e soma. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia uma matriz e diga se ela \u00e9 a matriz \\href{http://pt.wikipedia.org/wiki/Matriz_identidade}{identidade} ou n\u00e3o. \\end{lab}\\] \\[\\begin{lab} Escreva um programa que leia uma matriz e imprima sua \\href{http://pt.wikipedia.org/wiki/Matriz_transposta}{transposta}. \\end{lab}\\] \\iffalse \\chapter{Arranjos Multidimensionais (II)}","title":"{Exercicios}"},{"location":"intro/#introducao","text":"Como voc\u00ea j\u00e1 percebeu, arranjos multidimensionais s\u00e3o muito divertidos. Neste cap\u00edtulo, veremos alguns t\u00f3picos mais avan\u00e7ados em seu uso.","title":"{Introdu\u00e7\u00e3o}"},{"location":"intro/#matrizes-bidimensionais-como-unidimensionais-e-vice-versa","text":"Uma matriz bidimensional pode ser utilizada sem precisar acessar os elementos em suas posi\u00e7\u00f5es de linha ou coluna. Ela pode ser tratada como se tivesse uma \u00fanica dimens\u00e3o. O programa a seguir calcula a soma dos valores em uma matriz bidimensional, inicialmente utilizando as duas dimens\u00f5es e em seguida da mesma forma que com vetores. \\begin{lstlisting}","title":"{Matrizes Bidimensionais Como Unidimensionais e Vice-Versa}"},{"location":"intro/#include_37","text":"","title":"include "},{"location":"intro/#define-ncol-10_1","text":"using namespace std; int somaMatrizBi(int matriz[][ncol], int linhas) { int soma = 0; for (int i = 0; i < linhas; i++) for (int j = 0; j < ncol; j++) soma += matriz[i][j]; return soma; } int somaMatrizUni(int matriz[], int elementos) { int soma = 0; int i; for (i = 0; i < elementos; i++) soma += matriz[i]; return soma; } int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[2][10]={{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19,20}}; int c[3][10]={{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19, 20}, {21, 22, 23, 24, 25, 26, 27, 28, 29,30}}; cout << \"Soma dos elementos da primeira matriz: \" << somaMatrizUni(a, 10); cout << \"Soma dos elementos da primeira matriz de novo: \" << somaMatrizBi(a, 1); cout << \"Soma dos elementos da segunda matriz: \" << somaMatrizUni(b, 20); cout << \"Soma dos elementos da segunda matriz de novo: \" << somaMatrizBi(b, 2); cout << \"Soma dos elementos da terceira matriz: \" << somaMatrizUni(c, 30); cout << \"Soma dos elementos da terceira matriz de novo: \" << somaMatrizBi(c, 3); return 0; } \\end{lstlisting} Observe que a fun\u00e7\u00e3o \\lstinline!somaMatrizUni! recebe como argumento o total de elementos e percorre a matriz da mesma forma que um vetor. Isto pode ser feito porque na mem\u00f3ria do computador a matriz \u00e9 armazenada como um vetor de \\lstinline|nlinha| \\(\\times\\) \\lstinline|ncolunas| elementos. A fun\u00e7\u00e3o \\lstinline|somaMatrizBi| recebe o n\u00famero de linhas e faz a mesma soma utilizando as duas dimens\u00f5es. Uma vez que a matriz multidimensional pode ser acessada como unidimensional, voc\u00ea pode criar fun\u00e7\u00f5es que recebam uma matriz unidimensional e passar, como par\u00e2metro, todas as suas dimens\u00f5es. Internamente a esta fun\u00e7\u00e3o, a matriz pode ser percorrida usando-se as dimens\u00f5es e um pouco de aritm\u00e9tica b\u00e1sica. \\begin{lstlisting}","title":"define ncol 10"},{"location":"intro/#include_38","text":"using namespace std; int somaMatrizBiDisfarcadaDeUni(int matriz[], int linhas, int colunas) { int soma = 0; for (int i = 0; i < linhas; i++) for (int j = 0; j < colunas; j++) soma += matriz[i * colunas + j]; return soma; } int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[2][8]={{1, 2, 3, 4, 5, 6, 7, 8}, {11, 12, 13, 14, 15, 16, 17, 18}}; int c[3][7]={{1, 2, 3, 4, 5, 6, 7}, {11, 12, 13, 14, 15, 16, 17}, {21, 22, 23, 24, 25, 26, 27}}; cout << \"Soma dos elementos da primeira matriz: \" << somaMatrizBiDisfarcadaDeUni(a, 1, 10); cout << \"Soma dos elementos da segunda matriz: \" << somaMatrizBiDisfarcadaDeUni(b[0], 2, 8); cout << \"Soma dos elementos da terceira matriz: \" << somaMatrizBiDisfarcadaDeUni(c[0], 3, 7); return 0; } \\end{lstlisting} %TODO: escrever o vice-versa.","title":"include "},{"location":"intro/#exercicios_12","text":"\\fi \\chapter{Ordena\u00e7\u00e3o de Arranjos}","title":"{Exerc\u00edcios}"},{"location":"intro/#introducao_1","text":"Uma das aplica\u00e7\u00f5es mais estudadas e realizadas sobre arranjos \u00e9 a \\textbf{ordena\u00e7\u00e3o}. Ordenar um arranjo significa permutar seus elementos de tal forma que eles fiquem em ordem crescente, ou seja, \\(v[0] <= v[1] <= v[2] <= \\dots{} <= v[n-1]\\) . Por exemplo, suponha o vetor\\ \\(v = {5, 6, -9, 9, 0, 4}\\) . \\ Uma ordena\u00e7\u00e3o desse vetor resultaria em um rearranjo de seus elementos: \\ \\(v = {-9, 0, 4, 5, 6, 9}\\) . Exitem diversos algoritmos de ordena\u00e7\u00e3o para vetores. Eles variam em rela\u00e7\u00e3o \u00e0 dificuldade de implementa\u00e7\u00e3o e desempenho. Usualmente algoritmos mais f\u00e1ceis de serem implementados apresentam desempenho inferior. Veremos 3 algoritmos diferentes de ordena\u00e7\u00e3o: \\begin{enumerate} \\item Algoritmo de Inser\u00e7\u00e3o (\\textit{Insertion Sort}); \\item Algoritmo de Sele\u00e7\u00e3o (\\textit{Selection Sort}); e \\item Algoritmo de Ordena\u00e7\u00e3o por Troca (\\textit{Bubble Sort}). \\end{enumerate}","title":"{Introdu\u00e7\u00e3o}"},{"location":"intro/#algoritmos-de-ordenacao","text":"","title":"{Algoritmos de Ordena\u00e7\u00e3o}"},{"location":"intro/#algoritmo-de-insercao-textitinsertion-sort","text":"Trata-se de um dos algoritmos de implementa\u00e7\u00e3o mais simples. Seu m\u00e9todo de ordena\u00e7\u00e3o semelhante ao que usamos para ordenar as cartas de um baralho. A id\u00e9ia b\u00e1sica do algoritmo \u00e9 descrita a seguir: \\begin{itemize} \\item Compare a chave (\\texttt{x}) com os elementos \u00e0 sua esquerda, deslocando para direita cada elemento maior do que a chave; \\item Insira a chave na posi\u00e7\u00e3o correta \u00e0 sua esquerda, onde os elementos j\u00e1 est\u00e3o ordenados; \\item Repita os passos anteriores atualizando a chave para a pr\u00f3xima posi\u00e7\u00e3o \u00e0 direita at\u00e9 o fim do vetor. \\end{itemize} A figura \\ref{fig:insertion_sort} apresenta um exemplo de uma etapa da execu\u00e7\u00e3o do algoritmo. \\begin{figure}[ht] \\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/insercao.png} \\end{center} \\caption{Exemplo do algoritmo \\textit{Insertion Sort}.} \\label{fig:insertion_sort} \\end{figure} O c\u00f3digo a seguir implementa o algoritmo em C, considerando um vetor \\texttt{v} de tamanho \\texttt{n}. \\begin{lstlisting} void insertionSort(int v[], int n) { int i, j, x; for(i = 1; i < n; i++) { x = v[i]; j = i - 1; while(j >= 0 && v[j] > x) { v[j+1] = v[j]; j--; } v[j+1] = x; } } \\end{lstlisting}","title":"{Algoritmo de Inser\u00e7\u00e3o (\\textit{Insertion Sort})}"},{"location":"intro/#algoritmo-de-selecao-textitselection-sort","text":"A implementa\u00e7\u00e3o deste m\u00e9todo de ordena\u00e7\u00e3o \u00e9 muito simples. A id\u00e9ia b\u00e1sica \u00e9 descrita a seguir: \\begin{itemize} \\item Selecione o menor elemento do vetor de tamanho \\texttt{n}; \\item Troque esse elemento com o elemento da primeira posi\u00e7\u00e3o do vetor; \\item Repita as duas opera\u00e7\u00f5es anteriores considerando apenas os \\texttt{n-1} elementos restantes, em seguida repita com os \\texttt{n-2} elementos restantes; e assim sucessivamente at\u00e9 que reste apenas um elemento no vetor a ser considerado. \\end{itemize} A figura \\ref{fig:selection_sort} apresenta um exemplo da execu\u00e7\u00e3o do algoritmo. \\begin{figure}[h] \\begin{center} \\includegraphics[width=.7\\textwidth]{imagens/selecao.png} \\end{center} \\caption{Exemplo do algoritmo \\textit{Selection Sort}.} \\label{fig:selection_sort} \\end{figure} O c\u00f3digo a seguir implementa o algoritmo em C, considerando um vetor \\texttt{v} de tamanho \\texttt{n}. \\begin{lstlisting} void selectionSort(int v[], int n) { int i, j, aux, min; for(i = 0; i < n-1; i++) { min = i; for(j = i+1; j < n; j++) { if(v[j] < v[min]) { min = j; } } aux = v[i]; v[i] = v[min]; v[min] = aux; //troca } } \\end{lstlisting}","title":"{Algoritmo de Sele\u00e7\u00e3o (\\textit{Selection Sort})}"},{"location":"intro/#algoritmo-de-ordenacao-por-troca-textitbubble-sort","text":"Outro algoritmo simples, muito \u00fatil para ordena\u00e7\u00e3o de vetores pequenos, mas n\u00e3o indicado para vetores maiores devido ao seu baixo desempenho computacional. Sua d\u00e9ia b\u00e1sica \u00e9 apresentada a seguir: \\begin{itemize} \\item Compare o primeiro elemento com o segundo. Se estiverem desordenados, ent\u00e3o efetue a troca de posi\u00e7\u00e3o. Compare o segundo elemento com o terceiro e efetue a troca de posi\u00e7\u00e3o, se necess\u00e1rio; \\item Repita a opera\u00e7\u00e3o anterior at\u00e9 que o pen\u00faltimo elemento seja comparado com o \u00faltimo. Ao final desta repeti\u00e7\u00e3o o elemento de maior valor estar\u00e1 em sua posi\u00e7\u00e3o correta, a n-\u00e9sima posi\u00e7\u00e3o do vetor; \\item Continue a ordena\u00e7\u00e3o posicionando o segundo maior elemento, o terceiro,..., at\u00e9 que todo o vetor esteja ordenado. \\end{itemize} A figura \\ref{fig:bubble_sort} apresenta um exemplo de um vetor sendo ordenado pelo algoritmo. \\begin{figure}[h] \\begin{center} \\includegraphics[width=.9\\textwidth]{imagens/bubblesort.png} \\end{center} \\caption{Exemplo de ordena\u00e7\u00e3o usando o algoritmo \\textit{Bubble Sort}.} \\label{fig:bubble_sort} \\end{figure} O c\u00f3digo a seguir implementa o algoritmo em C, considerando um vetor \\texttt{v} de tamanho \\texttt{n}. \\begin{lstlisting} void bubbleSort(int v[], int n) { int i, j, aux; for(i = n-1; i > 0; i--) { for(j = 0; j < i; j++) { if(v[j] > v[j+1]) { aux = v[j]; v[j] = v[j+1]; v[j+1] = aux; //troca } } } } \\end{lstlisting}","title":"{Algoritmo de Ordena\u00e7\u00e3o por Troca (\\textit{Bubble Sort})}"},{"location":"intro/#exercicios_13","text":"","title":"{Exerc\u00edcios}"},{"location":"intro/#_7","text":"Implemente na linguagem C o algoritmo de ordena\u00e7\u00e3o \\textit{insertion sort}. Utilize fun\u00e7\u00f5es auxiliares para implementar a ordena\u00e7\u00e3o, a leitura do vetor desordenado e a impress\u00e3o do vetor ordenado.","title":"{}"},{"location":"intro/#_8","text":"Implemente na linguagem C o algoritmo de ordena\u00e7\u00e3o \\textit{selection sort}. Utilize fun\u00e7\u00f5es auxiliares para implementar a ordena\u00e7\u00e3o, a leitura do vetor desordenado e a impress\u00e3o do vetor ordenado.","title":"{}"},{"location":"intro/#_9","text":"Implemente na linguagem C o algoritmo de ordena\u00e7\u00e3o \\textit{bubble sort}. Utilize fun\u00e7\u00f5es auxiliares para implementar a ordena\u00e7\u00e3o, a leitura do vetor desordenado e a impress\u00e3o do vetor ordenado. %TODO: Busca bin\u00e1ria %TODO: Inser\u00e7\u00e3o ordenada \\part{Intermedi\u00e1rio} \\chapter{Estruturas N\u00e3o-Homog\u00eaneas}","title":"{}"},{"location":"intro/#introducao_2","text":"Imagine que voc\u00ea deseje armazenar informa\u00e7\u00f5es sobre um funcion\u00e1rio de uma empresa. Entre estas informa\u00e7\u00f5es podemos ter, por exemplo, nome, endere\u00e7o, telefone, sexo, estado civil, cargo, setor e sal\u00e1rio. Em um programa, isto seria representado por oito vari\u00e1veis apenas para um funcion\u00e1rio. Se voc\u00ea desejar incluir mais informa\u00e7\u00f5es, isto implicar\u00e1 em mais vari\u00e1veis, aumentando a complexidade do programa. Por esta raz\u00e3o, em muitas aplica\u00e7\u00f5es, \u00e9 importante a capacidade de se tratar todas as informa\u00e7\u00f5es de uma entidade (uma pessoa, por exemplo), como sendo uma \u00fanica unidade de armazenamento, ou seja, uma \u00fanica vari\u00e1vel. Por outro lado, deve ser poss\u00edvel, que esta \u00fanica vari\u00e1vel permita acesso a cada informa\u00e7\u00e3o em separado. Outros exemplos de informa\u00e7\u00e3o com esta caracter\u00edstica \u00e9 o endere\u00e7o, que pode ser decomposto em: logradouro, n\u00famero, complemento, CEP, cidade, estado, pa\u00eds. Neste tipo de informa\u00e7\u00e3o \u00e9 poss\u00edvel observar que, diferentemente de vari\u00e1veis indexadas (vetores e matrizes), n\u00e3o h\u00e1 homogeneidade quanto ao tipo de dados tratado. Por isso, deve haver um mecanismo para trabalhar com vari\u00e1veis estruturadas heterog\u00eaneas, tamb\u00e9m conhecidas simplesmente como \\textit{estruturas} ou \\textit{structs}.","title":"{Introdu\u00e7\u00e3o}"},{"location":"intro/#declaracao","text":"Na linguagem C, a palavra reservada \\lstinline|struct| \u00e9 destinada \u00e0 declara\u00e7\u00e3o de vari\u00e1veis n\u00e3o-homog\u00eaneas, e seu uso segue a seguinte sintaxe: \\[\\begin{verbatim} struct identificador{ tipo_campo_1 nome_campo_1; ... tipo_campo_n nome_campo_n; }; \\end{verbatim}\\] Em primeiro lugar, cada estrututura tem um identificador, usado na declara\u00e7\u00e3o de vari\u00e1veis do tipo desta estrutura. Em seguida, s\u00e3o declarados os campos da estrutura, especificadas entre as chaves. Os campos podem ter qualquer tipo, inclusive ser outra estrutura. O exemplo a seguir declara uma estrutura para o armazenamento de endere\u00e7os e v\u00e1rias vari\u00e1veis deste tipo. \\[\\begin{lstlisting} struct endereco { char logradouro[15]; int numero; char complemento[6], bairro[10]; char cidade[10], estado[3], pais[10]; }; ... struct endereco e1, e2, e3; \\end{lstlisting}\\] O uso da palavra reservada \\lstinline|struct| \u00e9 obrigat\u00f3rio na declara\u00e7\u00e3o de vari\u00e1veis, pois ela faz parte do tipo da vari\u00e1vel. O uso repetido desta palavra reservada pode ``poluir'' o c\u00f3digo, e por essa raz\u00e3o recomenda-se a defini\u00e7\u00e3o de novos tipos baseados na estrutura.","title":"{Declara\u00e7\u00e3o}"},{"location":"intro/#lstinlinetypedef","text":"A palavra chave \\lstinline!typedef! permite que se defina novos tipos de dados a partir de tipos j\u00e1 existentes. Por exemplo, \u00e9 poss\u00edvel definir um tipo numero\\_real'' ou um tipo caractere''. A sintaxe para o uso \\lstinline|typedef| \u00e9 a seguinte: \\[\\begin{verbatim} typedef tipo_antigo tipo_novo; \\end{verbatim}\\] Os exemplos apenas dados s\u00e3o implementados assim: \\begin{lstlisting} typedef float numero_real; typedef char caractere; \\end{lstlisting} Mais importante, \u00e9 poss\u00edvel definir um tipo basedo na estrutura. Neste caso, h\u00e1 duas formas de faz\u00ea-lo. O exemplo a seguir mostra a mais verborr\u00e1gica. \\begin{lstlisting} struct end{ char logradouro[15]; int numero; char complemento[6], bairro[10]; char cidade[10], estado[3], pais[10]; }; ... typedef end endereco; endereco e1, e2, e3; \\end{lstlisting} Embora mais expl\u00edcita, esta forma n\u00e3o \u00e9 usada normalmente, em fun\u00e7\u00e3o forma mais compacta a seguir. \\[\\begin{lstlisting} typedef struct{ char logradouro[15]; int numero; char complemento[6], bairro[10]; char cidade[10], estado[3], pais[10]; } endereco; ... endereco e1, e2, e3; \\end{lstlisting}\\]","title":"{\\lstinline|typedef|}"},{"location":"intro/#acesso-aos-campos-de-uma-estrutura","text":"Embora as estruturas agreguem v\u00e1rios campos, com raras exce\u00e7\u00f5es, o manuseio da mesma deve ser feito campo a campo, como vari\u00e1veis normais. Para acessar um dos campos de uma estrutura, usa-se o operador '.' (ponto). Diferentemente de vari\u00e1veis indexadas, vari\u00e1veis do tipo estrutura podem receber o valor de outra do mesmo tipo (desde que nenhum dos campos seja vetor). Por exemplo: \\begin{lstlisting} typedef struct st1 st1; struct st1 { char l; int i; float b; }; ... st1 s1 = {'c', -9, 4.76}, //Atribuicao na iniciacao. s1Copia, s2; s2.l = 'z'; //Atribuicao... s2.i = -4; //... campo a ... s2.b = 0.89; //... campo. s1Copia = s1; //Copia de valores de todos os campos. ... \\end{lstlisting}","title":"{Acesso aos Campos de Uma Estrutura}"},{"location":"intro/#exemplo","text":"Considere a estrutura \\texttt{complexo}, a qual representa um n\u00famero imagin\u00e1rio na forma \\(a + b \\times i\\) , em que o valor de \\(a\\) \u00e9 armazenado na vari\u00e1vel \\texttt{real} e o valor de \\(b\\) \u00e9 armazenado na vari\u00e1vel \\texttt{imag}. O exemplo a seguir apresenta uma matriz de \\(3 \\times 3\\) em que cada elemento \u00e9 do tipo \\texttt{complexo}. \\begin{lstlisting}","title":"{Exemplo}"},{"location":"intro/#include_39","text":"using namespace std; typedef struct{ float real, imag; } complexo; int main() { int i, j; complexo A[3][3] = { { {1.0, -0.1}, {2.0, -0.2}, {2.0, -0.2} }, //real { {4.0, -3.4}, {5.0, 4.1}, {6.0, -2.6} } //imag }; for ( i= 0; i < 3; i++) { for (j = 0; j < 3; j++) cout << A[i][j].real << \" + \" A[i][j].imag << \"*i\" << \\t; cout << endl; } return 0; } \\end{lstlisting}","title":"include "},{"location":"intro/#exercicios_14","text":"","title":"{Exerc\u00edcios}"},{"location":"intro/#_10","text":"Fa\u00e7a um programa que leia informa\u00e7\u00f5es sobre 15 pessoas. Essa informa\u00e7\u00e3o deve ficar em um vetor de vari\u00e1veis do tipo estruturado \\texttt{pessoa}, o qual deve conter as seguintes informa\u00e7\u00f5es: \\begin{itemize} \\item Nome: string de tamanho 30; \\item Sexo: tipo enumerativo com os valores \\texttt{masc}, \\texttt{fem}; \\item Idade: valor inteiro; \\item Estado Civil: tipo enumerativo com os valores \\texttt{solteiro}, \\texttt{casado}, \\texttt{separado}, \\texttt{vi\u00favo}. \\item Sal\u00e1rio: valor real. \\end{itemize} Em seguida, imprima o n\u00famero de homens, n\u00famero de mulheres e informa\u00e7\u00f5es da pessoa com maior sal\u00e1rio.","title":"{}"},{"location":"intro/#_11","text":"Fa\u00e7a um programa que leia o nome, duas notas e n\u00famero de faltas de 10 alunos. As informa\u00e7\u00f5es desses alunos devem ser armazenadas em um vetor de vari\u00e1veis do tipo estruturado \\texttt{aluno}, o qual deve conter as seguintes informa\u00e7\u00f5es de cada aluno: \\begin{itemize} \\item Nome: string de tamanho 30; \\item M\u00e9dia: n\u00famero real resultado da m\u00e9dia das duas notas lidas; \\item Situa\u00e7\u00e3o: caractere representando situa\u00e7\u00e3o, isto \u00e9, 'A' (Aprovado), se m\u00e9dia maior ou igual a 6 e n\u00famero de faltas menor que 10, e 'R' (Reprovado), caso contr\u00e1rio. \\item Faltas: n\u00famero de faltas (valor inteiro). \\end{itemize} Por fim, devem ser impressas as informa\u00e7\u00f5es de cada aluno.","title":"{}"},{"location":"intro/#laboratorio_11","text":"Primeiramente, implemente sua solu\u00e7\u00e3o para o exerc\u00edcio anterior. Em seguida, implemente duas fun\u00e7\u00f5es, que ordenem os dados das pessoas por Nome e Idade, e imprimam todos os dados na tela. Finalmente, demonstre o uso destas fun\u00e7\u00f5es. %TODO: usar a analogia com planilha eletronica para mostrar como estrutura \u00e9 alocada na mem\u00f3ria.","title":"{Laborat\u00f3rio}"},{"location":"intro/#estruturas-e-funcoes","text":"Estruturas s\u00e3o utilizadas em fun\u00e7\u00f5es da mesma forma que os tipos b\u00e1sicos que vimos (\\lstinline|int, float, char|, \\ldots). Veja o exemplo a seguir: \\begin{lstlisting}","title":"{Estruturas e fun\u00e7\u00f5es}"},{"location":"intro/#include_40","text":"using namespace std; typedef struct pessoa pessoa; struct pessoa { char nome[40]; char sobrenome[40]; int idade; float salario; }; pessoa maisVelho(pessoa p1, pessoa p2) { return p1.idade > p2.idade ? p1 : p2; } int main() { pessoa pes1, pes2, mv; cout << entre nome, sobrenome, idade e salario da primeira pessoa: ''; cin >> pes1.nome >> pes1.sobrenome >> pes1.idade >> pes1.salario; cout << entre nome, sobrenome, idade e salario da segunda pessoa: ''; cin >> pes2.nome >> pes2.sobrenome >> pes2.idade >> pes2.salario; mv = maisVelho(pes1, pes2); cout << O mais velho eh '' << mv.nome << '' << mv.sobrenome << , com ''; cout << mv.idade << anos e salario de '' << mv.salario << endl; return 0; } \\end{lstlisting} De maneira an\u00e1loga, vetores de estruturas devem ser utilizados da mesma forma que vetores dos tipos b\u00e1sicos: \\begin{lstlisting}","title":"include"},{"location":"intro/#include_41","text":"","title":"include"},{"location":"intro/#define-t-5","text":"using namespace std; typedef struct pessoa pessoa; struct pessoa { char nome[40]; char sobrenome[40]; int idade; float salario; }; void lePessoas(pessoa p[]) { for(int i = 0; i < T; i++) { cout << entre nome, sobrenome, idade e salario da pessoa '' << (i+1) << :'' << endl; cin >> p[i].nome >> p[i].sobrenome >> p[i].idade >> p[i].salario; } } int maisVelho(pessoa p[]) { int idade = p[0].idade, posicao = 0; for(int i = 1; i < T; i++) { if(p[i].idade > idade) { idade = p[i].idade; posicao = i; } } return posicao; } int main() { pessoa p[T]; int pos; lePessoas(p); pos = maisVelho(p); cout << O mais velho eh '' << p[pos].nome << '' << p[pos].sobrenome << , com ''; cout << p[pos].idade << anos e salario de '' << p[pos].salario << endl; return 0; } \\end{lstlisting}","title":"define T 5"},{"location":"intro/#laboratorio_12","text":"\\[\\begin{lab} Considerando a estrutura: \\begin{lstlisting} struct Ponto { int x; int y; }; \\end{lstlisting} para representar um ponto em uma grade 2D, implemente uma fun\u00e7\u00e3o que indique se um ponto \\texttt{p} est\u00e1 localizado dentro ou fora de um ret\u00e2ngulo. O ret\u00e2ngulo \u00e9 definido por seus v\u00e9rtices inferior esquerdo \\texttt{v1} e superior direito \\texttt{v2}. A fun\u00e7\u00e3o deve retornar 1 caso o ponto esteja localizado dentro do ret\u00e2ngulo e 0 caso contr\u00e1rio. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um fun\u00e7\u00e3o que recebe um valor em segundos e retorna o valor equivalente para o tipo hor\u00e1rio, o qual \u00e9 composto por hora, minuto e segundos. Em seguida imprima os campos da estrutura retornada. \\end{lab}\\] \\[\\begin{lab} Crie a estrutura baralho, baseado em um \u201cbaralho tradicional\u201d (cada carta tem seu naipe e seu valor). Implemente uma fun\u00e7\u00e3o que fa\u00e7a parte de distribui\u00e7\u00e3o (sorteio) de cartas para 2 jogadores, considerando que cada jogador ir\u00e1 receber 5 cartas. Exiba na tela as cartas que cada um dos jogadores recebeu. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que controla o consumo de energia dos eletrodom\u00e9sticos de uma casa. Leia um inteiro \\texttt{n} e, utilizando fun\u00e7\u00f5es auxiliares: \\begin{itemize} \\item Crie e leia \\texttt{n} eletrodom\u00e9sticos que cont\u00e9m nome (m\u00e1ximo 15 letras), potencia (real, em kW) e tempo ativo por dia (real, em horas). \\item Leia um tempo \\texttt{t} (em dias), calcule e mostre o consumo total na casa e o consumo relativo de cada eletrodom\u00e9stico (consumo/consumo total) nesse per\u00edodo de tempo. Apresente este \u00faltimo dado em porcentagem. \\end{itemize} \\end{lab}\\] \\chapter{Refer\u00eancias} O uso da analogia da mem\u00f3ria do computador com uma planilha eletr\u00f4nica nos permitiu entender como vari\u00e1veis simples e tamb\u00e9m arranjos s\u00e3o alocados em nossos programas. Agora que j\u00e1 conhecemos vetores, usaremos uma analogia mais precisa para entendermos refer\u00eancias, ou como s\u00e3o mais popularmente conhecidas, os famigerados ponteiros.","title":"{Laborat\u00f3rio}"},{"location":"intro/#a-memoria-e-um-grande-vetor","text":"\\label{sec:referencias.intro} A mem\u00f3ria de um computador pode ser vista como um grande vetor de bytes. O primeiro byte \u00e9 denominado byte 0, o segundo, byte 1 e assim por diante at\u00e9 o tamanho da mem\u00f3ria dispon\u00edvel ao seu programa. Quando em seu programa voc\u00ea, por exemplo, declara uma vari\u00e1vel do tipo caractere (\\lstinline|char|) com o nome \\lstinline|c|, o compilador separa um byte da mem\u00f3ria, digamos o byte 7542, e passa a cham\u00e1-lo de \\lstinline|c|. Assim, toda vez que se referir \u00e0 vari\u00e1vel \\lstinline|c| em seu programa, o computador sabe que est\u00e1 se referindo ao byte 7542. Neste caso, dizemos que o endere\u00e7o da vari\u00e1vel \\lstinline|c| \u00e9 7542. Similarmente, quando voc\u00ea aloca uma vari\u00e1vel do tipo inteiro, o compilador reserva quatro bytes para voc\u00ea, digamos, os bytes 8012, 8013, 8014 e 8015. Tal vari\u00e1vel tem o endere\u00e7o 8012 (como os tipos tem sempre tamanho fixo, o endere\u00e7o do primeiro byte mais a informa\u00e7\u00e3o sobre o tipo da vari\u00e1vel \u00e9 suficiente para o computador determinar de onde at\u00e9 onde na mem\u00f3ria cada vari\u00e1vel fica armazenada). Finalmente, quando voc\u00ea aloca um vetor de tamanho \\(n\\) de algum tipo qualquer, o compilador reserva um espa\u00e7o de tamanho \\(n \\times t\\) , onde \\(t\\) \u00e9 o tamanho do tipo em quest\u00e3o. Se s\u00e3o 10 inteiros, por exemplo, ent\u00e3o o vetor ter\u00e1 tamanho 40 bytes. O endere\u00e7o desta vari\u00e1vel \u00e9 o endere\u00e7o do primeiro byte da primeira c\u00e9lula. Assim, quando voc\u00ea, por exemplo, acessa a posi\u00e7\u00e3o 5 de um vetor de inteiros cujo endere\u00e7o \u00e9 1000, o computador faz o seguinte c\u00e1lculo para determinar a posi\u00e7\u00e3o de mem\u00f3ria que voc\u00ea est\u00e1 acessando, sabendo que cada inteiro ocupa 4 bytes: \\(1000+5*4\\) .","title":"{A mem\u00f3ria \u00e9 um grande vetor}"},{"location":"intro/#variaveis-do-tipo-referencia","text":"Em certas situa\u00e7\u00f5es, o poder de se referir a posi\u00e7\u00f5es de mem\u00f3ria pelo seus endere\u00e7os em vez de por um nome de vari\u00e1vel \u00e9 muito \u00fatil. Por exemplo, imagine que precisemos calcular uma s\u00e9rie de estat\u00edsticas sobre os dados em um vetor. Neste caso, gostar\u00edamos de definir uma fun\u00e7\u00e3o que analisasse o vetor e desse como resultados as v\u00e1rias estat\u00edsticas, como m\u00e9dia, desvio padr\u00e3o, vari\u00e2ncia, intervalo de confian\u00e7a etc. Entretanto, como bem sabemos, fun\u00e7\u00f5es em C(++) retornam um \u00fanico resultado. Se, contudo, pud\u00e9ssemos passar como par\u00e2metro para a fun\u00e7\u00e3o as refer\u00eancias de onde gostar\u00edamos que os resultados fossem colocados, ent\u00e3o a fun\u00e7\u00e3o poderia coloc\u00e1-los diretamente nestas posi\u00e7\u00f5es de mem\u00f3ria. Esse mecanismo \u00e9 o que chamamos de passagem de par\u00e2metro por refer\u00eancia. Antes de se poder exercitar a passagem de par\u00e2metros por refer\u00eancia, contudo, precisamos aprender a declar\u00e1-las, a obter refer\u00eancias para posi\u00e7\u00f5es de mem\u00f3ria, e a usar tais refer\u00eancias. Estas opera\u00e7\u00f5es s\u00e3o feitas pelos operadores \\lstinline|*| e \\lstinline|&|. A declara\u00e7\u00e3o de vari\u00e1veis segue a seguinte sintaxe: \\[\\begin{verbatim} tipo *identificador; \\end{verbatim}\\] Assim, para se declarar vari\u00e1veis de refer\u00eancia para uma posi\u00e7\u00f5es de mem\u00f3ria que armazenam um inteiro, um caractere, e um float, voc\u00ea usaria as seguintes declara\u00e7\u00f5es: \\begin{lstlisting} int *ref_int; char *ref_char; float *zabumba; \\end{lstlisting} Observe que o \\lstinline|*| \u00e9 sempre considerado como ligado ao identificador e n\u00e3o ao tipo da vari\u00e1vel. Assim, a linha de c\u00f3digo \\begin{lstlisting} int *a, b, *c; \\end{lstlisting} declara duas refer\u00eancias para inteiro (\\lstinline|a| e \\lstinline|c|), e um inteiro (\\lstinline|b|). Para se evitar confus\u00f5es, sugere-se que n\u00e3o se declare vari\u00e1veis do tipo refer\u00eancia e n\u00e3o refer\u00eancia em conjunto. Ou seja, a c\u00f3digo acima deveria ser reescrito como \\begin{lstlisting} int *a, *c; int b; \\end{lstlisting} O operador \\lstinline|&| permite que se extraia o endere\u00e7o (ou uma refer\u00eancia) de uma vari\u00e1vel. No c\u00f3digo, \\begin{lstlisting} int *a; int b; a = &b; \\end{lstlisting} \\lstinline|a| recebe o endere\u00e7o da vari\u00e1vel \\lstinline|b|. Logo, se \\lstinline|b| est\u00e1 nos bytes 2012, 2013, 2014 e 2015, a vari\u00e1vel a recebe o valor 2012. Aqui, gostar\u00edamos de chamar a aten\u00e7\u00e3o para o seguinte fato: \\emph{em rar\u00edssimas situa\u00e7\u00f5es \u00e9 necess\u00e1rio saber o endere\u00e7o de uma vari\u00e1vel. Na maior parte dos casos, basta saber que uma vari\u00e1vel tem tal endere\u00e7o.}. Finalmente, o operador \\lstinline|*| tamb\u00e9m nos permite acessar o conte\u00fado de uma vari\u00e1vel referenciada, em do valor da refer\u00eancia. No c\u00f3digo, \\begin{lstlisting} int *a; int b; int c; a = &b; *a = 20; c = *a; c++; \\end{lstlisting} a vari\u00e1vel \\lstinline|b| termina com o valor 20, enquanto que a vari\u00e1vel c termina com o valor 21.","title":"{Vari\u00e1veis do Tipo Refer\u00eancia}"},{"location":"intro/#passagem-de-referencias-como-parametros","text":"Vari\u00e1veis do tipo refer\u00eancia, como outros tipos de vari\u00e1veis, podem ser passadas como par\u00e2metro em chamadas de fun\u00e7\u00e3o. A grande vantagem desta t\u00e9cnica, tamb\u00e9m conhecida como passagem de par\u00e2metros por refer\u00eancia, \u00e9 a possibilidade de modifica\u00e7\u00e3o da mem\u00f3ria para qual a refer\u00eancia foi passada. Por exemplo, analise o seguinte c\u00f3digo. \\begin{lstlisting}","title":"{Passagem de Refer\u00eancias como Par\u00e2metros}"},{"location":"intro/#include_42","text":"","title":"include"},{"location":"intro/#include_43","text":"using namespace std; void sen_cos_tan(float val, float *seno, float *cosseno, float *tangente) { *seno = sin(val); *cosseno = cos(val); *tangente = tan(val); } int main() { float v = 0, s, c, t; sen_cos_tan(v, &s, &c, &t); cout << \"seno: \" << s << \" cosseno: \" << c << \" tangente: \"<< t; return 0; } \\end{lstlisting} Esse programa calcula em uma \u00fanica chamada, os valores do seno, cosseno e tangente da vari\u00e1vel \\lstinline|v|. Enquanto o feito n\u00e3o parece muito impressionante, pense no caso em que voc\u00ea precisa calcular diversas estat\u00edsticas de um vetor de n\u00fameros. Neste caso, devido \u00e0 forte depend\u00eancia do c\u00e1lculo de uma estat\u00edstica no c\u00e1lculo de outras, esta fun\u00e7\u00e3o poderia simplificar em muito o seu c\u00f3digo.","title":"include"},{"location":"intro/#laboratorio_13","text":"\\[\\begin{lab} Escreva um programa que contenha fun\u00e7\u00f5es que calculam a m\u00e9dia, vari\u00e2ncia e desvio padr\u00e3o de um vetor de n\u00fameros reais (uma fun\u00e7\u00e3o por dado estat\u00edstico). \\end{lab}\\] \\[\\begin{lab} Altere o programa do exerc\u00edcio anterior para que calcule as tr\u00eas estat\u00edsticas em uma fun\u00e7\u00e3o apenas, reaproveitado os c\u00e1lculos uns dos outros. \\end{lab}\\] \\chapter{Refer\u00eancias II} Continuando com o estudo de ponteiros, vamos ver como utiliz\u00e1-los para referenciar estruturas e arranjos.","title":"{Laborat\u00f3rio}"},{"location":"intro/#ponteiros-para-structs","text":"Se voc\u00ea recordar-se da anologia apresentada na se\u00e7\u00e3o \\ref{sec:referencias.intro}, em que a mem\u00f3ria \u00e9 comparada a um grande vetor e cada tipo de dados tem um tamanho pr\u00e9-definido, \u00e9 f\u00e1cil entender como uma estrutura \u00e9 representada na mem\u00f3ria. Considere a seguinte estrutura e responda: qual o tamanho desta estrutura na mem\u00f3ria do computador? \\begin{lstlisting} typedef struct { int i; char c; float j; } exemplo1; \\end{lstlisting} Para responder a esta pergunta precisamos entender que uma estrutura ocupa espa\u00e7o equivalente \u00e0 soma do espa\u00e7o ocupado por cada um de seus campos. Desta forma, o espa\u00e7o total ocupado por uma vari\u00e1vel do tipo \\lstinline|exemplo1| ser\u00e1 a soma dos tamanhos de 1 \\lstinline|int|, 1 \\lstinline|char| e 1 \\lstinline|float|, ou seja, \\(4 + 1 + 4 = 9\\) bytes. Assim, e voc\u00ea cria uma vari\u00e1vel \\lstinline{exemplo1 v[10]}, o compilador deve reservar um espa\u00e7o de \\(10 \\times 9 = 90\\) bytes. Assim como nos referimos a vari\u00e1veis dos tipos primitivos (inteiro, real, caractere) utilizando ponteiros, podemos tamb\u00e9m utilizar ponteiros para acessar uma vari\u00e1vel do tipo \\lstinline|struct| e seus campos. Veja o exemplo para a estrutura declarada anteriormente. \\[\\begin{lstlisting} exemplo1 a = {-5, 'z', 0.89}, b; exemplo1 *p; p = &a; cout << (*p).i << endl; p = &b; cin >> (*p).c; \\end{lstlisting}\\] Este trecho mostra na linha 1 a cria\u00e7\u00e3o de duas vari\u00e1veis do tipo \\lstinline|exemplo1| e na linha 2 a cria\u00e7\u00e3o de uma vari\u00e1vel do tipo ponteiro para \\lstinline|exemplo1|. As linhas 3 e 5 atualizando o ponteiro, fazendo com que referencie as vari\u00e1veis \\lstinline|a| e \\lstinline|b|, respectivamente. Desta maneira, a linha 4 ir\u00e1 imprimir o valor de \\lstinline|a.i|, enquanto a linha 6 ir\u00e1 ler a partir do teclado um valor para \\lstinline|b.c|. Quando usamos ponteiros e estruturas, aparece o incoveniente de termos que digitar toda vez entre par\u00eanteses a vari\u00e1vel do tipo ponteiro (\\lstinline{(*p).c}). Para simplificar a utiliza\u00e7\u00e3o de ponteiros no acesso a campos de uma estrutura, a linguagem C permite escrever esta mesma instru\u00e7\u00e3o de uma maneira mais f\u00e1cil de digitar: \\lstinline{p->c}. O c\u00f3digo anterior pode ser reescrito como: \\[\\begin{lstlisting} exemplo1 a = {-5, 'z', 0.89}, b; exemplo1 *p; p = &a; cout << p->i << endl; p = &b; cin >> p->c; \\end{lstlisting}\\] Por fim, a passagem de estruturas por refer\u00eancia em fun\u00e7\u00f5es auxiliares \u00e9 feita da mesma forma que vimos no cap\u00edtulo anterior: \\begin{lstlisting} void inverte_structs(exemplo1 *s1, exemplo2 *s2) { exemplo1 aux aux.i = s2->i; s2->i = s1->i; s1->i = aux.i; aux.c = s2->c; s2->c = s1->c; s1->c = aux.c; aux.j = s2->j; s2->j = s1->j; s1->j = aux.j; } int main() { exemplo1 a = {1, 'a', 1.0}, b = {2, 'b', 2.0}; inverte_structs(&a, &b); cout << a.i << \", \" << a.c << \",\" << a.j << endl; cout << b.i << \", \" << b.c << \",\" << b.j << endl; return 0; } \\end{lstlisting} A fun\u00e7\u00e3o auxiliar troca os valores de duas vari\u00e1veis do tipo \\lstinline|exemplo1| passadas por refer\u00eancia. Ap\u00f3s a invoca\u00e7\u00e3o da fun\u00e7\u00e3o auxiliar a partir da \\lstinline|main| os valores iniciais das vari\u00e1veis \\lstinline|a| e \\lstinline|b| ser\u00e3o trocados.","title":"{Ponteiros para Structs}"},{"location":"intro/#arranjos-e-ponteiros","text":"At\u00e9 agora vimos vetores sem nenhuma rela\u00e7\u00e3o com ponteiros. No fundo, quando criamos um vetor com a instru\u00e7\u00e3o \\lstinline{int a[10]}, estamos dizendo ao compilador para reservar na mem\u00f3ria espa\u00e7o para 10 inteiros (40 bytes) e armazenar o endere\u00e7o em que come\u00e7a o vetor na vari\u00e1vel \\lstinline|a|. Em outras palavras, a vari\u00e1vel \\lstinline|a| \u00e9 um \\textit{ponteiro} para o primeiro elemento do vetor. Por esta raz\u00e3o, a rela\u00e7\u00e3o entre vetores e ponteiros \u00e9 mais direta e mais f\u00e1cil de utilizar. Uma vez que a vari\u00e1vel que usamos cont\u00e9m o endere\u00e7o do come\u00e7o do vetor, um ponteiro pode receber diretamente seu valor, sem necessidade do operador \\&. Considere o exemplo a seguir: \\[\\begin{lstlisting} float a[10]; float *p; p = a; cout << \"Digite 10 numeros reais: \"; for(int i = 0; i < 10; i++) cin >> a[i]; cout << \"Num. digitados: \"; for(int i = 0; i < 10; i++) cout << p[i]; \\end{lstlisting}\\] Observe a linha 3 e perceba como a atualiza\u00e7\u00e3o da refer\u00eancia do ponteiro \\lstinline|p| para o vetor \\lstinline|a| n\u00e3o utilizou o \\&. Isto porque \\lstinline|a| tamb\u00e9m \u00e9 um ponteiro. A diferen\u00e7a entre \\lstinline|p| e \\lstinline|a| \u00e9 que a primeira pode ter sua refer\u00eancia atualizada, enquanto a segunda n\u00e3o. A partir da linha 3, o vetor pode ser acessado tanto pela vari\u00e1vel \\lstinline|a| (linha 6) quanto pela vari\u00e1vel \\lstinline|p| (linha 9). \u00c9 por este motivo que vetores sempre s\u00e3o passados por refer\u00eancia em fun\u00e7\u00f5es auxiliares, sem a necessidade do \\& e do *.","title":"{Arranjos e Ponteiros}"},{"location":"intro/#percorrendo-vetores-com-ponteiros","text":"\\label{ssec:referencias2-percorrendo_vetores} J\u00e1 sabemos a rela\u00e7\u00e3o entre ponteiros e vetores. Veremos a seguir algumas maneiras diferentes de acessar os elementos de um vetor utilizando ponteiros. Considere o trecho de um programa a seguir: \\[\\begin{lstlisting} char str[100]; char *s; int totalletras = 0; s = str; cout << \"entre uma frase com letras minusculas\" << endl; cin.getline(s,100); for(int i = 0; i < strlen(s); i++) { if(s[i] >= 'a' && s[i] <= 'z') { totalletras++; } } cout << \"O total de letras da frase eh \" << totalletras; \\end{lstlisting}\\] Neste trecho utilizamos o ponteiro \\lstinline|s| como o vetor \\lstinline|str|, pois a partir da linha 3 ele ``aponta'' para o vetor. Este mesmo trecho pode ser reescrito: \\[\\begin{lstlisting} char str[100]; char *s; int totalletras = 0; s = str; cout << \"entre uma frase com letras minusculas\" << endl; cin.getline(s,100); for(int i = 0; i < strlen(s); i++) { if( *(s+i) >= 'a' && *(s+i) <= 'z' ) { totalletras++; } } cout << \"O total de letras da frase eh \" << totalletras; \\end{lstlisting}\\] Observe a linha 9 de cada um dos dois trechos anteriores e veja a diferen\u00e7a na nota\u00e7\u00e3o. Quando utilizamos ponteiro, podemos acessar um vetor pelo \u00edndice (colchetes) ou por um deslocamento sobre o valor do endere\u00e7o inicial do vetor armazenado em \\lstinline{s}, ou seja, a nota\u00e7\u00e3o \\lstinline{*(s+i)}, significa o caractere localizado \\lstinline{i} caracteres a partir do caractere na primeira posi\u00e7\u00e3o do vetor. O mesmo trecho pode ser reescrito ainda de uma terceira forma: \\[\\begin{lstlisting} char str[100]; char *s; int totalletras = 0; s = str; cout << \"entre uma frase com letras minusculas\" << endl; cin.getline(s,100); for(int i = 0; i < strlen(str); i++) //Observe que aqui usamos str e nao s. Por que? { if( *s >= 'a' && *s <= 'z' ) { totalletras++; } s++; } cout << \"O total de letras da frase eh \" << totalletras; \\end{lstlisting}\\] Qual a diferen\u00e7a entre esta vers\u00e3o e as vers\u00f5es anteriores? Qual a diferen\u00e7a entre \\lstinline{s++} e \\lstinline{(*s)++}? Qual o valor de \\lstinline|s[0]| em cada vers\u00e3o? E de \\lstinline|*s|? E de \\lstinline|str[0]|?","title":"{Percorrendo vetores com ponteiros}"},{"location":"intro/#laboratorio_14","text":"\\begin{lab} Crie uma estrutura com os campos nome, idade e salario dos tipos \\textit{string}, inteiro e real, respectivamente. Em seguida, crie uma fun\u00e7\u00e3o que receba refer\u00eancias para duas vari\u00e1veis de tal tipo e uma vari\u00e1vel correspondente a uma porcentagem de aumento que deve ser aplicada sobre o campo sal\u00e1rio de cada estrutura. A fun\u00e7\u00e3o principal deve ler cada campo das duas vari\u00e1veis e imprimir o novo sal\u00e1rio. Finalmente, crie uma fun\u00e7\u00e3o que recebe duas vari\u00e1veis de tal tipo e que troque os valores de todos os campos das duas estruturas. A fun\u00e7\u00e3o principal deve agora imprimir as estruturas antes e depois da troca. \\end{lab} \\[\\begin{lab} Execute as tr\u00eas vers\u00f5es do programa da se\u00e7\u00e3o \\ref{ssec:referencias2-percorrendo_vetores} e veja se h\u00e1 diferen\u00e7a no resultado. Responda \u00e0s perguntas no final da se\u00e7\u00e3o. \\end{lab}\\] \\chapter{Aloca\u00e7\u00e3o Din\u00e2mica} Por mais interessante que seja poder criar ponteiros para vari\u00e1veis j\u00e1 existentes e passar par\u00e2metros por refer\u00eancia, o poder dos ponteiros s\u00f3 fica mesmo evidente quando se trabalha com aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria. Aloca\u00e7\u00e3o din\u00e2mica \u00e9 a habilidade de se criar novas vari\u00e1veis durante a execu\u00e7\u00e3o do programa, sem que elas tenham sido declaradas antes. Justamente por n\u00e3o terem sido declaradas antes da compila\u00e7\u00e3o, estas vari\u00e1veis alocadas dinamicamente n\u00e3o t\u00eam nomes e, assim, s\u00f3 podem ser acessadas por meio de refer\u00eancias.","title":"{Laborat\u00f3rio}"},{"location":"intro/#alocacao-dinamica-de-tipos-simples","text":"Existem v\u00e1rias formas de se alocar mem\u00f3ria dinamicamente, todas elas via fun\u00e7\u00f5es que retornam como resultado uma refer\u00eancia para o come\u00e7o da mem\u00f3ria alocada, na forma de uma refer\u00eancia gen\u00e9rica. A fun\u00e7\u00e3o mais simples para aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 a \\lstinline|malloc|. Esta fun\u00e7\u00e3o recebe como \u00fanico par\u00e2metro o tamanho da mem\u00f3ria a ser alocada, em bytes. Observe o seguinte c\u00f3digo para alguns exemplos. \\begin{lstlisting} char *s1; int *i1; float *f1; s1 = (char *) malloc(1); i1 = (int *) malloc(4); f1 = (float *) malloc(4); \\end{lstlisting} No exemplo acima voc\u00ea percebe que antes de cada \\lstinline|malloc| h\u00e1, entre par\u00eanteses, o tipo da vari\u00e1vel que guardar\u00e1 a refer\u00eancia. Isso \u00e9 o que chamamos de \\emph{casting}, e serve para transformar a refer\u00eancia gen\u00e9rica retornada pela fun\u00e7\u00e3o para o tipo de refer\u00eancia da vari\u00e1vel. \\textbf{Este \\emph{casting} \u00e9 obrigat\u00f3rio em seu c\u00f3digo}. Voc\u00ea tamb\u00e9m percebe que cada aloca\u00e7\u00e3o especifica exatamente o tamanho do tipo para o qual estamos alocando a mem\u00f3ria. Isto \u00e9, 1 para caracteres e 4 para inteiros e n\u00fameros reais. Estes tamanhos, contudo, podem variar de uma m\u00e1quina/sistema operacional para outra, o que tornaria complicado especificar tais tamanhos em cada invoca\u00e7\u00e3o \u00e0 \\lstinline|malloc|. \u00c9 por isso que a linguagem C(++) especifica o construto \\lstinline|sizeof|, que ``descobre'' o tamanho do tipo para voc\u00ea, conforme o seguinte exemplo. \\begin{lstlisting} char *s1; int *i1; float *f1; double *d1; s1 = (char *) malloc(sizeof(char)); i1 = (int *) malloc(sizeof(int)); f1 = (float *) malloc(sizeof(float)); d1 = (double *) malloc(sizeof(double)); \\end{lstlisting}","title":"{Aloca\u00e7\u00e3o Din\u00e2mica de Tipos Simples}"},{"location":"intro/#alocacao-dinamica-de-vetores","text":"Como visto nos cap\u00edtulos anteriores, a diferen\u00e7a entre refer\u00eancias para tipos simples e vetores \u00e9... \\textbf{nenhuma}! Isso quer dizer que podemos alocar vetores usando um c\u00f3digo similar ao anterior, alterando apenas a quantidade de mem\u00f3ria alocada, como no seguinte exemplo. \\begin{lstlisting} char *s2; int *i2; float *f2; double *d2; s2 = (char *) malloc(sizeof(char) * 100); i2 = (int *) malloc(sizeof(int) * 10); f2 = (float *) malloc(sizeof(float) * 6); d2 = (double *) malloc(sizeof(double) * 8); cin.getline(s2,100); cout << s2; for(int i = 0; i < 10; i++) cin >> i2[i]; for(int i = 0; i < 10; i++) cout << i2[i] << endl; for(int i = 0; i < 6; i++) cin >> f2[i]; for(int i = 0; i < 6; i++) cout << f2[i] << endl; for(int i = 0; i < 8; i++) cin >> d2[i]; for(int i = 0; i < 8; i++) cout << d2[i] << endl; \\end{lstlisting}","title":"{Aloca\u00e7\u00e3o Din\u00e2mica de Vetores}"},{"location":"intro/#liberacao-de-memoria","text":"Todos os exemplos mostrados at\u00e9 agora neste cap\u00edtulo s\u00e3o incompletos. Isso por qu\u00ea nenhum programa que fa\u00e7a aloca\u00e7\u00e3o din\u00e2mica em C(++) pode ser completo sem que se fa\u00e7a a libera\u00e7\u00e3o da mem\u00f3ria alocada. Liberar ou ``desalocar'' a mem\u00f3ria consiste simplesmente na invoca\u00e7\u00e3o da fun\u00e7\u00e3o \\lstinline|free|, passando-se como par\u00e2metro a refer\u00eancia a ser desalocada. O uso de \\lstinline|free| ser\u00e1 exemplificado na pr\u00f3xima se\u00e7\u00e3o.","title":"{Libera\u00e7\u00e3o de mem\u00f3ria}"},{"location":"intro/#alocacao-dinamica-de-estruturas","text":"Assim como declarar uma refer\u00eancia para uma estrutura \u00e9 t\u00e3o simples quanto declarar uma refer\u00eancia para um tipo primitivo(simples), alocar um vetor de estruturas dinamicamente \u00e9 t\u00e3o simples quanto alocar um vetor de tipos primitivos dinamicamente. O exemplo a seguir mostra exatamente como alocar um vetor com 10 estruturas do tipo definido. \\begin{lstlisting}","title":"{Aloca\u00e7\u00e3o Din\u00e2mica de Estruturas}"},{"location":"intro/#define-num_pessoas-10","text":"typedef struct { char prim_nome[20], char ult_nome[20], int idade, float salario, char regiao, char sexo } pessoa_t; int main() { pessoa_t *pessoas; pessoas = (pessoa_t *) malloc(sizeof(pessoa) * NUM_PESSOAS); for(int i = 0; i < NUM_PESSOAS; i++) { cin >> pessoas[i].prim_nome; cin >> pessoas[i].ult_nome; cin >> pessoas[i].idade; cin >> pessoas[i].salario; cin >> pessoas[i].sexo; cin >> pessoas[i].regiao; } //Uso dos dados ... //Liberacao da memoria free(pessoas); return 0; } \\end{lstlisting}","title":"define NUM_PESSOAS 10"},{"location":"intro/#exercicios_15","text":"","title":"{Exerc\u00edcios}"},{"location":"intro/#_12","text":"Escreva um programa que leia um numero inteiro N, aloque dinamicamente um vetor de N inteiros, leia cada um dos N inteiros, e imprima os N inteiros na tela.","title":"{}"},{"location":"intro/#_13","text":"Escreva um programa que repita o seguinte procedimento X vezes: leia um numero inteiro N, aloque dinamicamente um vetor de N carateres, leia uma palavra de N caracteres, transforme todas as mai\u00fasculas em min\u00fasculas e vice-versa na palara e imprima o resultado na tela. X deve ser lido no in\u00edcio da execu\u00e7\u00e3o do programa.","title":"{}"},{"location":"intro/#laboratorio_15","text":"","title":"{Laborat\u00f3rio}"},{"location":"intro/#implemente-os-exercicios-acima","text":"","title":"{} Implemente os exerc\u00edcios acima."},{"location":"intro/#_14","text":"Escreva um programa que aloque um vetor de 100000 float e imprima os 10 primeiros e os 10 \u00faltimos (o lixo que estiver na mem\u00f3ria). \\footnote{Se tudo funcionar, aumente o vetor para 1000000 e assim por diante. O objetivo neste laborat\u00f3rio \u00e9 mostrar que a quantidade de mem\u00f3ria dispon\u00edvel para seu programa \u00e9 limitada, e que se extrapolada, seu programa incorrer\u00e1 em um erro.} %TODO: \\chapter{Vetores de Refer\u00eancias} %TODO: Combinando vetores para refer\u00eancias para tipos simples e estruturados. %TODO: \\chapter{Aloca\u00e7\u00e3o Din\u00e2mica II} %TODO: Aloca\u00e7\u00e3o de arranjos multi-dimensionais (caso cont\u00edguo) \\chapter{Arquivos} %\\todo{Mover para 4 ou 5 cap\u00edtulo. Alunos v\u00eaem mais exemplos pr\u00e1ticos de aplicabilidade} Muitas vezes desejamos guardar o resultado de alguma computa\u00e7\u00e3o para consulta posterior. Imagine, por exemplo, que voc\u00ea fez um programa que calcula a m\u00e9dia final e situa\u00e7\u00e3o de toda a turma. Se o resultado deste processamento n\u00e3o puder ser armazenado, toda vez que for necess\u00e1rio consultar a situa\u00e7\u00e3o de algum aluno, o programa dever\u00e1 ser executado e todos os dados inseridos novamente. Para solucionar este problema, o usu\u00e1rio pode salvar resultados de computa\u00e7\u00e3o em uma estrutura persistente. Esta estrutura de dados manipulada fora do ambiente do programa (mem\u00f3ria principal) \u00e9 conhecida como \\textbf{arquivo}. Um arquivo \u00e9 armazenado em um dispositivo de mem\u00f3ria secund\u00e1ria (CD, DVD, disco r\u00edgido, pendrive) e pode ser lido ou escrito por um programa. Em C, um arquivo pode representar diversas coisas, como documentos, uma impressora, um teclado, ou qualquer dispositivo de entrada ou sa\u00edda. Consideraremos apenas dados em disco, iniciando por dados na forma textual.","title":"{}"},{"location":"intro/#arquivos-de-texto","text":"Nesta se\u00e7\u00e3o estudaremos apenas arquivos texto, ou seja, arquivos que cont\u00eam apenas caracteres e podem ser visualizados em editores de textos como Notepad, Gedit, Vim, etc. A linguagem C++ d\u00e1 suporte \u00e0 utiliza\u00e7\u00e3o de arquivos por meio da biblioteca \\lstinline|fstream|. Esta biblioteca fornece v\u00e1rias fun\u00e7\u00f5es para manipula\u00e7\u00e3o de arquivos e define alguns tipos de dados para serem usados especificamente com arquivos. O principal tipo definido nessa biblioteca que ser\u00e1 usado \u00e9 o tipo \\lstinline|fstream|. Um vari\u00e1vel do tipo \\lstinline|fstream| \u00e9 capaz de identificar um arquivo no disco, direcionando-lhe todas as opera\u00e7\u00f5es. Essas vari\u00e1veis s\u00e3o declaradas da seguinte maneira: \\lstinline|fstream arq;|","title":"{Arquivos de texto}"},{"location":"intro/#abertura-e-fechamendo-de-arquivos","text":"Antes que o arquivo seja manipulado, \u00e9 preciso abr\u00ed-lo, o que \u00e9 feito via ``fun\u00e7\u00e3o'' \\lstinline|open| do arquivo. Uma vez aberto, o arquivo funciona como o \\lstinline|cin| e \\lstinline|cout|, com os quais voc\u00ea j\u00e1 est\u00e1 acostumado a usar \\lstinline|<<| e \\lstinline|>>|, como no exemplo a seguir. Ao terminar o uso do arquivo, \u00e9 importante fech\u00e1-lo, para garantir que tudo que, em teoria, est\u00e1 escrito no arquivo, realmente foi colocado no disco. \\begin{lstlisting}","title":"{Abertura e Fechamendo de Arquivos}"},{"location":"intro/#include_44","text":"","title":"include "},{"location":"intro/#include_45","text":"using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\"); arquivo << \"O que eu deveria escrever neste arquivo?\" << endl; arquivo.close(); return 0; } \\end{lstlisting} Nem sempre \u00e9 poss\u00edvel abrir o arquivo como no exemplo, o que ser\u00e1 explicado adiante. Para testar se o arquivo foi aberto ou n\u00e3o, use a fun\u00e7\u00e3o \\lstinline|is_open()|. \u00c9 importante que voc\u00ea teste se o arquivo realmente est\u00e1 aberto, antes de tentar us\u00e1-lo. \\begin{lstlisting}","title":"include "},{"location":"intro/#include_46","text":"","title":"include "},{"location":"intro/#include_47","text":"using namespace std; int main () { fstream arquivo; arquivo.open(\"arquivo.txt\"); if(arquivo.is_open()) { arquivo << \"O que eu deveria escrever neste arquivo?\" << endl; arquivo.close(); cout << \"tudo escrito\"; } else cout << \"falhou\"; return 0; } \\end{lstlisting} Se voc\u00ea tentou executar o c\u00f3digo acima, percebeu que a mensagem \"falhou\" foi escrita na tela. O problema \u00e9 que o c\u00f3digo abre um arquivo e escreve no mesmo, mas somente se ele j\u00e1 existir, o que n\u00e3o \u00e9 o caso. Por enquanto, v\u00e1 at\u00e9 a pasta onde est\u00e1 o seu projeto e crie o arquivo manualmente. Na se\u00e7\u00e3o seguinte veremos como criar um arquivo ``de dentro'' do programa. J\u00e1 no c\u00f3digo a seguir, veja como os dados do arquivo podem ser lidos. \\begin{lstlisting}","title":"include "},{"location":"intro/#include_48","text":"","title":"include "},{"location":"intro/#include_49","text":"using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\"); if(arquivo.is_open()) { cout << \"yeah\"; arquivo << \"Sera que isso foi escrito?\" << endl; arquivo.close(); arquivo.open (\"arquivo.txt\"); char str[1000]; arquivo.getline(str,1000); arquivo.close(); cout << str; } else cout << \"O arquivo nao foi aberto\"; return 0; } \\end{lstlisting}","title":"include "},{"location":"intro/#criacao-de-arquivos","text":"Para abrir um arquivo que n\u00e3o existe, ou seja, criar o arquivo, \u00e9 necess\u00e1rio passar um conjunto especial de instru\u00e7\u00f5es para a fun\u00e7\u00e3o de abertura. Infelizmente, o \u00fanico jeito de passar estas instru\u00e7\u00f5es \u00e9 bem mais complicado do que o que vimos at\u00e9 agora. Veja o seguinte c\u00f3digo, em especial a linha que abre o arquivo. \\begin{lstlisting}","title":"{Cria\u00e7\u00e3o de Arquivos}"},{"location":"intro/#include_50","text":"","title":"include "},{"location":"intro/#include_51","text":"using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\", ios::out | ios::in | ios::trunc); if(arquivo.is_open()) cout << \"yeah\"; else cout << \"nope\"; arquivo << \"O que eu deveria escrever neste arquivo?\" << endl; arquivo.close(); arquivo.open (\"arquivo.txt\"); char str[1000]; arquivo.getline(str,1000); arquivo.close(); cout << str; return 0; } \\end{lstlisting} Na frente do par\u00e2metro com o nome do arquivo, na fun\u00e7\u00e3o \\lstinline|open|, foram passadas tr\u00eas op\u00e7\u00f5es para o modo de abertura do arquivo, que especifica o tipo de opera\u00e7\u00f5es que se intende fazer no arquivo (o caractere \\lstinline-|- combina as op\u00e7\u00f5es passadas). Algumas das op\u00e7\u00f5es poss\u00edveis s\u00e3o: \\[\\begin{itemize} \\item ios::in -- Opera\u00e7\u00f5es de escrita. \\item ios::out -- Opera\u00e7\u00f5es de leitura. \\item ios::app -- Posiciona no fim do arquivo. N\u00e3o pode ser reposicionado. N\u00e3o pode ser usado com ios::in. \\item ios::trunc -- Posiciona no in\u00edcio do arquivo. Se o arquivo j\u00e1 existe, ent\u00e3o seu conte\u00fado anterior \u00e9 perdido. \\end{itemize}\\] As op\u00e7\u00f5es para leitura e escrita do arquivo, e somente estas, s\u00e3o impl\u00edcitas, quando nenhuma op\u00e7\u00e3o \u00e9 especificada. Se voc\u00ea quiser, pode usar apenas uma destas por quest\u00f5es de seguran\u00e7a (o arquivo pode ser lido mas n\u00e3o escrito, ou o arquivo pode ser aumentado mas n\u00e3o lido). Usando somente as op\u00e7\u00f5es de leitura e escrita, contudo, o arquivo n\u00e3o \u00e9 criado caso n\u00e3o exista. Para que seja criado, \u00e9 necess\u00e1rio que se especifique ou \\lstinline|ios::trunc| ou \\lstinline|ios::app|, que far\u00e3o com que o arquivo seja ou truncado ou que toda modifica\u00e7\u00e3o seja adicionada ao fim do arquivo (\\emph{append}).","title":"include "},{"location":"intro/#cuidados-com-a-formatacao-dos-dados","text":"Quando se escreve um dado em um arquivo de texto, precisa-se entender que o dado ocupa somente o espa\u00e7o que voc\u00ea especificar. Isto \u00e9, se voc\u00ea escrever a sequ\u00eancia de caracteres C(++) \u00e9 bom!!!'', 14 caracteres ser\u00e3o escritos, e pronto. Se escrever algo na linha seguinte depois resolver mudar a string acima para C(++) n\u00e3o \u00e9 bom!!!'', ent\u00e3o a divis\u00e3o entre as linhas (o \\lstinline|endl|) ter\u00e1 sido sobrescrito e as duas linhas se tornar\u00e3o uma. Estes cuidados n\u00e3o precisam ser tomados agora, com os exemplos simples com os quais estamos lidando, mas nos pr\u00f3ximos capitulos voc\u00ea ter\u00e1 que tom\u00e1-los. Assim, melhor que voc\u00ea j\u00e1 saiba sobre estes problemas desde agora. \\begin{lstlisting}","title":"{Cuidados com a Formata\u00e7\u00e3o dos Dados}"},{"location":"intro/#include_52","text":"","title":"include "},{"location":"intro/#include_53","text":"using namespace std; int main () { fstream arquivo; arquivo.open (\"arquivo.txt\", ios::out | ios::in | ios::trunc); char str[1000]; if(arquivo.is_open()) { cout << \"O arquivo foi aberto!\"; arquivo << \"Escrevendo um numero pequeno:\" << endl; arquivo << 10 <<endl; arquivo << \"Numero pequeno escrito.\" << endl; cout << \"Fechando o arquivo.\"; arquivo.close(); cout << \"Reabrindo o arquivo.\"; arquivo.open (\"arquivo.txt\"); arquivo << \"Escrevendo um numero pequeno:\" << endl; arquivo << 10000 <<endl; cout << \"Fechando o arquivo.\"; arquivo.close(); cout << \"Reabrindo o arquivo.\"; arquivo.open (\"arquivo.txt\"); arquivo.getline(str,1000); cout << str; arquivo.getline(str,1000); cout << str; arquivo.getline(str,1000); cout << str; arquivo.close(); } else cout << \"nope\"; return 0; } \\end{lstlisting}","title":"include "},{"location":"intro/#laboratorio_16","text":"\\[\\begin{lab} Fa\u00e7a um programa que leia o nome e sobrenome de 30 alunos e armazene em um arquivo, de tal forma que o arquivo tenha um aluno por linha. Abra o arquivo usando um editor de textos qualquer, como o Notepad. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que tente abrir um arquivo e, caso n\u00e3o consiga, tente cri\u00e1-lo e abr\u00ed-lo. Com arquivo aberto, leia um vetor A de inteiros de tamanho 20 e guarde seus valores em um arquivo, um por linha. Em seguida, reabra o arquivo e leia os elementos para o vetor B, verificando se os valores foram gravados corretamente. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa em Linguagem C que receba do usu\u00e1rio um arquivo, e mostre na tela quantas linhas esse arquivo possui. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa que receba dois arquivos do usu\u00e1rio, e crie um terceiro arquivo com o conte\u00fado dos dois primeiros juntos (o conte\u00fado do primeiro seguido do conte\u00fado do segundo). \\end{lab}\\] \\[\\begin{lab} Desenvolver um programa em C que l\u00ea o conte\u00fado de um arquivo e cria um arquivo com o mesmo conte\u00fado, mas com todas as letras min\u00fasculas convertidas para mai\u00fasculas. Os nomes dos arquivos ser\u00e3o fornecidos, via teclado, pelo usu\u00e1rio. A fun\u00e7\u00e3o que converte min\u00fascula para mai\u00fascula \u00e9 o toupper(). Ela \u00e9 aplicada em cada caractere da string. \\end{lab}\\] \\[\\begin{lab} Fa\u00e7a um programa no qual o usu\u00e1rio informa o nome do arquivo, e uma palavra, e retorne o n\u00famero de vezes que aquela palavra aparece no arquivo. \\end{lab}\\] \\chapter{Navega\u00e7\u00e3o dentro do arquivo} Embora seja poss\u00edvel trabalhar com arquivos usando apenas as ferramentas apresentadas at\u00e9 agora, alguns problemas s\u00e3o de dif\u00edcil resolu\u00e7\u00e3o, a n\u00e3o ser que extendamos nosso conhecimento. Suponha por exemplo que voc\u00ea tenha o seguinte arquivo: \\[\\begin{verbatim} O rato roeu a roupa do rei de Roma e a rainha Ruinha resolveu rir-se pois o rei que remente suas ro\u00eddas roupagens. \\end{verbatim}\\] Observe que todas as linhas tem o mesmo tamanho (22 caracteres) e que a palavra ``remende'' est\u00e1 escrita de forma incorreta. Para corrigir esta palavra, podemos reescrever toda a frase, ou posicionar o cursor do arquivo exatamente sobre o caractere errado e corrigi-lo. H\u00e1 v\u00e1rias formas de se fazer isso, como veremos agora.","title":"{Laborat\u00f3rio}"},{"location":"intro/#posicionamento-no-arquivo","text":"Como visto no cap\u00edtulo anterior, opera\u00e7\u00f5es de leitura e escrita no arquivo v\u00e3o mudando a posi\u00e7\u00e3o em que as pr\u00f3ximas opera\u00e7\u00f5es ser\u00e3o executadas. Isto \u00e9, se considerarmos que h\u00e1 um cursor dentro do arquivo, na posi\u00e7\u00e3o em escreveremos, caso uma escrita seja feita, ou leremos, caso uma leitura seja executada, ent\u00e3o se lermos ou escrevermos 3 caracteres, ent\u00e3o o cursor ``andar\u00e1'' 3 caracteres. Se quisermos colocar o cursor no fim do arquivo, podemos reabr\u00ed-lo usando \\lstinline|ios::app|. Caso queiramos colocar o cursor no come\u00e7o do arquivo, podemos simplesmente reabri-lo sem especificar qualquer op\u00e7\u00e3o ou usando \\lstinline|ios::trunc| (e com isso tamb\u00e9m zerarmos nosso arquivo). Caso precisemos posicionar o cursor no meio do arquivo, podemos usar a fun\u00e7\u00e3o \\lstinline|seekg|, que pode ser usada duas formas: \\begin{verbatim} seekg(nova posi\u00e7\u00e3o [em bytes]) seekg(diferen\u00e7a [em bytes] em rela\u00e7\u00e3o ao marco, marco) \\end{verbatim} Na primeira forma voc\u00ea pode especificar onde o cursor deve ser posicionado em rela\u00e7\u00e3o ao in\u00edcio do arquivo, em n\u00famero de bytes. Por exemplo, \\lstinline|arq.seekg(10)| posiciona o cursor no d\u00e9cimo byte do arquivo \\lstinline|arq|. J\u00e1 pela segunda forma, voc\u00ea especifica onde posicionar o cursor em rela\u00e7\u00e3o a um marco no arquivo, que pode ser seu in\u00edcio (\\lstinline|ios_base::beg|), fim (\\lstinline|ios_base::end|), ou posi\u00e7\u00e3o atual (\\lstinline|ios_base::cur|). A diferen\u00e7a em rela\u00e7\u00e3o ao marco \u00e9 especificada como um inteiro com sinal. Por exemplo, \\lstinline|arq.seekg(-10,ios_base::end)| posiciona o cursor no d\u00e9cimo caractere \\emph{antes do fim} do arquivo \\lstinline|arq|. Para resolver o problema apresentado acima, podemos ent\u00e3o usar as seguintes solu\u00e7\u00f5es. \\begin{lstlisting}","title":"{Posicionamento no arquivo}"},{"location":"intro/#include_54","text":"","title":"include "},{"location":"intro/#include_55","text":"using namespace std; int main() { fstream arq; arq.open(\"arquivo.txt\"); //Posicionando o cursor no inicio. arq.seekg(23*3+20); arq << 'd'; arq.close(); arq.open(\"arquivo.txt\"); //Buscando a partir do fim. arq.seekg(-23-3, ios_base::end); arq << 'd'; arq.close(); arq.open(\"arquivo.txt\", ios::out | ios::trunc); //Recriando o arquivo. arq << \"O rato roeu a roupa do\" << endl << \"rei de Roma e a rainha\" << endl << \"Ruinha resolveu rir-se\" << endl << \"pois o rei que remende\" << endl << \"suas roidas roupagens.\"; arq.close(); return 0; } \" \\end{lstlisting}","title":"include "},{"location":"intro/#arquivos-formatados","text":"Para que se possa movimentar o cursor dentro de um arquivo, \u00e9 importante que se conhe\u00e7a a estrutura do mesmo, principalmente se pretender sobrescrev\u00ea-lo sem destru\u00ed-lo. Por exemplo, considere o seguinte problema. Escrever um programa que leia matr\u00edcula e nome de alunos do curso de Engenharia Qu\u00edmica e armazene estas informa\u00e7\u00f5es em um arquivo. Em seguida, seu programa deve escrever todas as informa\u00e7\u00f5es na tela, precedidas por um n\u00famero identificando cada aluno. Finalmente, o programa deve ler n\u00fameros correspondentes a alunos e sobrescrever os dados do aluno com novas informa\u00e7\u00f5es. \\begin{lstlisting}","title":"{Arquivos formatados}"},{"location":"intro/#include_56","text":"","title":"include "},{"location":"intro/#include_57","text":"","title":"include "},{"location":"intro/#define-nome_arq-arquivotxt","text":"using namespace std; bool mais_info() { char resp = 'x'; cout << \"Entrar com mais informacoes? (s/n)\"; while(true) { cin >> resp; switch(resp) { case 's': case 'S': return true; case 'n': case 'N': return false; } } } void ler_aluno(char mat[], int tmat, char nome[], int tnome) { cin.ignore(1000,'\\n'); cin.clear(); cout << \"Digite a matricula (max \" << tmat-1 << \" caracteres:)\"; cin.getline(mat,tmat); cout << \"Digite o nome (max \" << tnome-1 << \" caracteres\"; cin.getline(nome,tnome); } int main() { fstream arq; int totalcount = 0; int count; char linha[1000]; char mat[15]; char nome[100]; arq.open(NOME_ARQ); if(! arq.is_open()) arq.open(NOME_ARQ, ios::in | ios::out | ios::trunc); while(mais_info()) { ler_aluno(mat, 15, nome, 100); arq << mat << \" \" << nome << endl; } count = 1; arq.clear(); arq.seekg(0); cout << \"Dados atuais\" << endl; while(arq.getline(linha,1000)) { cout << count++ << \" - \"<< linha << endl; totalcount++; } while(mais_info()) { cout << \"Sobrescrever qual linha?\"; cin >> count; if(count > totalcount) { cout << \"Linha nao existente\"; } else { ler_aluno(mat, 15, nome, 100); arq.clear(); arq.seekg(0); while(count > 1) { arq.getline(linha,1000); count--; } arq << mat << \" \" << nome << endl; } } arq.clear(); count = 1; arq.seekg(0, arq.beg); cout << \"Dados atuais\" << endl; while(arq.getline(linha,1000)) { cout << count++ << \" - \"<< linha << endl; } return 0; } \\end{lstlisting} Este c\u00f3digo possui duas particularidades. Primeiro, ele usa a fun\u00e7\u00e3o \\lstinline|arq.clear()|, ainda n\u00e3o mencionada e, segundo, ele est\u00e1 errado. Toda vez que o arquivo \u00e9 lido at\u00e9 o seu fim, seu estado interno \u00e9 mudado para identificar o fato. Isto \u00e9 verific\u00e1vel pela fun\u00e7\u00e3o \\lstinline|arq.eof()|, que testa se o arquivo chegou ao \\emph{end of file}. Quando isso \u00e9 verdade, as fun\u00e7\u00f5es de reposicionamento n\u00e3o funcionar\u00e3o, a n\u00e3o ser que este status seja reiniciado, o que \u00e9 feito com a fun\u00e7\u00e3o \\lstinline|clear()|. No c\u00f3digo simplesmente usamos esta fun\u00e7\u00e3o sempre que formos fazer um \\emph{seek}, por simplicidade. Sobre o c\u00f3digo n\u00e3o funcionar como esperado, execute-o e insira um aluno apenas, com matr\u00edcula \"aaaaaaaaaa\" e nome \"bbbbbbbbbb\". Em seguida, altere os dados da linha 1 e insira matr\u00edcula \"cc\" e nome \"dd\". Ao final, os dados impressos ser\u00e3o os seguintes: \\[\\begin{verbatim} Dados atuais 1 - cc dd 2 - aaaa bbbbbbbbbb \\end{verbatim}\\]","title":"define NOME_ARQ \"arquivo.txt\""},{"location":"intro/#exercicios_16","text":"","title":"{Exerc\u00edcios}"},{"location":"intro/#_15","text":"Corrija o programa exemplo mostrado acima para que escreva sempre linhas de um mesmo tamanho e que, portanto, n\u00e3o tenha o problema de fragmenta\u00e7\u00e3o de registros. \\[\\begin{tabular}{l-l} ios::ate & Posiciona no fim do arquivo. Se n\u00e3o for usado, \u00e9 posicionado no in\u00edcio.\\\\ \\end{tabular}\\]","title":"{}"},{"location":"intro/#arquivos-binarios","text":"\\[\\begin{tabular}{l-l} ios::binary & Modo n\u00e3o formatado. (Pr\u00f3ximo cap\u00edtulo)\\\\ \\end{tabular}\\] O argumento \\lstinline{nome_do_arquivo} \u00e9 o caminho do arquivo que se deseja abrir, e \\lstinline{modo_de_abertura} representa como o arquivo ser\u00e1 aberto, de acordo com a tabela a seguir: \\begin{table}[h] \\centering \\begin{tabular}{|c|l|}\\hline \\textbf{Modo} & \\textbf{Descri\u00e7\u00e3o}\\\\hline r & Abre arquivo texto somente para leitura\\\\hline w & Cria arquivo texto somente para escrita\\\\hline a & Anexa dados a um arquivo texto\\\\hline r+ & Abre arquivo texto para leitura e escrita\\\\hline w+ & Cria arquivo onde poder\u00e3o ser realizadas leituras e escritas\\\\hline a+ & Anexa dados a um arquivo texto ou cria um para leitura e escrita\\\\hline \\end{tabular} \\caption{Modos de abertura de arquivo texto em C.} \\label{tab:fopen_modes} \\end{table} \\subsubsection{Fechamento de Arquivo} Um arquivo aberto sempre deve ser fechado antes do fim do programa. A fun\u00e7\u00e3o que realiza essa tarefa \u00e9 \\lstinline{fclose}. Seu prot\u00f3tipo \u00e9: \\lstinline{int fclose(FILE *arq);} O argumento \\lstinline{arq} \u00e9 a vari\u00e1vel que representa o arquivo aberto (com \\lstinline{fopen}) O retorno dessa fun\u00e7\u00e3o \u00e9 zero em caso de sucesso. Qualquer valor diferente de zero, significa erro. \\subsubsection{Leitura e Escrita de Arquivo} A fun\u00e7\u00e3o \\lstinline{fputc} escreve um caractere em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fputc(char ch, FILE *arq);| A fun\u00e7\u00e3o \\lstinline{fputs} escreve um cadeia de caracteres em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|char *fputs(char *cadeia, FILE *arq);| A fun\u00e7\u00e3o \\lstinline{fgetc} l\u00ea um caractere em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fgetc(FILE *arq);| A fun\u00e7\u00e3o \\lstinline{fgets} l\u00ea um cadeia de caracteres em um arquivo. Seu prot\u00f3tipo \u00e9:\\ \\verb|char *fgets(char *cadeia, int tam, FILE *arq);|, onde \\lstinline{tam} define o tamanho da cadeia que ser\u00e1 lida: tam-1 ou fim de linha, o que ocorrer primeiro. A fun\u00e7\u00e3o \\lstinline{fprintf} permite escrever em um arquivo da mesma forma que escrevemos na tela com o \\lstinline{printf}. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fprintf(FILE *arq, char *formato, ...);| A fun\u00e7\u00e3o \\lstinline{fscanf} l\u00ea informa\u00e7\u00f5es de um arquivo da mesma forma que lemos do teclado com o \\lstinline{scanf}. Seu prot\u00f3tipo \u00e9:\\ \\verb|int fscanf(FILE *arq, char *formato, ...);| \\subsubsection{Exemplos} \\begin{lstlisting}","title":"{Arquivos bin\u00e1rios}"},{"location":"intro/#include_58","text":"","title":"include "},{"location":"intro/#include_59","text":"int main(){ FILE *arq; char nome1[20], nome2[20], linha[20]; arq = fopen(\"teste.txt\", \"w\"); printf(\"entre nome1: \"); scanf(\"%s\", nome1); printf(\"entre nome2: \"); scanf(\"%s\", nome2); fputs(nome1, arq); fputs(\"\\n\", arq); fputs(nome2, arq); fclose(arq); arq = fopen(\"teste.txt\", \"r\"); printf(\"lendo do arquivo:\\n\"); fgets(linha, 20, arq); printf(\"\\tnome1: %s\", linha); fgets(linha, 20, arq); printf(\"\\tnome2: %s\\n\", linha); return 0; } \\end{lstlisting} \\begin{lstlisting}","title":"include "},{"location":"intro/#include_60","text":"","title":"include "},{"location":"intro/#include_61","text":"int main(){ FILE *arq; char nome1[20], nome2[20], linha[20]; arq = fopen(\"teste.txt\", \"w\"); printf(\"entre nome1: \"); scanf(\"%s\", nome1); printf(\"entre nome2: \"); scanf(\"%s\", nome2); fprintf(arq, \"%s\\n%s\", nome1, nome2); fclose(arq); arq = fopen(\"teste.txt\", \"r\"); printf(\"lendo do arquivo:\\n\"); fscanf(arq, \"%s\", nome1); fscanf(arq, \"%s\", nome2); printf(\"nome1: %s\\nnome2: %s\\n\", nome1, nome2); return 0; } \\end{lstlisting} \\part{Avan\u00e7ado: Estruturas de dados} \\chapter{Aloca\u00e7\u00e3o Din\u00e2mica} Aloca\u00e7\u00e3o de arranjos multi-dimensionais (caso n\u00e3o cont\u00edguo) \\chapter{BigNum} Lembrar limites de vari\u00e1veis n\u00famericas. Implementando fun\u00e7\u00f5es para manipula\u00e7\u00e3o de n\u00fameros gigantescos. \\chapter{Listas} \\chapter{Filas} \\chapter{Pilhas} \\chapter{\u00c1rvores}","title":"include "}]}